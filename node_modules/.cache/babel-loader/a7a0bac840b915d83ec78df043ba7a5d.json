{"ast":null,"code":"var _jsxFileName = \"/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js\";\nimport React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\nimport { supabase } from './supabaseClient';\nimport axios from 'axios';\n\n// --- IMPORTANT: Ensure TradingContext is EXPORTED here ---\nexport const TradingContext = createContext();\n\n// --- Finnhub API Key and Currency Symbol (consider moving API key to .env) ---\n// It's highly recommended to move FINNHUB_API_KEY to a .env file and access it via process.env.REACT_APP_FINNHUB_API_KEY\n// For demonstration, it's directly here, but for production, use .env!\nconst FINNHUB_API_KEY = 'd108911r01qhkqr8ggb0d108911r01qhkqr8ggbg';\nconst CURRENCY_SYMBOL = '$';\n\n// --- Helper function to validate Finnhub API Key ---\nconst isInvalidApiKey = key => {\n  return !key || key === \"YOUR_FINNHUB_API_KEY\" ||\n  // Check for placeholder text\n  key.length < 5 ||\n  // Basic length check\n  key.includes(\" \"); // No spaces\n};\nexport const TradingDataProvider = ({\n  children,\n  user\n}) => {\n  // --- State Variables ---\n  const [trades, setTrades] = useState([]); // Array of all trades\n  const [_capital, _setCapitalState] = useState(100000); // User's available paper trading capital\n  const [livePrices, setLivePrices] = useState({}); // Object of {symbol: price}\n  const [availableSymbols, setAvailableSymbols] = useState([]); // List of tradable symbols\n  const [symbolError, setSymbolError] = useState(\"\"); // Errors related to symbol/API fetches\n  const [loadingData, setLoadingData] = useState(true); // Tracks initial data loading state\n\n  // --- Memoized function to fetch user capital from Supabase ---\n  const fetchUserCapital = useCallback(async userId => {\n    if (!userId) {\n      // console.warn(\"No userId provided to fetchUserCapital. Setting capital to default.\"); // Removed console.warn\n      _setCapitalState(100000); // Default capital if no user ID\n      return;\n    }\n    try {\n      // console.log(\"Fetching user capital for userId:\", userId); // Removed console.log\n      const {\n        data: profile,\n        error\n      } = await supabase.from('profiles').select('paper_trading_capital').eq('id', userId).single();\n      if (error && error.code === 'PGRST116') {\n        // 'PGRST116' is the error code for no rows found with .single()\n        // console.log('No profile found for user, creating one with default capital (100000).'); // Removed console.log\n        const {\n          data: newProfile,\n          error: insertError\n        } = await supabase.from('profiles').insert({\n          id: userId,\n          paper_trading_capital: 100000\n        }).select('paper_trading_capital').single();\n        if (insertError) throw insertError; // Throw if new profile creation fails\n        _setCapitalState(newProfile.paper_trading_capital); // Set capital from newly created profile\n      } else if (error) {\n        throw error; // Throw other Supabase errors\n      } else if (profile) {\n        _setCapitalState(profile.paper_trading_capital); // Set capital from fetched profile\n        // console.log(\"Fetched user capital:\", profile.paper_trading_capital); // Removed console.log\n      }\n    } catch (error) {\n      console.error(\"Error fetching or creating user capital:\", error.message);\n      _setCapitalState(100000); // Fallback to default on error\n    }\n  }, []);\n\n  // --- Memoized function to update user capital in Supabase ---\n  // This function both updates the local state and syncs with the database\n  const setCapital = useCallback(async newCapitalValue => {\n    _setCapitalState(newCapitalValue); // Update local state immediately\n\n    if (user === null || user === void 0 ? void 0 : user.id) {\n      try {\n        // console.log(`Updating capital in DB for user ${user.id} to ${newCapitalValue}`); // Removed console.log\n        const {\n          error\n        } = await supabase.from('profiles').update({\n          paper_trading_capital: newCapitalValue\n        }).eq('id', user.id);\n        if (error) {\n          console.error(\"Error updating capital in database:\", error.message);\n        }\n      } catch (err) {\n        console.error(\"Error updating capital in database (catch block):\", err);\n      }\n    }\n  }, [user]);\n\n  // --- Memoized function to fetch trades for the current user ---\n  const fetchTrades = useCallback(async () => {\n    if (!user || !user.id) {\n      // console.log(\"No user ID available to fetch trades.\"); // Removed console.log\n      return [];\n    }\n    // console.log(\"Fetching trades for user:\", user.id); // Removed console.log\n    const {\n      data,\n      error\n    } = await supabase.from(\"trades\").select(\"*\").eq(\"user_id\", user.id).order(\"created_at\", {\n      ascending: true\n    }); // Order by creation for FIFO consistency\n\n    if (error) {\n      console.error(\"Error fetching trades:\", error);\n      return [];\n    } else {\n      // console.log(\"Trades fetched:\", data); // Removed console.log\n      return data || [];\n    }\n  }, [user]);\n\n  // --- Memoized function to fetch all tradable symbols from Finnhub ---\n  const fetchAvailableSymbols = useCallback(async () => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      setSymbolError(\"Finnhub API key is invalid or not set. Cannot fetch available symbols.\");\n      // console.warn(\"Finnhub API key is invalid or not set. Skipping symbol fetch.\"); // Removed console.warn\n      return [];\n    }\n    try {\n      // console.log(\"Fetching available US market symbols from Finnhub...\"); // Removed console.log\n      const response = await axios.get(`https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`);\n      if (response.data && Array.isArray(response.data)) {\n        // Filter for common stocks, valid symbols, and exclude those with '.' or '-'\n        const usSymbols = response.data.filter(s => s.type === \"Common Stock\" && s.symbol && !s.symbol.includes(\".\") && !s.symbol.includes(\"-\")).map(s => s.symbol);\n        setSymbolError(\"\"); // Clear any previous symbol errors\n        // console.log(`Fetched ${usSymbols.length} US symbols.`); // Removed console.log\n        return usSymbols;\n      } else {\n        setSymbolError(\"No valid symbol data received from Finnhub.\");\n        return [];\n      }\n    } catch (error) {\n      console.error(\"Error fetching available symbols:\", error);\n      // Specific error handling for API limits\n      if (error.response && error.response.status === 429) {\n        setSymbolError(\"Finnhub API limit exceeded for symbols. Please wait or upgrade plan.\");\n      } else {\n        setSymbolError(`Failed to fetch available symbols from Finnhub. Check API key and network. Error: ${error.message}`);\n      }\n      return [];\n    }\n  }, [FINNHUB_API_KEY]);\n\n  // --- Memoized function to fetch live prices for given symbols ---\n  const fetchLivePrices = useCallback(async symbols => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      // console.warn(\"Finnhub API key is invalid. Skipping live price fetch.\"); // Removed console.warn\n      return;\n    }\n    if (!symbols || symbols.length === 0) {\n      setLivePrices({}); // Clear live prices if no symbols to fetch\n      return;\n    }\n    ;\n    try {\n      const newPrices = {};\n      // Fetch prices for each symbol individually (Finnhub 'quote' endpoint is per-symbol)\n      // This is a potential area for optimization if many symbols are watched (e.g., using WebSockets)\n      await Promise.all(symbols.map(async symbol => {\n        // console.log(`Fetching price for ${symbol}...`); // Removed console.log\n        const response = await axios.get(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`);\n        if (response.data && response.data.c > 0) {\n          // 'c' is the current price\n          newPrices[symbol] = response.data.c;\n        } else {\n          console.warn(`No valid live price found for ${symbol}. Response:`, response.data);\n          newPrices[symbol] = null; // Indicate no price found\n        }\n      }));\n      setLivePrices(prevPrices => ({\n        ...prevPrices,\n        ...newPrices\n      }));\n      setSymbolError(\"\"); // Clear symbol errors if prices are fetched successfully\n    } catch (error) {\n      console.error(\"Error fetching live prices:\", error);\n      // Specific error handling for API limits\n      if (error.response && error.response.status === 429) {\n        setSymbolError(\"Finnhub API limit exceeded for live prices. Displayed prices may be stale.\");\n      } else {\n        setSymbolError(`Failed to fetch live prices: ${error.message || 'Network error'}`);\n      }\n    }\n  }, [FINNHUB_API_KEY]);\n\n  // --- Function to remove a trade from history ---\n  // This function adjusts capital and refreshes trade data to ensure consistency.\n  const removeTrade = useCallback(async tradeToRemove => {\n    const {\n      id,\n      symbol,\n      quantity,\n      price,\n      type\n    } = tradeToRemove; // Destructure trade details\n\n    try {\n      // 1. Delete the trade from Supabase\n      const {\n        error: deleteError\n      } = await supabase.from('trades').delete().eq('id', id); // Identify trade by its unique ID\n\n      if (deleteError) throw deleteError;\n\n      // 2. Calculate the capital adjustment needed to reverse the trade\n      let capitalAdjustment = 0;\n      if (type === 'buy') {\n        capitalAdjustment = quantity * price; // For a buy, capital returns (cost)\n      } else if (type === 'sell') {\n        capitalAdjustment = -(quantity * price); // For a sell, capital decreases (proceeds removed)\n      }\n\n      // 3. Update capital in context and database\n      const newCapital = _capital + capitalAdjustment;\n      await setCapital(newCapital); // This function also updates the DB\n\n      // 4. Re-fetch all trades to ensure the trades state is consistent after deletion\n      const updatedTrades = await fetchTrades();\n      setTrades(updatedTrades); // Update the trades state in the context\n\n      console.log(`Trade ${id} (${type} ${symbol} ${quantity}@${price}) removed.`);\n      console.log(`Capital adjusted by ${CURRENCY_SYMBOL}${capitalAdjustment.toFixed(2)}. New capital: ${CURRENCY_SYMBOL}${newCapital.toFixed(2)}`);\n    } catch (error) {\n      console.error(\"Error removing trade:\", error.message);\n      // Re-throw to allow component to catch and display error\n      throw new Error(`Failed to remove trade: ${error.message || \"An unexpected error occurred.\"}`);\n    }\n  }, [user, _capital, setCapital, fetchTrades, setTrades]);\n\n  // --- Initial Data Fetching Effect ---\n  useEffect(() => {\n    // console.log(\"TradingDataProvider useEffect triggered. User:\", user); // Removed console.log\n    if (user && user.id) {\n      // Only fetch data if user is authenticated and has an ID\n      setLoadingData(true); // Indicate data loading is in progress\n      // console.log(\"Starting initial data load for user:\", user.id); // Removed console.log\n\n      const initializeData = async () => {\n        try {\n          // Fetch capital, trades, and available symbols in parallel\n          const [fetchedTrades, fetchedSymbols] = await Promise.all([fetchTrades(), fetchAvailableSymbols(), fetchUserCapital(user.id) // Pass user.id to fetchUserCapital\n          ]);\n          setTrades(fetchedTrades); // Update trades state\n          setAvailableSymbols(fetchedSymbols); // Update available symbols state\n\n          // After fetching trades, determine which symbols need live prices\n          if (fetchedTrades.length > 0) {\n            const symbolsInHoldings = [...new Set(fetchedTrades.map(trade => trade.symbol))];\n            // console.log(\"Fetching live prices for symbols in holdings:\", symbolsInHoldings); // Removed console.log\n            fetchLivePrices(symbolsInHoldings); // Fetch live prices for current holdings\n          } else {\n            // console.log(\"No trades, so no symbols to fetch live prices for.\"); // Removed console.log\n            setLivePrices({}); // Clear live prices if no trades\n          }\n\n          // console.log(\"All initial data fetches complete.\"); // Removed console.log\n        } catch (error) {\n          console.error(\"Error during initial data fetch in TradingDataProvider:\", error);\n        } finally {\n          setLoadingData(false); // Set loading to false regardless of success/failure\n          // console.log(\"TradingDataProvider: setLoadingData(false) called.\"); // Removed console.log\n        }\n      };\n      initializeData();\n\n      // --- Set up interval for refreshing live prices ---\n      // This interval will run only if there are trades to fetch prices for\n      const livePriceInterval = setInterval(() => {\n        if (trades.length > 0) {\n          const symbolsInHoldings = [...new Set(trades.map(trade => trade.symbol))];\n          fetchLivePrices(symbolsInHoldings);\n        }\n      }, 15000); // Refresh every 15 seconds (adjust as per Finnhub limits and needs)\n\n      // Clean up interval on component unmount or user change\n      return () => clearInterval(livePriceInterval);\n    } else {\n      // If no user, reset all relevant states and stop loading\n      setTrades([]);\n      _setCapitalState(100000);\n      setLivePrices({});\n      setAvailableSymbols([]);\n      setSymbolError(\"\");\n      setLoadingData(false);\n      // console.log(\"No user or user ID, resetting data and setting loadingData to false.\"); // Removed console.log\n    }\n  }, [user, fetchTrades, fetchAvailableSymbols, fetchUserCapital, fetchLivePrices]); // Dependencies for this effect\n\n  // --- Memoized function to calculate holdings and P&L ---\n  // This logic is crucial and uses the 'trades' and 'livePrices' state\n  const calculatePnL = useCallback(() => {\n    const pnlSummary = {}; // Object to store holdings and realized PnL per symbol\n    let totalRealizedPnl = 0; // Overall realized PnL from all closed positions\n\n    // Iterate through all trades to build up holdings and calculate realized PnL\n    trades.forEach(trade => {\n      if (!pnlSummary[trade.symbol]) {\n        pnlSummary[trade.symbol] = {\n          netQty: 0,\n          // Current quantity held\n          realizedProfit: 0,\n          // Realized PnL for this symbol\n          buyQueue: [] // FIFO queue for buy lots (to determine cost basis)\n        };\n      }\n      if (trade.type === \"buy\") {\n        pnlSummary[trade.symbol].netQty += trade.quantity;\n        pnlSummary[trade.symbol].buyQueue.push({\n          quantity: trade.quantity,\n          price: trade.price,\n          tradeId: trade.id // Store trade ID for potential debugging or future features\n        });\n      } else if (trade.type === \"sell\") {\n        let remainingQtyToSell = trade.quantity;\n        let costBasisForThisSale = 0;\n\n        // FIFO (First-In, First-Out) logic for cost basis calculation\n        while (remainingQtyToSell > 0 && pnlSummary[trade.symbol].buyQueue.length > 0) {\n          const oldestBuy = pnlSummary[trade.symbol].buyQueue[0];\n          const qtyFromThisBuy = Math.min(oldestBuy.quantity, remainingQtyToSell);\n          costBasisForThisSale += qtyFromThisBuy * oldestBuy.price;\n          oldestBuy.quantity -= qtyFromThisBuy;\n          remainingQtyToSell -= qtyFromThisBuy;\n          if (oldestBuy.quantity === 0) {\n            pnlSummary[trade.symbol].buyQueue.shift(); // Remove lot if fully sold\n          }\n        }\n        pnlSummary[trade.symbol].netQty -= trade.quantity; // Update net quantity held\n\n        const realizedProfitForThisSell = trade.quantity * trade.price - costBasisForThisSale;\n        pnlSummary[trade.symbol].realizedProfit += realizedProfitForThisSell; // Accumulate realized PnL for symbol\n        totalRealizedPnl += realizedProfitForThisSell; // Accumulate total realized PnL\n      }\n    });\n\n    // Convert the summary object into an array of holdings for display\n    const holdings = Object.entries(pnlSummary).map(([symbol, data]) => {\n      let avgBuyPrice = 0;\n      let remainingBuyCost = 0;\n      let remainingBuyQty = 0;\n      // Calculate average buy price for remaining open positions\n      data.buyQueue.forEach(lot => {\n        remainingBuyCost += lot.quantity * lot.price;\n        remainingBuyQty += lot.quantity;\n      });\n      if (remainingBuyQty > 0) {\n        avgBuyPrice = remainingBuyCost / remainingBuyQty;\n      } else {\n        avgBuyPrice = 0; // No open positions for this symbol\n      }\n      const currentPrice = livePrices[symbol];\n      const currentMarketValue = data.netQty > 0 && currentPrice ? data.netQty * currentPrice : 0;\n      let unrealizedPnl = 0;\n      if (data.netQty > 0 && currentPrice && avgBuyPrice !== 0) {\n        unrealizedPnl = currentMarketValue - avgBuyPrice * data.netQty;\n      }\n      return {\n        symbol,\n        netQty: data.netQty,\n        avgBuyPrice: avgBuyPrice.toFixed(2),\n        realizedPnl: data.realizedProfit.toFixed(2),\n        unrealizedPnl: unrealizedPnl.toFixed(2),\n        currentMarketValue: currentMarketValue.toFixed(2)\n      };\n    })\n    // Filter out symbols with 0 net quantity (fully closed positions)\n    .filter(holding => holding.netQty !== 0).sort((a, b) => a.symbol.localeCompare(b.symbol)); // Sort holdings by symbol\n\n    // Calculate total unrealized PnL from all current holdings\n    let totalUnrealizedPnl = holdings.reduce((sum, h) => sum + parseFloat(h.unrealizedPnl || 0), 0);\n    return {\n      holdings: holdings,\n      // Array of current open holdings\n      totalRealizedPnl: totalRealizedPnl.toFixed(2),\n      // Total realized PnL across all symbols\n      totalUnrealizedPnl: totalUnrealizedPnl.toFixed(2) // Total unrealized PnL across all symbols\n    };\n  }, [trades, livePrices]); // Recalculate when trades or livePrices change\n\n  // --- Memoized function to calculate the total portfolio value ---\n  const calculateTotalPortfolioValue = useCallback(() => {\n    const {\n      holdings,\n      totalUnrealizedPnl\n    } = calculatePnL(); // Use the memoized calculatePnL\n    // Total portfolio value is cash + current market value of all holdings\n    // Note: totalUnrealizedPnl is already included in the `holdings` market value calculation\n    // So, it's safer to sum `_capital` and `holdingsValue` for clarity.\n    let holdingsValue = 0;\n    holdings.forEach(holding => {\n      holdingsValue += parseFloat(holding.currentMarketValue);\n    });\n    return (_capital + holdingsValue).toFixed(2);\n  }, [_capital, calculatePnL]);\n\n  // --- Context Value ---\n  // This object contains all the states and functions that components using the context can access\n  const value = {\n    trades,\n    setTrades,\n    // Allow components to update trades if needed (though fetchTrades is preferred)\n    capital: _capital,\n    // Expose capital as 'capital'\n    setCapital,\n    // Expose capital setter for manual updates\n    livePrices,\n    setLivePrices,\n    // Allow components to update live prices if needed\n    availableSymbols,\n    symbolError,\n    setSymbolError,\n    fetchTrades,\n    fetchAvailableSymbols,\n    fetchLivePrices,\n    calculatePnL,\n    // Expose PnL calculation utility\n    isInvalidApiKey,\n    // Expose API key validation\n    FINNHUB_API_KEY,\n    // Expose API key (for debug/info, consider removing for production)\n    CURRENCY_SYMBOL,\n    // Expose currency symbol\n    loadingData,\n    // Expose data loading status\n    calculateTotalPortfolioValue,\n    // Expose total portfolio value calculation\n    removeTrade // --- NEW: Expose the removeTrade function ---\n  };\n  return /*#__PURE__*/React.createElement(TradingContext.Provider, {\n    value: value,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 443,\n      columnNumber: 5\n    }\n  }, children);\n};\n\n// --- Custom Hook to easily consume the TradingContext ---\nexport const useTradingData = () => {\n  const context = useContext(TradingContext);\n  if (!context) {\n    throw new Error('useTradingData must be used within a TradingDataProvider');\n  }\n  return context;\n};","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useCallback","supabase","axios","TradingContext","FINNHUB_API_KEY","CURRENCY_SYMBOL","isInvalidApiKey","key","length","includes","TradingDataProvider","children","user","trades","setTrades","_capital","_setCapitalState","livePrices","setLivePrices","availableSymbols","setAvailableSymbols","symbolError","setSymbolError","loadingData","setLoadingData","fetchUserCapital","userId","data","profile","error","from","select","eq","single","code","newProfile","insertError","insert","id","paper_trading_capital","console","message","setCapital","newCapitalValue","update","err","fetchTrades","order","ascending","fetchAvailableSymbols","response","get","Array","isArray","usSymbols","filter","s","type","symbol","map","status","fetchLivePrices","symbols","newPrices","Promise","all","c","warn","prevPrices","removeTrade","tradeToRemove","quantity","price","deleteError","delete","capitalAdjustment","newCapital","updatedTrades","log","toFixed","Error","initializeData","fetchedTrades","fetchedSymbols","symbolsInHoldings","Set","trade","livePriceInterval","setInterval","clearInterval","calculatePnL","pnlSummary","totalRealizedPnl","forEach","netQty","realizedProfit","buyQueue","push","tradeId","remainingQtyToSell","costBasisForThisSale","oldestBuy","qtyFromThisBuy","Math","min","shift","realizedProfitForThisSell","holdings","Object","entries","avgBuyPrice","remainingBuyCost","remainingBuyQty","lot","currentPrice","currentMarketValue","unrealizedPnl","realizedPnl","holding","sort","a","b","localeCompare","totalUnrealizedPnl","reduce","sum","h","parseFloat","calculateTotalPortfolioValue","holdingsValue","value","capital","createElement","Provider","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","useTradingData","context"],"sources":["/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\nimport { supabase } from './supabaseClient';\nimport axios from 'axios';\n\n// --- IMPORTANT: Ensure TradingContext is EXPORTED here ---\nexport const TradingContext = createContext();\n\n// --- Finnhub API Key and Currency Symbol (consider moving API key to .env) ---\n// It's highly recommended to move FINNHUB_API_KEY to a .env file and access it via process.env.REACT_APP_FINNHUB_API_KEY\n// For demonstration, it's directly here, but for production, use .env!\nconst FINNHUB_API_KEY = 'd108911r01qhkqr8ggb0d108911r01qhkqr8ggbg';\nconst CURRENCY_SYMBOL = '$';\n\n// --- Helper function to validate Finnhub API Key ---\nconst isInvalidApiKey = (key) => {\n  return !key ||\n         key === \"YOUR_FINNHUB_API_KEY\" || // Check for placeholder text\n         key.length < 5 || // Basic length check\n         key.includes(\" \"); // No spaces\n};\n\nexport const TradingDataProvider = ({ children, user }) => {\n  // --- State Variables ---\n  const [trades, setTrades] = useState([]); // Array of all trades\n  const [_capital, _setCapitalState] = useState(100000); // User's available paper trading capital\n  const [livePrices, setLivePrices] = useState({}); // Object of {symbol: price}\n  const [availableSymbols, setAvailableSymbols] = useState([]); // List of tradable symbols\n  const [symbolError, setSymbolError] = useState(\"\"); // Errors related to symbol/API fetches\n  const [loadingData, setLoadingData] = useState(true); // Tracks initial data loading state\n\n  // --- Memoized function to fetch user capital from Supabase ---\n  const fetchUserCapital = useCallback(async (userId) => {\n    if (!userId) {\n      // console.warn(\"No userId provided to fetchUserCapital. Setting capital to default.\"); // Removed console.warn\n      _setCapitalState(100000); // Default capital if no user ID\n      return;\n    }\n    try {\n      // console.log(\"Fetching user capital for userId:\", userId); // Removed console.log\n      const { data: profile, error } = await supabase\n        .from('profiles')\n        .select('paper_trading_capital')\n        .eq('id', userId)\n        .single();\n\n      if (error && error.code === 'PGRST116') { // 'PGRST116' is the error code for no rows found with .single()\n        // console.log('No profile found for user, creating one with default capital (100000).'); // Removed console.log\n        const { data: newProfile, error: insertError } = await supabase\n          .from('profiles')\n          .insert({ id: userId, paper_trading_capital: 100000 })\n          .select('paper_trading_capital')\n          .single();\n        \n        if (insertError) throw insertError; // Throw if new profile creation fails\n        _setCapitalState(newProfile.paper_trading_capital); // Set capital from newly created profile\n      } else if (error) {\n        throw error; // Throw other Supabase errors\n      } else if (profile) {\n        _setCapitalState(profile.paper_trading_capital); // Set capital from fetched profile\n        // console.log(\"Fetched user capital:\", profile.paper_trading_capital); // Removed console.log\n      }\n    } catch (error) {\n      console.error(\"Error fetching or creating user capital:\", error.message);\n      _setCapitalState(100000); // Fallback to default on error\n    }\n  }, []);\n\n  // --- Memoized function to update user capital in Supabase ---\n  // This function both updates the local state and syncs with the database\n  const setCapital = useCallback(async (newCapitalValue) => {\n    _setCapitalState(newCapitalValue); // Update local state immediately\n\n    if (user?.id) {\n      try {\n        // console.log(`Updating capital in DB for user ${user.id} to ${newCapitalValue}`); // Removed console.log\n        const { error } = await supabase\n          .from('profiles')\n          .update({ paper_trading_capital: newCapitalValue })\n          .eq('id', user.id);\n\n        if (error) {\n          console.error(\"Error updating capital in database:\", error.message);\n        }\n      } catch (err) {\n        console.error(\"Error updating capital in database (catch block):\", err);\n      }\n    }\n  }, [user]);\n\n  // --- Memoized function to fetch trades for the current user ---\n  const fetchTrades = useCallback(async () => {\n    if (!user || !user.id) {\n      // console.log(\"No user ID available to fetch trades.\"); // Removed console.log\n      return [];\n    }\n    // console.log(\"Fetching trades for user:\", user.id); // Removed console.log\n    const { data, error } = await supabase\n      .from(\"trades\")\n      .select(\"*\")\n      .eq(\"user_id\", user.id)\n      .order(\"created_at\", { ascending: true }); // Order by creation for FIFO consistency\n\n    if (error) {\n      console.error(\"Error fetching trades:\", error);\n      return [];\n    } else {\n      // console.log(\"Trades fetched:\", data); // Removed console.log\n      return data || [];\n    }\n  }, [user]);\n\n  // --- Memoized function to fetch all tradable symbols from Finnhub ---\n  const fetchAvailableSymbols = useCallback(async () => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      setSymbolError(\"Finnhub API key is invalid or not set. Cannot fetch available symbols.\");\n      // console.warn(\"Finnhub API key is invalid or not set. Skipping symbol fetch.\"); // Removed console.warn\n      return [];\n    }\n    \n    try {\n      // console.log(\"Fetching available US market symbols from Finnhub...\"); // Removed console.log\n      const response = await axios.get(\n        `https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`\n      );\n      if (response.data && Array.isArray(response.data)) {\n        // Filter for common stocks, valid symbols, and exclude those with '.' or '-'\n        const usSymbols = response.data\n          .filter(\n            (s) =>\n              s.type === \"Common Stock\" &&\n              s.symbol &&\n              !s.symbol.includes(\".\") &&\n              !s.symbol.includes(\"-\")\n          )\n          .map((s) => s.symbol);\n        setSymbolError(\"\"); // Clear any previous symbol errors\n        // console.log(`Fetched ${usSymbols.length} US symbols.`); // Removed console.log\n        return usSymbols;\n      } else {\n        setSymbolError(\"No valid symbol data received from Finnhub.\");\n        return [];\n      }\n    } catch (error) {\n      console.error(\"Error fetching available symbols:\", error);\n      // Specific error handling for API limits\n      if (error.response && error.response.status === 429) {\n        setSymbolError(\"Finnhub API limit exceeded for symbols. Please wait or upgrade plan.\");\n      } else {\n        setSymbolError(\n          `Failed to fetch available symbols from Finnhub. Check API key and network. Error: ${error.message}`\n        );\n      }\n      return [];\n    }\n  }, [FINNHUB_API_KEY]);\n\n  // --- Memoized function to fetch live prices for given symbols ---\n  const fetchLivePrices = useCallback(async (symbols) => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      // console.warn(\"Finnhub API key is invalid. Skipping live price fetch.\"); // Removed console.warn\n      return;\n    }\n    if (!symbols || symbols.length === 0) {\n        setLivePrices({}); // Clear live prices if no symbols to fetch\n        return;\n    };\n\n    try {\n      const newPrices = {};\n      // Fetch prices for each symbol individually (Finnhub 'quote' endpoint is per-symbol)\n      // This is a potential area for optimization if many symbols are watched (e.g., using WebSockets)\n      await Promise.all(\n        symbols.map(async (symbol) => {\n          // console.log(`Fetching price for ${symbol}...`); // Removed console.log\n          const response = await axios.get(\n            `https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`\n          );\n          if (response.data && response.data.c > 0) { // 'c' is the current price\n            newPrices[symbol] = response.data.c;\n          } else {\n            console.warn(`No valid live price found for ${symbol}. Response:`, response.data);\n            newPrices[symbol] = null; // Indicate no price found\n          }\n        })\n      );\n      setLivePrices((prevPrices) => ({ ...prevPrices, ...newPrices }));\n      setSymbolError(\"\"); // Clear symbol errors if prices are fetched successfully\n\n    } catch (error) {\n      console.error(\"Error fetching live prices:\", error);\n      // Specific error handling for API limits\n      if (error.response && error.response.status === 429) {\n        setSymbolError(\"Finnhub API limit exceeded for live prices. Displayed prices may be stale.\");\n      } else {\n        setSymbolError(`Failed to fetch live prices: ${error.message || 'Network error'}`);\n      }\n    }\n  }, [FINNHUB_API_KEY]);\n\n  // --- Function to remove a trade from history ---\n  // This function adjusts capital and refreshes trade data to ensure consistency.\n  const removeTrade = useCallback(async (tradeToRemove) => {\n    const { id, symbol, quantity, price, type } = tradeToRemove; // Destructure trade details\n    \n    try {\n      // 1. Delete the trade from Supabase\n      const { error: deleteError } = await supabase\n        .from('trades')\n        .delete()\n        .eq('id', id); // Identify trade by its unique ID\n\n      if (deleteError) throw deleteError;\n\n      // 2. Calculate the capital adjustment needed to reverse the trade\n      let capitalAdjustment = 0;\n      if (type === 'buy') {\n        capitalAdjustment = quantity * price; // For a buy, capital returns (cost)\n      } else if (type === 'sell') {\n        capitalAdjustment = -(quantity * price); // For a sell, capital decreases (proceeds removed)\n      }\n\n      // 3. Update capital in context and database\n      const newCapital = _capital + capitalAdjustment;\n      await setCapital(newCapital); // This function also updates the DB\n\n      // 4. Re-fetch all trades to ensure the trades state is consistent after deletion\n      const updatedTrades = await fetchTrades();\n      setTrades(updatedTrades); // Update the trades state in the context\n\n      console.log(`Trade ${id} (${type} ${symbol} ${quantity}@${price}) removed.`);\n      console.log(`Capital adjusted by ${CURRENCY_SYMBOL}${capitalAdjustment.toFixed(2)}. New capital: ${CURRENCY_SYMBOL}${newCapital.toFixed(2)}`);\n\n    } catch (error) {\n      console.error(\"Error removing trade:\", error.message);\n      // Re-throw to allow component to catch and display error\n      throw new Error(`Failed to remove trade: ${error.message || \"An unexpected error occurred.\"}`);\n    }\n  }, [user, _capital, setCapital, fetchTrades, setTrades]);\n\n\n  // --- Initial Data Fetching Effect ---\n  useEffect(() => {\n    // console.log(\"TradingDataProvider useEffect triggered. User:\", user); // Removed console.log\n    if (user && user.id) { // Only fetch data if user is authenticated and has an ID\n      setLoadingData(true); // Indicate data loading is in progress\n      // console.log(\"Starting initial data load for user:\", user.id); // Removed console.log\n      \n      const initializeData = async () => {\n        try {\n          // Fetch capital, trades, and available symbols in parallel\n          const [fetchedTrades, fetchedSymbols] = await Promise.all([\n            fetchTrades(),\n            fetchAvailableSymbols(),\n            fetchUserCapital(user.id) // Pass user.id to fetchUserCapital\n          ]);\n          \n          setTrades(fetchedTrades); // Update trades state\n          setAvailableSymbols(fetchedSymbols); // Update available symbols state\n          \n          // After fetching trades, determine which symbols need live prices\n          if (fetchedTrades.length > 0) {\n            const symbolsInHoldings = [...new Set(fetchedTrades.map(trade => trade.symbol))];\n            // console.log(\"Fetching live prices for symbols in holdings:\", symbolsInHoldings); // Removed console.log\n            fetchLivePrices(symbolsInHoldings); // Fetch live prices for current holdings\n          } else {\n            // console.log(\"No trades, so no symbols to fetch live prices for.\"); // Removed console.log\n            setLivePrices({}); // Clear live prices if no trades\n          }\n\n          // console.log(\"All initial data fetches complete.\"); // Removed console.log\n\n        } catch (error) {\n          console.error(\"Error during initial data fetch in TradingDataProvider:\", error);\n        } finally {\n          setLoadingData(false); // Set loading to false regardless of success/failure\n          // console.log(\"TradingDataProvider: setLoadingData(false) called.\"); // Removed console.log\n        }\n      };\n      initializeData();\n\n      // --- Set up interval for refreshing live prices ---\n      // This interval will run only if there are trades to fetch prices for\n      const livePriceInterval = setInterval(() => {\n        if (trades.length > 0) {\n            const symbolsInHoldings = [...new Set(trades.map(trade => trade.symbol))];\n            fetchLivePrices(symbolsInHoldings);\n        }\n      }, 15000); // Refresh every 15 seconds (adjust as per Finnhub limits and needs)\n\n      // Clean up interval on component unmount or user change\n      return () => clearInterval(livePriceInterval);\n\n    } else {\n        // If no user, reset all relevant states and stop loading\n        setTrades([]);\n        _setCapitalState(100000);\n        setLivePrices({});\n        setAvailableSymbols([]);\n        setSymbolError(\"\");\n        setLoadingData(false);\n        // console.log(\"No user or user ID, resetting data and setting loadingData to false.\"); // Removed console.log\n    }\n  }, [user, fetchTrades, fetchAvailableSymbols, fetchUserCapital, fetchLivePrices]); // Dependencies for this effect\n\n\n  // --- Memoized function to calculate holdings and P&L ---\n  // This logic is crucial and uses the 'trades' and 'livePrices' state\n  const calculatePnL = useCallback(() => {\n    const pnlSummary = {}; // Object to store holdings and realized PnL per symbol\n    let totalRealizedPnl = 0; // Overall realized PnL from all closed positions\n\n    // Iterate through all trades to build up holdings and calculate realized PnL\n    trades.forEach((trade) => {\n      if (!pnlSummary[trade.symbol]) {\n        pnlSummary[trade.symbol] = {\n          netQty: 0, // Current quantity held\n          realizedProfit: 0, // Realized PnL for this symbol\n          buyQueue: [], // FIFO queue for buy lots (to determine cost basis)\n        };\n      }\n\n      if (trade.type === \"buy\") {\n        pnlSummary[trade.symbol].netQty += trade.quantity;\n        pnlSummary[trade.symbol].buyQueue.push({\n            quantity: trade.quantity,\n            price: trade.price,\n            tradeId: trade.id // Store trade ID for potential debugging or future features\n        });\n      } else if (trade.type === \"sell\") {\n        let remainingQtyToSell = trade.quantity;\n        let costBasisForThisSale = 0;\n\n        // FIFO (First-In, First-Out) logic for cost basis calculation\n        while (remainingQtyToSell > 0 && pnlSummary[trade.symbol].buyQueue.length > 0) {\n            const oldestBuy = pnlSummary[trade.symbol].buyQueue[0];\n            const qtyFromThisBuy = Math.min(oldestBuy.quantity, remainingQtyToSell);\n\n            costBasisForThisSale += qtyFromThisBuy * oldestBuy.price;\n            oldestBuy.quantity -= qtyFromThisBuy;\n            remainingQtyToSell -= qtyFromThisBuy;\n\n            if (oldestBuy.quantity === 0) {\n                pnlSummary[trade.symbol].buyQueue.shift(); // Remove lot if fully sold\n            }\n        }\n        \n        pnlSummary[trade.symbol].netQty -= trade.quantity; // Update net quantity held\n        \n        const realizedProfitForThisSell = (trade.quantity * trade.price) - costBasisForThisSale;\n        pnlSummary[trade.symbol].realizedProfit += realizedProfitForThisSell; // Accumulate realized PnL for symbol\n        totalRealizedPnl += realizedProfitForThisSell; // Accumulate total realized PnL\n      }\n    });\n\n    // Convert the summary object into an array of holdings for display\n    const holdings = Object.entries(pnlSummary)\n      .map(([symbol, data]) => {\n        let avgBuyPrice = 0;\n        let remainingBuyCost = 0;\n        let remainingBuyQty = 0;\n        // Calculate average buy price for remaining open positions\n        data.buyQueue.forEach(lot => {\n            remainingBuyCost += lot.quantity * lot.price;\n            remainingBuyQty += lot.quantity;\n        });\n        if (remainingBuyQty > 0) {\n            avgBuyPrice = remainingBuyCost / remainingBuyQty;\n        } else {\n            avgBuyPrice = 0; // No open positions for this symbol\n        }\n\n        const currentPrice = livePrices[symbol];\n        const currentMarketValue = data.netQty > 0 && currentPrice ? (data.netQty * currentPrice) : 0;\n        \n        let unrealizedPnl = 0;\n        if (data.netQty > 0 && currentPrice && avgBuyPrice !== 0) {\n            unrealizedPnl = currentMarketValue - (avgBuyPrice * data.netQty);\n        }\n\n        return {\n          symbol,\n          netQty: data.netQty,\n          avgBuyPrice: avgBuyPrice.toFixed(2),\n          realizedPnl: data.realizedProfit.toFixed(2),\n          unrealizedPnl: unrealizedPnl.toFixed(2),\n          currentMarketValue: currentMarketValue.toFixed(2),\n        };\n      })\n      // Filter out symbols with 0 net quantity (fully closed positions)\n      .filter(holding => holding.netQty !== 0)\n      .sort((a, b) => a.symbol.localeCompare(b.symbol)); // Sort holdings by symbol\n\n    // Calculate total unrealized PnL from all current holdings\n    let totalUnrealizedPnl = holdings.reduce((sum, h) => sum + parseFloat(h.unrealizedPnl || 0), 0);\n    \n    return {\n      holdings: holdings, // Array of current open holdings\n      totalRealizedPnl: totalRealizedPnl.toFixed(2), // Total realized PnL across all symbols\n      totalUnrealizedPnl: totalUnrealizedPnl.toFixed(2), // Total unrealized PnL across all symbols\n    };\n  }, [trades, livePrices]); // Recalculate when trades or livePrices change\n\n  // --- Memoized function to calculate the total portfolio value ---\n  const calculateTotalPortfolioValue = useCallback(() => {\n    const { holdings, totalUnrealizedPnl } = calculatePnL(); // Use the memoized calculatePnL\n    // Total portfolio value is cash + current market value of all holdings\n    // Note: totalUnrealizedPnl is already included in the `holdings` market value calculation\n    // So, it's safer to sum `_capital` and `holdingsValue` for clarity.\n    let holdingsValue = 0;\n    holdings.forEach(holding => {\n      holdingsValue += parseFloat(holding.currentMarketValue);\n    });\n    \n    return (_capital + holdingsValue).toFixed(2);\n  }, [_capital, calculatePnL]);\n\n\n  // --- Context Value ---\n  // This object contains all the states and functions that components using the context can access\n  const value = {\n    trades,\n    setTrades, // Allow components to update trades if needed (though fetchTrades is preferred)\n    capital: _capital, // Expose capital as 'capital'\n    setCapital, // Expose capital setter for manual updates\n    livePrices,\n    setLivePrices, // Allow components to update live prices if needed\n    availableSymbols,\n    symbolError,\n    setSymbolError,\n    fetchTrades,\n    fetchAvailableSymbols,\n    fetchLivePrices,\n    calculatePnL, // Expose PnL calculation utility\n    isInvalidApiKey, // Expose API key validation\n    FINNHUB_API_KEY, // Expose API key (for debug/info, consider removing for production)\n    CURRENCY_SYMBOL, // Expose currency symbol\n    loadingData, // Expose data loading status\n    calculateTotalPortfolioValue, // Expose total portfolio value calculation\n    removeTrade, // --- NEW: Expose the removeTrade function ---\n  };\n\n  return (\n    <TradingContext.Provider value={value}>\n      {children}\n    </TradingContext.Provider>\n  );\n};\n\n// --- Custom Hook to easily consume the TradingContext ---\nexport const useTradingData = () => {\n  const context = useContext(TradingContext);\n  if (!context) {\n    throw new Error('useTradingData must be used within a TradingDataProvider');\n  }\n  return context;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}