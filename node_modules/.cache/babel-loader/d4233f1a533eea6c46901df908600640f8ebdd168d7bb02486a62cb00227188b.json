{"ast":null,"code":"var _jsxFileName = \"/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// src/TradingDataContext.js\nimport React, { createContext, useContext, useState, useEffect, useCallback, useMemo } from \"react\";\nimport { supabase } from \"./supabaseClient\";\nimport axios from \"axios\";\n\n// Constants for API Key and Currency Symbol\n// WARNING: Hardcoding API keys directly in source code is not recommended for security.\n// Consider using environment variables (.env file) for production deployment.\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const FINNHUB_API_KEY = \"d108911r01qhkqr8ggb0d108911r01qhkqr8ggbg\"; // YOUR FINNHUB API KEY\nexport const ALPHA_VANTAGE_API_KEY = \"DR0O9MY1P0QU6ZEL\"; // YOUR ALPHA VANTAGE API KEY HERE\nexport const CURRENCY_SYMBOL = process.env.REACT_APP_CURRENCY_SYMBOL || \"$\";\n\n// Helper to check if API key is valid (simple check)\nexport const isInvalidApiKey = key => {\n  const trimmedKey = key ? key.trim() : '';\n  // Check for empty string, Finnhub placeholder, or Alpha Vantage placeholder\n  return !trimmedKey || trimmedKey === \"YOUR_FINNHUB_API_KEY_HERE\" || trimmedKey === \"YOUR_ALPHA_VANTAGE_API_KEY\" || trimmedKey.length < 10;\n};\nconst TradingDataContext = /*#__PURE__*/createContext();\nexport const TradingDataProvider = ({\n  children\n}) => {\n  _s();\n  const [user, setUser] = useState(null);\n  const [trades, setTrades] = useState([]);\n  const [capital, setCapital] = useState(10000); // Initial capital\n  const [livePrices, setLivePrices] = useState({});\n  const [availableSymbols, setAvailableSymbols] = useState([]);\n  const [symbolError, setSymbolError] = useState(\"\");\n  const [loadingData, setLoadingData] = useState(true);\n  const [session, setSession] = useState(null); // Supabase session\n  const [watchListSymbols, setWatchListSymbols] = useState([]);\n  const [holdings, setHoldings] = useState({}); // New state for holdings\n\n  // --- Fetch live prices for a given list of symbols (uses Finnhub) ---\n  const fetchLivePrices = useCallback(async symbolsToFetch => {\n    const uniqueSymbols = [...new Set(symbolsToFetch)].filter(s => s && typeof s === 'string');\n    if (uniqueSymbols.length === 0 || isInvalidApiKey(FINNHUB_API_KEY)) {\n      setLivePrices(prev => {\n        const newPrices = {};\n        if (uniqueSymbols.length === 0) return prev;\n        uniqueSymbols.forEach(sym => {\n          if (prev[sym]) newPrices[sym] = prev[sym];\n        });\n        return newPrices;\n      });\n      return;\n    }\n    try {\n      const responses = await Promise.all(uniqueSymbols.map(symbol => axios.get(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`)));\n      const newPrices = {};\n      responses.forEach((res, index) => {\n        const symbol = uniqueSymbols[index];\n        if (res.data && res.data.c !== 0) {\n          newPrices[symbol] = res.data.c;\n        } else {\n          newPrices[symbol] = null; // Mark as unavailable\n        }\n      });\n      setLivePrices(prev => ({\n        ...prev,\n        ...newPrices\n      }));\n    } catch (error) {\n      console.error(\"Error fetching live prices:\", error);\n      const errorPrices = {};\n      uniqueSymbols.forEach(symbol => {\n        errorPrices[symbol] = null;\n      });\n      setLivePrices(prev => ({\n        ...prev,\n        ...errorPrices\n      }));\n    }\n  }, []);\n\n  // --- Helper to fetch user's capital from Supabase ---\n  const fetchCapital = useCallback(async userId => {\n    if (!userId) {\n      setCapital(10000);\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"user_profiles\").select(\"capital\").eq(\"user_id\", userId).single();\n      if (error && error.code !== 'PGRST116') {\n        // PGRST116 means \"no row found\"\n        throw error;\n      }\n      if (data) {\n        setCapital(data.capital);\n      } else {\n        // If no profile exists, create one with initial capital\n        const {\n          data: newProfile,\n          error: insertError\n        } = await supabase.from(\"user_profiles\").insert([{\n          user_id: userId,\n          capital: 10000\n        }]).select(\"capital\").single();\n        if (insertError) throw insertError;\n        setCapital(newProfile.capital);\n      }\n    } catch (error) {\n      console.error(\"Error fetching or setting capital:\", error.message);\n      setCapital(10000); // Default to initial capital on error\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Function to update capital in Supabase ---\n  const updateCapitalInDb = useCallback(async (newCapital, userId) => {\n    if (!userId) {\n      console.warn(\"updateCapitalInDb: No user ID, not updating DB.\");\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        error\n      } = await supabase.from(\"user_profiles\").update({\n        capital: newCapital\n      }).eq(\"user_id\", userId);\n      if (error) throw error;\n      setCapital(newCapital); // Update local state after successful DB update\n    } catch (error) {\n      console.error(\"Error updating capital in DB:\", error.message);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Wrapped setCapital to update DB as well ---\n  const handleSetCapital = useCallback(async newCapital => {\n    setCapital(newCapital); // Optimistically update local state\n    if (user !== null && user !== void 0 && user.id) {\n      await updateCapitalInDb(newCapital, user.id);\n    } else {\n      console.warn(\"No user ID available for DB capital update.\");\n    }\n  }, [user, updateCapitalInDb]);\n\n  // --- Fetch trades for the current user ---\n  const fetchTrades = useCallback(async userId => {\n    if (!userId) {\n      setTrades([]);\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"trades\").select(\"*\").eq(\"user_id\", userId).order(\"created_at\", {\n        ascending: false\n      });\n      if (error) throw error;\n      setTrades(data);\n    } catch (error) {\n      console.error(\"Error fetching trades:\", error.message);\n      setTrades([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Fetch holdings for the current user ---\n  const fetchHoldings = useCallback(async userId => {\n    if (!userId) {\n      setHoldings({});\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"holdings\").select(\"*\").eq(\"user_id\", userId);\n      if (error) throw error;\n      const newHoldings = {};\n      data.forEach(holding => {\n        newHoldings[holding.symbol] = {\n          symbol: holding.symbol,\n          netQty: holding.net_qty,\n          totalCost: holding.total_cost,\n          avgBuyPrice: holding.avg_buy_price\n        };\n      });\n      setHoldings(newHoldings);\n    } catch (error) {\n      console.error(\"Error fetching holdings:\", error.message);\n      setHoldings({});\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Update holdings in Supabase ---\n  const updateHoldingInDb = useCallback(async (userId, symbol, netQty, totalCost, avgBuyPrice) => {\n    if (!userId) {\n      console.warn(\"updateHoldingInDb: No user ID, not updating DB.\");\n      return;\n    }\n    try {\n      if (netQty === 0) {\n        // If netQty is 0, delete the holding\n        const {\n          error\n        } = await supabase.from(\"holdings\").delete().eq(\"user_id\", userId).eq(\"symbol\", symbol);\n        if (error) throw error;\n      } else {\n        // Upsert the holding\n        const {\n          error\n        } = await supabase.from(\"holdings\").upsert({\n          user_id: userId,\n          symbol,\n          net_qty: netQty,\n          total_cost: totalCost,\n          avg_buy_price: avgBuyPrice\n        }, {\n          onConflict: ['user_id', 'symbol']\n        });\n        if (error) throw error;\n      }\n      // Re-fetch holdings to ensure state is in sync\n      await fetchHoldings(userId);\n    } catch (error) {\n      console.error(\"Error updating holding in DB:\", error.message);\n      throw error;\n    }\n  }, [fetchHoldings]);\n\n  // --- Fetch watchlist symbols for the current user ---\n  const fetchWatchlist = useCallback(async userId => {\n    if (!userId) {\n      setWatchListSymbols([]);\n      return;\n    }\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"watchlists\").select(\"symbol\").eq(\"user_id\", userId).order(\"created_at\", {\n        ascending: true\n      });\n      if (error) throw error;\n      setWatchListSymbols(data.map(item => item.symbol));\n    } catch (error) {\n      console.error(\"Error fetching watchlist:\", error.message);\n      setWatchListSymbols([]);\n    }\n  }, []);\n\n  // --- Add symbol to watchlist ---\n  const addToWatchlist = useCallback(async symbol => {\n    if (!(user !== null && user !== void 0 && user.id)) {\n      throw new Error(\"User not authenticated.\");\n    }\n    const normalizedSymbol = symbol.toUpperCase();\n    if (watchListSymbols.includes(normalizedSymbol)) {\n      throw new Error(`'${normalizedSymbol}' is already in your watchlist.`);\n    }\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"watchlists\").insert([{\n        user_id: user.id,\n        symbol: normalizedSymbol\n      }]).select(\"symbol\").single();\n      if (error) throw error;\n      setWatchListSymbols(prev => [...prev, data.symbol]);\n      fetchLivePrices([normalizedSymbol]);\n    } catch (error) {\n      console.error(\"Error adding to watchlist:\", error.message);\n      throw error;\n    }\n  }, [user, watchListSymbols, fetchLivePrices]);\n\n  // --- Remove symbol from watchlist ---\n  const removeFromWatchlist = useCallback(async symbol => {\n    if (!(user !== null && user !== void 0 && user.id)) {\n      throw new Error(\"User not authenticated.\");\n    }\n    try {\n      const {\n        error\n      } = await supabase.from(\"watchlists\").delete().eq(\"user_id\", user.id).eq(\"symbol\", symbol.toUpperCase());\n      if (error) throw error;\n      setWatchListSymbols(prev => prev.filter(s => s !== symbol.toUpperCase()));\n      setLivePrices(prev => {\n        // Clear live price for removed symbol if not needed elsewhere\n        const newPrices = {\n          ...prev\n        };\n        delete newPrices[symbol.toUpperCase()];\n        return newPrices;\n      });\n    } catch (error) {\n      console.error(\"Error removing from watchlist:\", error.message);\n      throw error;\n    }\n  }, [user]);\n\n  // --- Fetch available US stock symbols from Finnhub (uses Finnhub) ---\n  const fetchAvailableSymbols = useCallback(async () => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      setSymbolError(\"Invalid Finnhub API Key. Cannot fetch US stock symbols.\");\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        data\n      } = await axios.get(`https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`);\n      const filteredSymbols = data.filter(s => s.type === \"Common Stock\" || s.type === \"ADR\" || s.type === \"REIT\" || s.type === \"ETP\" || s.type === \"ETF\").map(s => s.symbol).sort();\n      setAvailableSymbols(filteredSymbols);\n      setSymbolError(\"\");\n    } catch (error) {\n      console.error(\"Error fetching available symbols:\", error);\n      setSymbolError(\"Failed to fetch US stock symbols. This might be due to API rate limits or an invalid Finnhub API key (free tier keys have limited symbol access).\");\n      setAvailableSymbols([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Calculate PnL and Holdings (now uses `holdings` state directly) ---\n  const calculatePnL = useCallback(() => {\n    let totalRealizedPnl = 0; // This will still need to be calculated from trades\n    // For now, let's keep it simple and focus on unrealized PnL from the new holdings structure.\n    // Realized PnL will be derived from trade history, similar to before.\n\n    let currentHoldingsCalculated = {};\n    Object.values(holdings).forEach(holding => {\n      let unrealizedPnl = 0;\n      if (holding.netQty > 0 && livePrices[holding.symbol]) {\n        const livePrice = livePrices[holding.symbol];\n        unrealizedPnl = (livePrice - holding.avgBuyPrice) * holding.netQty;\n      }\n      currentHoldingsCalculated[holding.symbol] = {\n        ...holding,\n        unrealizedPnl: unrealizedPnl.toFixed(2)\n      };\n    });\n\n    // Calculate totalUnrealizedPnl from currentHoldingsCalculated\n    const totalUnrealizedPnl = Object.values(currentHoldingsCalculated).reduce((sum, holding) => {\n      return sum + parseFloat(holding.unrealizedPnl || 0);\n    }, 0);\n\n    // Re-calculating realized PnL from trades is still necessary if trades are deleted.\n    // However, if trades are only added/modified, and holdings are the source of truth for current positions,\n    // realized PnL needs a more robust calculation method.\n    // For simplicity for now, we'll keep the existing realized PnL calculation logic that iterates through trades.\n    let realizedPnlFromTrades = 0;\n    const tempHoldingsForRealizedPnl = {}; // Temporary holdings to calculate realized PnL from trades\n    trades.slice().reverse().forEach(trade => {\n      // Iterate from oldest to newest for correct PnL calculation\n      if (!tempHoldingsForRealizedPnl[trade.symbol]) {\n        tempHoldingsForRealizedPnl[trade.symbol] = {\n          netQty: 0,\n          totalCost: 0,\n          avgBuyPrice: 0\n        };\n      }\n      if (trade.type === \"buy\") {\n        tempHoldingsForRealizedPnl[trade.symbol].totalCost += trade.quantity * trade.price;\n        tempHoldingsForRealizedPyl[trade.symbol].netQty += trade.quantity;\n        tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice = tempHoldingsForRealizedPnl[trade.symbol].netQty > 0 ? tempHoldingsForRealizedPnl[trade.symbol].totalCost / tempHoldingsForRealizedPnl[trade.symbol].netQty : 0;\n      } else {\n        // sell\n        const qtySold = trade.quantity;\n        const currentNetQty = tempHoldingsForRealizedPnl[trade.symbol].netQty;\n        const currentAvgBuyPrice = tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice;\n        if (currentNetQty > 0) {\n          const sellCostBasis = currentAvgBuyPrice * Math.min(qtySold, currentNetQty);\n          const sellProceeds = trade.price * qtySold;\n          realizedPnlFromTrades += sellProceeds - sellCostBasis;\n        }\n        tempHoldingsForRealizedPnl[trade.symbol].netQty -= qtySold;\n        if (tempHoldingsForRealizedPnl[trade.symbol].netQty <= 0) {\n          tempHoldingsForRealizedPnl[trade.symbol].totalCost = 0;\n          tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice = 0;\n          tempHoldingsForRealizedPnl[trade.symbol].netQty = 0;\n        } else {\n          tempHoldingsForRealizedPnl[trade.symbol].totalCost = tempHoldingsForRealizedPnl[trade.symbol].netQty * tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice;\n        }\n      }\n    });\n    return {\n      holdings: Object.values(currentHoldingsCalculated),\n      totalRealizedPnl: realizedPnlFromTrades.toFixed(2),\n      totalUnrealizedPnl: totalUnrealizedPnl.toFixed(2)\n    };\n  }, [holdings, livePrices, trades]);\n\n  // --- Calculate total portfolio value ---\n  const calculateTotalPortfolioValue = useCallback(() => {\n    const {\n      holdings: calculatedHoldings\n    } = calculatePnL(); // Use the holdings from calculatePnL\n    let holdingsValue = 0;\n    Object.values(calculatedHoldings).forEach(holding => {\n      if (holding.netQty > 0 && livePrices[holding.symbol]) {\n        holdingsValue += holding.netQty * livePrices[holding.symbol];\n      }\n    });\n    return (capital + holdingsValue).toFixed(2);\n  }, [capital, calculatePnL, livePrices]);\n\n  // --- Add trade logic (modified to update holdings as well) ---\n  const addTrade = useCallback(async newTrade => {\n    if (!(user !== null && user !== void 0 && user.id)) throw new Error(\"User not authenticated.\");\n    const normalizedSymbol = newTrade.symbol.toUpperCase();\n    const tradeCost = newTrade.quantity * newTrade.price;\n    let newCapital = capital;\n    let currentHolding = holdings[normalizedSymbol] || {\n      netQty: 0,\n      totalCost: 0,\n      avgBuyPrice: 0\n    };\n    let newNetQty = currentHolding.netQty;\n    let newTotalCost = currentHolding.totalCost;\n    let newAvgBuyPrice = currentHolding.avgBuyPrice;\n    if (newTrade.type === \"buy\") {\n      newCapital -= tradeCost;\n      newNetQty += newTrade.quantity;\n      newTotalCost += tradeCost;\n      newAvgBuyPrice = newTotalCost / newNetQty;\n    } else {\n      // sell\n      newCapital += tradeCost;\n      const qtySold = newTrade.quantity;\n      if (currentHolding.netQty < qtySold) {\n        throw new Error(\"Insufficient shares to sell.\");\n      }\n\n      // Calculate realized PnL for this specific sale\n      const sellCostBasis = currentHolding.avgBuyPrice * qtySold;\n      const sellProceeds = newTrade.price * qtySold;\n      const realizedPnlForThisSale = sellProceeds - sellCostBasis;\n      // We will sum realized PnL later from all trades, no need to store here directly\n\n      newNetQty -= qtySold;\n      if (newNetQty <= 0) {\n        newTotalCost = 0;\n        newAvgBuyPrice = 0;\n        newNetQty = 0; // Ensure netQty doesn't go negative\n      } else {\n        // For partial sell, adjust totalCost for remaining shares\n        newTotalCost = newNetQty * currentHolding.avgBuyPrice; // The average buy price remains the same\n      }\n    }\n    try {\n      // 1. Insert the trade\n      const {\n        data: insertedTrade,\n        error: tradeError\n      } = await supabase.from(\"trades\").insert([{\n        user_id: user.id,\n        symbol: normalizedSymbol,\n        type: newTrade.type,\n        quantity: newTrade.quantity,\n        price: newTrade.price,\n        created_at: new Date().toISOString()\n      }]).select().single();\n      if (tradeError) throw tradeError;\n\n      // 2. Update capital\n      await handleSetCapital(newCapital);\n\n      // 3. Update holdings\n      await updateHoldingInDb(user.id, normalizedSymbol, newNetQty, newTotalCost, newAvgBuyPrice);\n\n      // Refresh trades and holdings from DB to ensure state is consistent\n      await fetchTrades(user.id);\n      await fetchHoldings(user.id);\n    } catch (error) {\n      console.error(\"Error adding trade:\", error.message);\n      throw error;\n    }\n  }, [user, capital, holdings, handleSetCapital, updateHoldingInDb, fetchTrades, fetchHoldings]);\n\n  // --- Remove trade logic (modified to correctly recalculate capital and holdings) ---\n  const removeTrade = useCallback(async tradeToRemove => {\n    if (!(user !== null && user !== void 0 && user.id)) throw new Error(\"User not authenticated.\");\n    try {\n      const {\n        error: deleteError\n      } = await supabase.from(\"trades\").delete().eq(\"id\", tradeToRemove.id).eq(\"user_id\", user.id);\n      if (deleteError) throw deleteError;\n\n      // After deleting a trade, we need to recalculate capital and holdings from scratch\n      // to ensure accuracy. This is a common pattern for financial transaction systems.\n\n      // 1. Fetch all remaining trades for the user\n      const {\n        data: remainingTrades,\n        error: fetchTradesError\n      } = await supabase.from(\"trades\").select(\"*\").eq(\"user_id\", user.id).order(\"created_at\", {\n        ascending: true\n      }); // Crucial: process in chronological order\n\n      if (fetchTradesError) throw fetchTradesError;\n\n      // 2. Recalculate capital and holdings\n      let recalculatedCapital = 10000; // Start with initial capital\n      let recalculatedHoldings = {};\n      remainingTrades.forEach(trade => {\n        const symbol = trade.symbol;\n        const quantity = trade.quantity;\n        const price = trade.price;\n        if (!recalculatedHoldings[symbol]) {\n          recalculatedHoldings[symbol] = {\n            netQty: 0,\n            totalCost: 0,\n            avgBuyPrice: 0\n          };\n        }\n        if (trade.type === 'buy') {\n          recalculatedCapital -= quantity * price;\n          recalculatedHoldings[symbol].totalCost += quantity * price;\n          recalculatedHoldings[symbol].netQty += quantity;\n          recalculatedHoldings[symbol].avgBuyPrice = recalculatedHoldings[symbol].netQty > 0 ? recalculatedHoldings[symbol].totalCost / recalculatedHoldings[symbol].netQty : 0;\n        } else {\n          // sell\n          recalculatedCapital += quantity * price;\n          const currentNetQty = recalculatedHoldings[symbol].netQty;\n          const currentAvgBuyPrice = recalculatedHoldings[symbol].avgBuyPrice;\n\n          // Only adjust holdings if selling existing shares\n          if (currentNetQty > 0) {\n            const qtyToSellFromHolding = Math.min(quantity, currentNetQty);\n            recalculatedHoldings[symbol].netQty -= qtyToSellFromHolding;\n            if (recalculatedHoldings[symbol].netQty <= 0) {\n              recalculatedHoldings[symbol].totalCost = 0;\n              recalculatedHoldings[symbol].avgBuyPrice = 0;\n              recalculatedHoldings[symbol].netQty = 0; // Ensure it's not negative\n            } else {\n              // If partial sell, totalCost adjusts proportionally\n              recalculatedHoldings[symbol].totalCost = recalculatedHoldings[symbol].netQty * currentAvgBuyPrice;\n            }\n          }\n        }\n      });\n\n      // 3. Update capital in DB and state\n      await handleSetCapital(recalculatedCapital);\n\n      // 4. Update all holdings in DB based on recalculation\n      // First, delete all existing holdings for the user\n      const {\n        error: deleteHoldingsError\n      } = await supabase.from(\"holdings\").delete().eq(\"user_id\", user.id);\n      if (deleteHoldingsError) throw deleteHoldingsError;\n\n      // Then, insert the recalculated holdings\n      const holdingsToInsert = Object.values(recalculatedHoldings).filter(h => h.netQty > 0) // Only insert holdings with positive quantity\n      .map(h => ({\n        user_id: user.id,\n        symbol: h.symbol,\n        net_qty: h.netQty,\n        total_cost: h.totalCost,\n        avg_buy_price: h.avgBuyPrice\n      }));\n      if (holdingsToInsert.length > 0) {\n        const {\n          error: insertHoldingsError\n        } = await supabase.from(\"holdings\").insert(holdingsToInsert);\n        if (insertHoldingsError) throw insertHoldingsError;\n      }\n\n      // Finally, re-fetch all state to ensure consistency\n      await fetchTrades(user.id);\n      await fetchHoldings(user.id);\n    } catch (error) {\n      console.error(\"Error removing trade:\", error.message);\n      throw error;\n    }\n  }, [user, handleSetCapital, fetchTrades, fetchHoldings]);\n\n  // --- Initial Data Load on Mount or User Change ---\n  useEffect(() => {\n    const {\n      data: authListener\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      setSession(session);\n      const currentUser = (session === null || session === void 0 ? void 0 : session.user) || null;\n      setUser(currentUser);\n      if (currentUser) {\n        setLoadingData(true);\n        await fetchCapital(currentUser.id);\n        await fetchTrades(currentUser.id);\n        await fetchHoldings(currentUser.id); // Fetch holdings on user change\n        await fetchWatchlist(currentUser.id);\n        setLoadingData(false);\n      } else {\n        setCapital(10000); // Reset to initial capital for logged-out state\n        setTrades([]);\n        setHoldings({}); // Clear holdings on logout\n        setWatchListSymbols([]);\n        setLivePrices({});\n        setUser(null);\n        setLoadingData(false);\n      }\n    });\n\n    // Initial check for session on component mount\n    const checkSession = async () => {\n      setLoadingData(true);\n      const {\n        data: {\n          session\n        }\n      } = await supabase.auth.getSession();\n      setSession(session);\n      const currentUser = (session === null || session === void 0 ? void 0 : session.user) || null;\n      setUser(currentUser);\n      if (currentUser) {\n        await fetchCapital(currentUser.id);\n        await fetchTrades(currentUser.id);\n        await fetchHoldings(currentUser.id); // Initial fetch of holdings\n        await fetchWatchlist(currentUser.id);\n      }\n      setLoadingData(false);\n    };\n    checkSession();\n    fetchAvailableSymbols(); // Fetch symbols once on load for everyone\n\n    return () => {\n      authListener.subscription.unsubscribe();\n    };\n  }, [fetchCapital, fetchTrades, fetchHoldings, fetchAvailableSymbols, fetchWatchlist]); // Dependencies for initial data load\n\n  // --- Effect to fetch live prices for all relevant symbols ---\n  useEffect(() => {\n    // Combine symbols from trades, watchlist, and holdings\n    const allSymbols = [...new Set([...trades.map(t => t.symbol), ...watchListSymbols, ...Object.keys(holdings) // Include symbols from holdings\n    ])].filter(Boolean); // Filter out any null/undefined/empty symbols\n\n    if (allSymbols.length > 0) {\n      // Fetch immediately\n      fetchLivePrices(allSymbols);\n\n      // Set up interval for periodic refresh\n      const interval = setInterval(() => {\n        fetchLivePrices(allSymbols);\n      }, 20000); // Every 20 seconds\n\n      return () => clearInterval(interval); // Cleanup on unmount or dependency change\n    }\n  }, [trades, watchListSymbols, holdings, fetchLivePrices]); // Re-run if trades, watchlist, or holdings change\n\n  // Memoize the context value to prevent unnecessary re-renders\n  const contextValue = useMemo(() => ({\n    user,\n    trades,\n    capital,\n    setCapital: handleSetCapital,\n    // Use the wrapped function\n    livePrices,\n    availableSymbols,\n    symbolError,\n    setSymbolError,\n    fetchTrades,\n    fetchLivePrices,\n    calculatePnL,\n    calculateTotalPortfolioValue,\n    loadingData,\n    removeTrade,\n    addTrade,\n    // Expose addTrade function\n    watchListSymbols,\n    addToWatchlist,\n    removeFromWatchlist,\n    holdings: Object.values(holdings) // Provide holdings as an array for easier consumption\n  }), [user, trades, capital, handleSetCapital, livePrices, availableSymbols, symbolError, setSymbolError, fetchTrades, fetchLivePrices, calculatePnL, calculateTotalPortfolioValue, loadingData, removeTrade, addTrade, addToWatchlist, removeFromWatchlist, watchListSymbols, holdings]);\n  return /*#__PURE__*/_jsxDEV(TradingDataContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 738,\n    columnNumber: 5\n  }, this);\n};\n_s(TradingDataProvider, \"fEk52PnGiUHmejVSmISMjPb05Rs=\");\n_c = TradingDataProvider;\nexport const useTradingData = () => {\n  _s2();\n  const context = useContext(TradingDataContext);\n  if (context === undefined) {\n    throw new Error(\"useTradingData must be used within a TradingDataProvider\");\n  }\n  return context;\n};\n_s2(useTradingData, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"TradingDataProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useCallback","useMemo","supabase","axios","jsxDEV","_jsxDEV","FINNHUB_API_KEY","ALPHA_VANTAGE_API_KEY","CURRENCY_SYMBOL","process","env","REACT_APP_CURRENCY_SYMBOL","isInvalidApiKey","key","trimmedKey","trim","length","TradingDataContext","TradingDataProvider","children","_s","user","setUser","trades","setTrades","capital","setCapital","livePrices","setLivePrices","availableSymbols","setAvailableSymbols","symbolError","setSymbolError","loadingData","setLoadingData","session","setSession","watchListSymbols","setWatchListSymbols","holdings","setHoldings","fetchLivePrices","symbolsToFetch","uniqueSymbols","Set","filter","s","prev","newPrices","forEach","sym","responses","Promise","all","map","symbol","get","res","index","data","c","error","console","errorPrices","fetchCapital","userId","from","select","eq","single","code","newProfile","insertError","insert","user_id","message","updateCapitalInDb","newCapital","warn","update","handleSetCapital","id","fetchTrades","order","ascending","fetchHoldings","newHoldings","holding","netQty","net_qty","totalCost","total_cost","avgBuyPrice","avg_buy_price","updateHoldingInDb","delete","upsert","onConflict","fetchWatchlist","item","addToWatchlist","Error","normalizedSymbol","toUpperCase","includes","removeFromWatchlist","fetchAvailableSymbols","filteredSymbols","type","sort","calculatePnL","totalRealizedPnl","currentHoldingsCalculated","Object","values","unrealizedPnl","livePrice","toFixed","totalUnrealizedPnl","reduce","sum","parseFloat","realizedPnlFromTrades","tempHoldingsForRealizedPnl","slice","reverse","trade","quantity","price","tempHoldingsForRealizedPyl","qtySold","currentNetQty","currentAvgBuyPrice","sellCostBasis","Math","min","sellProceeds","calculateTotalPortfolioValue","calculatedHoldings","holdingsValue","addTrade","newTrade","tradeCost","currentHolding","newNetQty","newTotalCost","newAvgBuyPrice","realizedPnlForThisSale","insertedTrade","tradeError","created_at","Date","toISOString","removeTrade","tradeToRemove","deleteError","remainingTrades","fetchTradesError","recalculatedCapital","recalculatedHoldings","qtyToSellFromHolding","deleteHoldingsError","holdingsToInsert","h","insertHoldingsError","authListener","auth","onAuthStateChange","event","currentUser","checkSession","getSession","subscription","unsubscribe","allSymbols","t","keys","Boolean","interval","setInterval","clearInterval","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useTradingData","_s2","context","undefined","$RefreshReg$"],"sources":["/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js"],"sourcesContent":["// src/TradingDataContext.js\nimport React, { createContext, useContext, useState, useEffect, useCallback, useMemo } from \"react\";\nimport { supabase } from \"./supabaseClient\";\nimport axios from \"axios\";\n\n// Constants for API Key and Currency Symbol\n// WARNING: Hardcoding API keys directly in source code is not recommended for security.\n// Consider using environment variables (.env file) for production deployment.\n\nexport const FINNHUB_API_KEY = \"d108911r01qhkqr8ggb0d108911r01qhkqr8ggbg\"; // YOUR FINNHUB API KEY\nexport const ALPHA_VANTAGE_API_KEY = \"DR0O9MY1P0QU6ZEL\"; // YOUR ALPHA VANTAGE API KEY HERE\nexport const CURRENCY_SYMBOL = process.env.REACT_APP_CURRENCY_SYMBOL || \"$\";\n\n// Helper to check if API key is valid (simple check)\nexport const isInvalidApiKey = (key) => {\n  const trimmedKey = key ? key.trim() : '';\n  // Check for empty string, Finnhub placeholder, or Alpha Vantage placeholder\n  return !trimmedKey || trimmedKey === \"YOUR_FINNHUB_API_KEY_HERE\" || trimmedKey === \"YOUR_ALPHA_VANTAGE_API_KEY\" || trimmedKey.length < 10;\n};\n\nconst TradingDataContext = createContext();\n\nexport const TradingDataProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [trades, setTrades] = useState([]);\n  const [capital, setCapital] = useState(10000); // Initial capital\n  const [livePrices, setLivePrices] = useState({});\n  const [availableSymbols, setAvailableSymbols] = useState([]);\n  const [symbolError, setSymbolError] = useState(\"\");\n  const [loadingData, setLoadingData] = useState(true);\n  const [session, setSession] = useState(null); // Supabase session\n  const [watchListSymbols, setWatchListSymbols] = useState([]);\n  const [holdings, setHoldings] = useState({}); // New state for holdings\n\n  // --- Fetch live prices for a given list of symbols (uses Finnhub) ---\n  const fetchLivePrices = useCallback(async (symbolsToFetch) => {\n    const uniqueSymbols = [...new Set(symbolsToFetch)].filter(s => s && typeof s === 'string');\n\n    if (uniqueSymbols.length === 0 || isInvalidApiKey(FINNHUB_API_KEY)) {\n      setLivePrices((prev) => {\n        const newPrices = {};\n        if (uniqueSymbols.length === 0) return prev;\n\n        uniqueSymbols.forEach(sym => {\n            if (prev[sym]) newPrices[sym] = prev[sym];\n        });\n        return newPrices;\n      });\n      return;\n    }\n\n    try {\n      const responses = await Promise.all(\n        uniqueSymbols.map((symbol) =>\n          axios.get(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`)\n        )\n      );\n\n      const newPrices = {};\n      responses.forEach((res, index) => {\n        const symbol = uniqueSymbols[index];\n        if (res.data && res.data.c !== 0) {\n          newPrices[symbol] = res.data.c;\n        } else {\n          newPrices[symbol] = null; // Mark as unavailable\n        }\n      });\n\n      setLivePrices((prev) => ({ ...prev, ...newPrices }));\n    } catch (error) {\n      console.error(\"Error fetching live prices:\", error);\n      const errorPrices = {};\n      uniqueSymbols.forEach(symbol => { errorPrices[symbol] = null; });\n      setLivePrices((prev) => ({ ...prev, ...errorPrices }));\n    }\n  }, []);\n\n  // --- Helper to fetch user's capital from Supabase ---\n  const fetchCapital = useCallback(async (userId) => {\n    if (!userId) {\n      setCapital(10000);\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { data, error } = await supabase\n        .from(\"user_profiles\")\n        .select(\"capital\")\n        .eq(\"user_id\", userId)\n        .single();\n\n      if (error && error.code !== 'PGRST116') { // PGRST116 means \"no row found\"\n        throw error;\n      }\n\n      if (data) {\n        setCapital(data.capital);\n      } else {\n        // If no profile exists, create one with initial capital\n        const { data: newProfile, error: insertError } = await supabase\n          .from(\"user_profiles\")\n          .insert([{ user_id: userId, capital: 10000 }])\n          .select(\"capital\")\n          .single();\n\n        if (insertError) throw insertError;\n        setCapital(newProfile.capital);\n      }\n    } catch (error) {\n      console.error(\"Error fetching or setting capital:\", error.message);\n      setCapital(10000); // Default to initial capital on error\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Function to update capital in Supabase ---\n  const updateCapitalInDb = useCallback(async (newCapital, userId) => {\n    if (!userId) {\n      console.warn(\"updateCapitalInDb: No user ID, not updating DB.\");\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { error } = await supabase\n        .from(\"user_profiles\")\n        .update({ capital: newCapital })\n        .eq(\"user_id\", userId);\n\n      if (error) throw error;\n      setCapital(newCapital); // Update local state after successful DB update\n    } catch (error) {\n      console.error(\"Error updating capital in DB:\", error.message);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Wrapped setCapital to update DB as well ---\n  const handleSetCapital = useCallback(async (newCapital) => {\n    setCapital(newCapital); // Optimistically update local state\n    if (user?.id) {\n      await updateCapitalInDb(newCapital, user.id);\n    } else {\n      console.warn(\"No user ID available for DB capital update.\");\n    }\n  }, [user, updateCapitalInDb]);\n\n  // --- Fetch trades for the current user ---\n  const fetchTrades = useCallback(async (userId) => {\n    if (!userId) {\n      setTrades([]);\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { data, error } = await supabase\n        .from(\"trades\")\n        .select(\"*\")\n        .eq(\"user_id\", userId)\n        .order(\"created_at\", { ascending: false });\n\n      if (error) throw error;\n      setTrades(data);\n    } catch (error) {\n      console.error(\"Error fetching trades:\", error.message);\n      setTrades([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Fetch holdings for the current user ---\n  const fetchHoldings = useCallback(async (userId) => {\n    if (!userId) {\n      setHoldings({});\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { data, error } = await supabase\n        .from(\"holdings\")\n        .select(\"*\")\n        .eq(\"user_id\", userId);\n\n      if (error) throw error;\n\n      const newHoldings = {};\n      data.forEach(holding => {\n        newHoldings[holding.symbol] = {\n          symbol: holding.symbol,\n          netQty: holding.net_qty,\n          totalCost: holding.total_cost,\n          avgBuyPrice: holding.avg_buy_price,\n        };\n      });\n      setHoldings(newHoldings);\n    } catch (error) {\n      console.error(\"Error fetching holdings:\", error.message);\n      setHoldings({});\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Update holdings in Supabase ---\n  const updateHoldingInDb = useCallback(async (userId, symbol, netQty, totalCost, avgBuyPrice) => {\n    if (!userId) {\n      console.warn(\"updateHoldingInDb: No user ID, not updating DB.\");\n      return;\n    }\n\n    try {\n      if (netQty === 0) {\n        // If netQty is 0, delete the holding\n        const { error } = await supabase\n          .from(\"holdings\")\n          .delete()\n          .eq(\"user_id\", userId)\n          .eq(\"symbol\", symbol);\n        if (error) throw error;\n      } else {\n        // Upsert the holding\n        const { error } = await supabase\n          .from(\"holdings\")\n          .upsert(\n            { user_id: userId, symbol, net_qty: netQty, total_cost: totalCost, avg_buy_price: avgBuyPrice },\n            { onConflict: ['user_id', 'symbol'] }\n          );\n        if (error) throw error;\n      }\n      // Re-fetch holdings to ensure state is in sync\n      await fetchHoldings(userId);\n    } catch (error) {\n      console.error(\"Error updating holding in DB:\", error.message);\n      throw error;\n    }\n  }, [fetchHoldings]);\n\n  // --- Fetch watchlist symbols for the current user ---\n  const fetchWatchlist = useCallback(async (userId) => {\n    if (!userId) {\n      setWatchListSymbols([]);\n      return;\n    }\n    try {\n      const { data, error } = await supabase\n        .from(\"watchlists\")\n        .select(\"symbol\")\n        .eq(\"user_id\", userId)\n        .order(\"created_at\", { ascending: true });\n\n      if (error) throw error;\n      setWatchListSymbols(data.map(item => item.symbol));\n    } catch (error) {\n      console.error(\"Error fetching watchlist:\", error.message);\n      setWatchListSymbols([]);\n    }\n  }, []);\n\n  // --- Add symbol to watchlist ---\n  const addToWatchlist = useCallback(async (symbol) => {\n    if (!user?.id) {\n      throw new Error(\"User not authenticated.\");\n    }\n    const normalizedSymbol = symbol.toUpperCase();\n    if (watchListSymbols.includes(normalizedSymbol)) {\n      throw new Error(`'${normalizedSymbol}' is already in your watchlist.`);\n    }\n\n    try {\n      const { data, error } = await supabase\n        .from(\"watchlists\")\n        .insert([{ user_id: user.id, symbol: normalizedSymbol }])\n        .select(\"symbol\")\n        .single();\n\n      if (error) throw error;\n      setWatchListSymbols((prev) => [...prev, data.symbol]);\n      fetchLivePrices([normalizedSymbol]);\n    } catch (error) {\n      console.error(\"Error adding to watchlist:\", error.message);\n      throw error;\n    }\n  }, [user, watchListSymbols, fetchLivePrices]);\n\n  // --- Remove symbol from watchlist ---\n  const removeFromWatchlist = useCallback(async (symbol) => {\n    if (!user?.id) {\n      throw new Error(\"User not authenticated.\");\n    }\n    try {\n      const { error } = await supabase\n        .from(\"watchlists\")\n        .delete()\n        .eq(\"user_id\", user.id)\n        .eq(\"symbol\", symbol.toUpperCase());\n\n      if (error) throw error;\n      setWatchListSymbols((prev) => prev.filter((s) => s !== symbol.toUpperCase()));\n      setLivePrices((prev) => { // Clear live price for removed symbol if not needed elsewhere\n        const newPrices = { ...prev };\n        delete newPrices[symbol.toUpperCase()];\n        return newPrices;\n      });\n    } catch (error) {\n      console.error(\"Error removing from watchlist:\", error.message);\n      throw error;\n    }\n  }, [user]);\n\n  // --- Fetch available US stock symbols from Finnhub (uses Finnhub) ---\n  const fetchAvailableSymbols = useCallback(async () => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      setSymbolError(\"Invalid Finnhub API Key. Cannot fetch US stock symbols.\");\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { data } = await axios.get(\n        `https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`\n      );\n      const filteredSymbols = data\n        .filter(\n          (s) =>\n            s.type === \"Common Stock\" ||\n            s.type === \"ADR\" ||\n            s.type === \"REIT\" ||\n            s.type === \"ETP\" ||\n            s.type === \"ETF\"\n        )\n        .map((s) => s.symbol)\n        .sort();\n\n      setAvailableSymbols(filteredSymbols);\n      setSymbolError(\"\");\n    } catch (error) {\n      console.error(\"Error fetching available symbols:\", error);\n      setSymbolError(\n        \"Failed to fetch US stock symbols. This might be due to API rate limits or an invalid Finnhub API key (free tier keys have limited symbol access).\"\n      );\n      setAvailableSymbols([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Calculate PnL and Holdings (now uses `holdings` state directly) ---\n  const calculatePnL = useCallback(() => {\n    let totalRealizedPnl = 0; // This will still need to be calculated from trades\n    // For now, let's keep it simple and focus on unrealized PnL from the new holdings structure.\n    // Realized PnL will be derived from trade history, similar to before.\n\n    let currentHoldingsCalculated = {};\n    Object.values(holdings).forEach((holding) => {\n        let unrealizedPnl = 0;\n        if (holding.netQty > 0 && livePrices[holding.symbol]) {\n            const livePrice = livePrices[holding.symbol];\n            unrealizedPnl = (livePrice - holding.avgBuyPrice) * holding.netQty;\n        }\n        currentHoldingsCalculated[holding.symbol] = {\n            ...holding,\n            unrealizedPnl: unrealizedPnl.toFixed(2),\n        };\n    });\n\n    // Calculate totalUnrealizedPnl from currentHoldingsCalculated\n    const totalUnrealizedPnl = Object.values(currentHoldingsCalculated).reduce((sum, holding) => {\n        return sum + parseFloat(holding.unrealizedPnl || 0);\n    }, 0);\n\n    // Re-calculating realized PnL from trades is still necessary if trades are deleted.\n    // However, if trades are only added/modified, and holdings are the source of truth for current positions,\n    // realized PnL needs a more robust calculation method.\n    // For simplicity for now, we'll keep the existing realized PnL calculation logic that iterates through trades.\n    let realizedPnlFromTrades = 0;\n    const tempHoldingsForRealizedPnl = {}; // Temporary holdings to calculate realized PnL from trades\n    trades.slice().reverse().forEach((trade) => { // Iterate from oldest to newest for correct PnL calculation\n        if (!tempHoldingsForRealizedPnl[trade.symbol]) {\n            tempHoldingsForRealizedPnl[trade.symbol] = { netQty: 0, totalCost: 0, avgBuyPrice: 0 };\n        }\n\n        if (trade.type === \"buy\") {\n            tempHoldingsForRealizedPnl[trade.symbol].totalCost += trade.quantity * trade.price;\n            tempHoldingsForRealizedPyl[trade.symbol].netQty += trade.quantity;\n            tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice =\n                tempHoldingsForRealizedPnl[trade.symbol].netQty > 0\n                    ? tempHoldingsForRealizedPnl[trade.symbol].totalCost / tempHoldingsForRealizedPnl[trade.symbol].netQty\n                    : 0;\n        } else { // sell\n            const qtySold = trade.quantity;\n            const currentNetQty = tempHoldingsForRealizedPnl[trade.symbol].netQty;\n            const currentAvgBuyPrice = tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice;\n\n            if (currentNetQty > 0) {\n                const sellCostBasis = (currentAvgBuyPrice * Math.min(qtySold, currentNetQty));\n                const sellProceeds = trade.price * qtySold;\n                realizedPnlFromTrades += (sellProceeds - sellCostBasis);\n            }\n\n            tempHoldingsForRealizedPnl[trade.symbol].netQty -= qtySold;\n            if (tempHoldingsForRealizedPnl[trade.symbol].netQty <= 0) {\n                tempHoldingsForRealizedPnl[trade.symbol].totalCost = 0;\n                tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice = 0;\n                tempHoldingsForRealizedPnl[trade.symbol].netQty = 0;\n            } else {\n                tempHoldingsForRealizedPnl[trade.symbol].totalCost = tempHoldingsForRealizedPnl[trade.symbol].netQty * tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice;\n            }\n        }\n    });\n\n\n    return {\n      holdings: Object.values(currentHoldingsCalculated),\n      totalRealizedPnl: realizedPnlFromTrades.toFixed(2),\n      totalUnrealizedPnl: totalUnrealizedPnl.toFixed(2),\n    };\n  }, [holdings, livePrices, trades]);\n\n  // --- Calculate total portfolio value ---\n  const calculateTotalPortfolioValue = useCallback(() => {\n    const { holdings: calculatedHoldings } = calculatePnL(); // Use the holdings from calculatePnL\n    let holdingsValue = 0;\n    Object.values(calculatedHoldings).forEach(holding => {\n      if (holding.netQty > 0 && livePrices[holding.symbol]) {\n        holdingsValue += holding.netQty * livePrices[holding.symbol];\n      }\n    });\n    return (capital + holdingsValue).toFixed(2);\n  }, [capital, calculatePnL, livePrices]);\n\n  // --- Add trade logic (modified to update holdings as well) ---\n  const addTrade = useCallback(async (newTrade) => {\n    if (!user?.id) throw new Error(\"User not authenticated.\");\n\n    const normalizedSymbol = newTrade.symbol.toUpperCase();\n    const tradeCost = newTrade.quantity * newTrade.price;\n    let newCapital = capital;\n    let currentHolding = holdings[normalizedSymbol] || { netQty: 0, totalCost: 0, avgBuyPrice: 0 };\n    let newNetQty = currentHolding.netQty;\n    let newTotalCost = currentHolding.totalCost;\n    let newAvgBuyPrice = currentHolding.avgBuyPrice;\n\n    if (newTrade.type === \"buy\") {\n      newCapital -= tradeCost;\n      newNetQty += newTrade.quantity;\n      newTotalCost += tradeCost;\n      newAvgBuyPrice = newTotalCost / newNetQty;\n    } else { // sell\n      newCapital += tradeCost;\n      const qtySold = newTrade.quantity;\n\n      if (currentHolding.netQty < qtySold) {\n          throw new Error(\"Insufficient shares to sell.\");\n      }\n\n      // Calculate realized PnL for this specific sale\n      const sellCostBasis = (currentHolding.avgBuyPrice * qtySold);\n      const sellProceeds = newTrade.price * qtySold;\n      const realizedPnlForThisSale = (sellProceeds - sellCostBasis);\n      // We will sum realized PnL later from all trades, no need to store here directly\n\n      newNetQty -= qtySold;\n      if (newNetQty <= 0) {\n        newTotalCost = 0;\n        newAvgBuyPrice = 0;\n        newNetQty = 0; // Ensure netQty doesn't go negative\n      } else {\n        // For partial sell, adjust totalCost for remaining shares\n        newTotalCost = newNetQty * currentHolding.avgBuyPrice; // The average buy price remains the same\n      }\n    }\n\n    try {\n      // 1. Insert the trade\n      const { data: insertedTrade, error: tradeError } = await supabase\n        .from(\"trades\")\n        .insert([{\n          user_id: user.id,\n          symbol: normalizedSymbol,\n          type: newTrade.type,\n          quantity: newTrade.quantity,\n          price: newTrade.price,\n          created_at: new Date().toISOString(),\n        }])\n        .select()\n        .single();\n\n      if (tradeError) throw tradeError;\n\n      // 2. Update capital\n      await handleSetCapital(newCapital);\n\n      // 3. Update holdings\n      await updateHoldingInDb(user.id, normalizedSymbol, newNetQty, newTotalCost, newAvgBuyPrice);\n\n      // Refresh trades and holdings from DB to ensure state is consistent\n      await fetchTrades(user.id);\n      await fetchHoldings(user.id);\n\n    } catch (error) {\n      console.error(\"Error adding trade:\", error.message);\n      throw error;\n    }\n  }, [user, capital, holdings, handleSetCapital, updateHoldingInDb, fetchTrades, fetchHoldings]);\n\n  // --- Remove trade logic (modified to correctly recalculate capital and holdings) ---\n  const removeTrade = useCallback(async (tradeToRemove) => {\n    if (!user?.id) throw new Error(\"User not authenticated.\");\n\n    try {\n      const { error: deleteError } = await supabase\n        .from(\"trades\")\n        .delete()\n        .eq(\"id\", tradeToRemove.id)\n        .eq(\"user_id\", user.id);\n\n      if (deleteError) throw deleteError;\n\n      // After deleting a trade, we need to recalculate capital and holdings from scratch\n      // to ensure accuracy. This is a common pattern for financial transaction systems.\n\n      // 1. Fetch all remaining trades for the user\n      const { data: remainingTrades, error: fetchTradesError } = await supabase\n        .from(\"trades\")\n        .select(\"*\")\n        .eq(\"user_id\", user.id)\n        .order(\"created_at\", { ascending: true }); // Crucial: process in chronological order\n\n      if (fetchTradesError) throw fetchTradesError;\n\n      // 2. Recalculate capital and holdings\n      let recalculatedCapital = 10000; // Start with initial capital\n      let recalculatedHoldings = {};\n\n      remainingTrades.forEach(trade => {\n        const symbol = trade.symbol;\n        const quantity = trade.quantity;\n        const price = trade.price;\n\n        if (!recalculatedHoldings[symbol]) {\n          recalculatedHoldings[symbol] = { netQty: 0, totalCost: 0, avgBuyPrice: 0 };\n        }\n\n        if (trade.type === 'buy') {\n          recalculatedCapital -= (quantity * price);\n          recalculatedHoldings[symbol].totalCost += (quantity * price);\n          recalculatedHoldings[symbol].netQty += quantity;\n          recalculatedHoldings[symbol].avgBuyPrice = recalculatedHoldings[symbol].netQty > 0\n            ? recalculatedHoldings[symbol].totalCost / recalculatedHoldings[symbol].netQty\n            : 0;\n        } else { // sell\n          recalculatedCapital += (quantity * price);\n          \n          const currentNetQty = recalculatedHoldings[symbol].netQty;\n          const currentAvgBuyPrice = recalculatedHoldings[symbol].avgBuyPrice;\n\n          // Only adjust holdings if selling existing shares\n          if (currentNetQty > 0) {\n              const qtyToSellFromHolding = Math.min(quantity, currentNetQty);\n              recalculatedHoldings[symbol].netQty -= qtyToSellFromHolding;\n              \n              if (recalculatedHoldings[symbol].netQty <= 0) {\n                  recalculatedHoldings[symbol].totalCost = 0;\n                  recalculatedHoldings[symbol].avgBuyPrice = 0;\n                  recalculatedHoldings[symbol].netQty = 0; // Ensure it's not negative\n              } else {\n                  // If partial sell, totalCost adjusts proportionally\n                  recalculatedHoldings[symbol].totalCost = recalculatedHoldings[symbol].netQty * currentAvgBuyPrice;\n              }\n          }\n        }\n      });\n\n      // 3. Update capital in DB and state\n      await handleSetCapital(recalculatedCapital);\n\n      // 4. Update all holdings in DB based on recalculation\n      // First, delete all existing holdings for the user\n      const { error: deleteHoldingsError } = await supabase\n        .from(\"holdings\")\n        .delete()\n        .eq(\"user_id\", user.id);\n      if (deleteHoldingsError) throw deleteHoldingsError;\n\n      // Then, insert the recalculated holdings\n      const holdingsToInsert = Object.values(recalculatedHoldings)\n        .filter(h => h.netQty > 0) // Only insert holdings with positive quantity\n        .map(h => ({\n          user_id: user.id,\n          symbol: h.symbol,\n          net_qty: h.netQty,\n          total_cost: h.totalCost,\n          avg_buy_price: h.avgBuyPrice,\n        }));\n\n      if (holdingsToInsert.length > 0) {\n        const { error: insertHoldingsError } = await supabase\n          .from(\"holdings\")\n          .insert(holdingsToInsert);\n        if (insertHoldingsError) throw insertHoldingsError;\n      }\n      \n      // Finally, re-fetch all state to ensure consistency\n      await fetchTrades(user.id);\n      await fetchHoldings(user.id);\n\n    } catch (error) {\n      console.error(\"Error removing trade:\", error.message);\n      throw error;\n    }\n  }, [user, handleSetCapital, fetchTrades, fetchHoldings]);\n\n\n  // --- Initial Data Load on Mount or User Change ---\n  useEffect(() => {\n    const { data: authListener } = supabase.auth.onAuthStateChange(\n      async (event, session) => {\n        setSession(session);\n        const currentUser = session?.user || null;\n        setUser(currentUser);\n\n        if (currentUser) {\n          setLoadingData(true);\n          await fetchCapital(currentUser.id);\n          await fetchTrades(currentUser.id);\n          await fetchHoldings(currentUser.id); // Fetch holdings on user change\n          await fetchWatchlist(currentUser.id);\n          setLoadingData(false);\n        } else {\n          setCapital(10000); // Reset to initial capital for logged-out state\n          setTrades([]);\n          setHoldings({}); // Clear holdings on logout\n          setWatchListSymbols([]);\n          setLivePrices({});\n          setUser(null);\n          setLoadingData(false);\n        }\n      }\n    );\n\n    // Initial check for session on component mount\n    const checkSession = async () => {\n      setLoadingData(true);\n      const { data: { session } } = await supabase.auth.getSession();\n      setSession(session);\n      const currentUser = session?.user || null;\n      setUser(currentUser);\n\n      if (currentUser) {\n        await fetchCapital(currentUser.id);\n        await fetchTrades(currentUser.id);\n        await fetchHoldings(currentUser.id); // Initial fetch of holdings\n        await fetchWatchlist(currentUser.id);\n      }\n      setLoadingData(false);\n    };\n\n    checkSession();\n    fetchAvailableSymbols(); // Fetch symbols once on load for everyone\n\n    return () => {\n      authListener.subscription.unsubscribe();\n    };\n  }, [fetchCapital, fetchTrades, fetchHoldings, fetchAvailableSymbols, fetchWatchlist]); // Dependencies for initial data load\n\n  // --- Effect to fetch live prices for all relevant symbols ---\n  useEffect(() => {\n    // Combine symbols from trades, watchlist, and holdings\n    const allSymbols = [\n      ...new Set([\n        ...trades.map((t) => t.symbol),\n        ...watchListSymbols,\n        ...Object.keys(holdings), // Include symbols from holdings\n      ])\n    ].filter(Boolean); // Filter out any null/undefined/empty symbols\n\n    if (allSymbols.length > 0) {\n      // Fetch immediately\n      fetchLivePrices(allSymbols);\n\n      // Set up interval for periodic refresh\n      const interval = setInterval(() => {\n        fetchLivePrices(allSymbols);\n      }, 20000); // Every 20 seconds\n\n      return () => clearInterval(interval); // Cleanup on unmount or dependency change\n    }\n  }, [trades, watchListSymbols, holdings, fetchLivePrices]); // Re-run if trades, watchlist, or holdings change\n\n  // Memoize the context value to prevent unnecessary re-renders\n  const contextValue = useMemo(\n    () => ({\n      user,\n      trades,\n      capital,\n      setCapital: handleSetCapital, // Use the wrapped function\n      livePrices,\n      availableSymbols,\n      symbolError,\n      setSymbolError,\n      fetchTrades,\n      fetchLivePrices,\n      calculatePnL,\n      calculateTotalPortfolioValue,\n      loadingData,\n      removeTrade,\n      addTrade, // Expose addTrade function\n      watchListSymbols,\n      addToWatchlist,\n      removeFromWatchlist,\n      holdings: Object.values(holdings), // Provide holdings as an array for easier consumption\n    }),\n    [\n      user,\n      trades,\n      capital,\n      handleSetCapital,\n      livePrices,\n      availableSymbols,\n      symbolError,\n      setSymbolError,\n      fetchTrades,\n      fetchLivePrices,\n      calculatePnL,\n      calculateTotalPortfolioValue,\n      loadingData,\n      removeTrade,\n      addTrade,\n      addToWatchlist,\n      removeFromWatchlist,\n      watchListSymbols,\n      holdings,\n    ]\n  );\n\n  return (\n    <TradingDataContext.Provider value={contextValue}>\n      {children}\n    </TradingDataContext.Provider>\n  );\n};\n\nexport const useTradingData = () => {\n  const context = useContext(TradingDataContext);\n  if (context === undefined) {\n    throw new Error(\"useTradingData must be used within a TradingDataProvider\");\n  }\n  return context;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}