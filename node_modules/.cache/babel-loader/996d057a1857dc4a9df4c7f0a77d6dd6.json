{"ast":null,"code":"var _jsxFileName = \"/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js\";\n// src/TradingDataContext.js\nimport React, { createContext, useContext, useState, useEffect, useCallback, useMemo } from \"react\";\nimport { supabase } from \"./supabaseClient\";\nimport axios from \"axios\";\nconst TradingDataContext = createContext();\n\n// Constants for API Key and Currency Symbol - Replace with your actual values\nconst FINNHUB_API_KEY = process.env.REACT_APP_FINNHUB_API_KEY || \"YOUR_FINNHUB_API_KEY\"; // Get from .env or replace\nconst CURRENCY_SYMBOL = process.env.REACT_APP_CURRENCY_SYMBOL || \"$\"; // Get from .env or replace\n\n// Helper to check if API key is valid (simple check)\nconst isInvalidApiKey = key => {\n  return !key || key === \"YOUR_FINNHUB_API_KEY\" || key.length < 10; // Basic check\n};\nexport const TradingDataProvider = ({\n  children\n}) => {\n  const [user, setUser] = useState(null);\n  const [trades, setTrades] = useState([]);\n  const [capital, setCapital] = useState(10000); // Initial capital\n  const [livePrices, setLivePrices] = useState({});\n  const [availableSymbols, setAvailableSymbols] = useState([]);\n  const [symbolError, setSymbolError] = useState(\"\");\n  const [loadingData, setLoadingData] = useState(true);\n  const [session, setSession] = useState(null); // Supabase session\n  const [watchListSymbols, setWatchListSymbols] = useState([]); // NEW STATE for watchlist symbols\n\n  // --- Fetch live prices for a given list of symbols (MOVED UP) ---\n  const fetchLivePrices = useCallback(async symbolsToFetch => {\n    // Filter out invalid symbols or duplicates\n    const uniqueSymbols = [...new Set(symbolsToFetch)].filter(s => s && typeof s === 'string');\n    if (uniqueSymbols.length === 0 || isInvalidApiKey(FINNHUB_API_KEY)) {\n      setLivePrices(prev => {\n        // Clear prices for symbols not being fetched\n        const newPrices = {};\n        // Keep existing prices if they're for symbols currently being watched/held\n        // This logic needs to be careful not to remove valid prices if the input is empty\n        // For simplicity, if uniqueSymbols is empty, we don't update prices here.\n        if (uniqueSymbols.length === 0) return prev;\n\n        // If specific symbols are requested, only keep those\n        uniqueSymbols.forEach(sym => {\n          if (prev[sym]) newPrices[sym] = prev[sym];\n        });\n        return newPrices;\n      });\n      return;\n    }\n    try {\n      const responses = await Promise.all(uniqueSymbols.map(symbol => axios.get(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`)));\n      const newPrices = {};\n      responses.forEach((res, index) => {\n        const symbol = uniqueSymbols[index];\n        if (res.data && res.data.c !== 0) {\n          // 'c' is current price, 0 often means no data\n          newPrices[symbol] = res.data.c;\n        } else {\n          newPrices[symbol] = null; // Mark as unavailable\n        }\n      });\n      setLivePrices(prev => ({\n        ...prev,\n        ...newPrices\n      }));\n    } catch (error) {\n      console.error(\"Error fetching live prices:\", error);\n      // Mark all requested symbols as unavailable on error\n      const errorPrices = {};\n      uniqueSymbols.forEach(symbol => {\n        errorPrices[symbol] = null;\n      });\n      setLivePrices(prev => ({\n        ...prev,\n        ...errorPrices\n      }));\n    }\n  }, [FINNHUB_API_KEY]); // FINNHUB_API_KEY is a constant, can be removed if strictly adhering to exhaustive-deps for non-changing values\n\n  // --- Helper to fetch user's capital from Supabase ---\n  const fetchCapital = useCallback(async userId => {\n    if (!userId) {\n      setCapital(10000); // Reset to default if no user\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"user_profiles\").select(\"capital\").eq(\"user_id\", userId).single();\n      if (error && error.code !== 'PGRST116') {\n        // PGRST116 means no rows found (new user)\n        throw error;\n      }\n      if (data) {\n        setCapital(data.capital);\n      } else {\n        // If no profile exists, create one with default capital\n        const {\n          data: newProfile,\n          error: insertError\n        } = await supabase.from(\"user_profiles\").insert([{\n          user_id: userId,\n          capital: 10000\n        }]).select(\"capital\").single();\n        if (insertError) throw insertError;\n        setCapital(newProfile.capital);\n      }\n    } catch (error) {\n      console.error(\"Error fetching or setting capital:\", error.message);\n      // Fallback to default capital if DB operation fails\n      setCapital(10000);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Function to update capital in Supabase ---\n  const updateCapitalInDb = useCallback(async (newCapital, userId) => {\n    if (!userId) {\n      console.warn(\"updateCapitalInDb: No user ID, not updating DB.\");\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        error\n      } = await supabase.from(\"user_profiles\").update({\n        capital: newCapital\n      }).eq(\"user_id\", userId);\n      if (error) throw error;\n      setCapital(newCapital); // Update local state only after successful DB update\n    } catch (error) {\n      console.error(\"Error updating capital in DB:\", error.message);\n      // You might want to revert the local state or show an error to the user\n      // if the DB update fails, or trigger a re-fetch.\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Wrapped setCapital to update DB as well ---\n  const handleSetCapital = useCallback(async newCapital => {\n    // Optimistic update\n    setCapital(newCapital);\n    // Then attempt to update DB\n    if (user === null || user === void 0 ? void 0 : user.id) {\n      await updateCapitalInDb(newCapital, user.id);\n    } else {\n      console.warn(\"No user ID available for DB capital update.\");\n    }\n  }, [user, updateCapitalInDb]);\n\n  // --- Fetch trades for the current user ---\n  const fetchTrades = useCallback(async userId => {\n    if (!userId) {\n      setTrades([]); // Clear trades if no user\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"trades\").select(\"*\").eq(\"user_id\", userId).order(\"created_at\", {\n        ascending: false\n      });\n      if (error) throw error;\n      setTrades(data);\n    } catch (error) {\n      console.error(\"Error fetching trades:\", error.message);\n      setTrades([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- NEW: Fetch watchlist symbols for the current user ---\n  const fetchWatchlist = useCallback(async userId => {\n    if (!userId) {\n      setWatchListSymbols([]);\n      return;\n    }\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"watchlists\").select(\"symbol\").eq(\"user_id\", userId).order(\"created_at\", {\n        ascending: true\n      }); // Order by creation for consistent display\n\n      if (error) throw error;\n      setWatchListSymbols(data.map(item => item.symbol));\n    } catch (error) {\n      console.error(\"Error fetching watchlist:\", error.message);\n      setWatchListSymbols([]);\n    }\n  }, []);\n\n  // --- NEW: Add symbol to watchlist ---\n  const addToWatchlist = useCallback(async symbol => {\n    if (!(user === null || user === void 0 ? void 0 : user.id)) {\n      throw new Error(\"User not authenticated.\");\n    }\n    const normalizedSymbol = symbol.toUpperCase();\n    if (watchListSymbols.includes(normalizedSymbol)) {\n      throw new Error(`'${normalizedSymbol}' is already in your watchlist.`);\n    }\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"watchlists\").insert([{\n        user_id: user.id,\n        symbol: normalizedSymbol\n      }]).select(\"symbol\").single();\n      if (error) throw error;\n      setWatchListSymbols(prev => [...prev, data.symbol]);\n      // Also fetch live price for this new symbol\n      fetchLivePrices([normalizedSymbol]); // This call is now safe as fetchLivePrices is defined\n    } catch (error) {\n      console.error(\"Error adding to watchlist:\", error.message);\n      throw error; // Re-throw to be handled by UI\n    }\n  }, [user, watchListSymbols, fetchLivePrices]);\n\n  // --- NEW: Remove symbol from watchlist ---\n  const removeFromWatchlist = useCallback(async symbol => {\n    if (!(user === null || user === void 0 ? void 0 : user.id)) {\n      throw new Error(\"User not authenticated.\");\n    }\n    try {\n      const {\n        error\n      } = await supabase.from(\"watchlists\").delete().eq(\"user_id\", user.id).eq(\"symbol\", symbol.toUpperCase());\n      if (error) throw error;\n      setWatchListSymbols(prev => prev.filter(s => s !== symbol.toUpperCase()));\n      // Optionally remove price from livePrices if it's no longer needed anywhere else\n      setLivePrices(prev => {\n        const newPrices = {\n          ...prev\n        };\n        delete newPrices[symbol.toUpperCase()];\n        return newPrices;\n      });\n    } catch (error) {\n      console.error(\"Error removing from watchlist:\", error.message);\n      throw error; // Re-throw to be handled by UI\n    }\n  }, [user]);\n\n  // --- Fetch available US stock symbols from Finnhub ---\n  const fetchAvailableSymbols = useCallback(async () => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      setSymbolError(\"Invalid Finnhub API Key. Cannot fetch US stock symbols.\");\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        data\n      } = await axios.get(`https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`);\n      // Filter for common stock types (e.g., 'Common Stock', 'ADR', 'REIT', 'ETP')\n      const filteredSymbols = data.filter(s => s.type === \"Common Stock\" || s.type === \"ADR\" || s.type === \"REIT\" || s.type === \"ETP\" || s.type === \"ETF\").map(s => s.symbol).sort(); // Sort alphabetically\n\n      setAvailableSymbols(filteredSymbols);\n      setSymbolError(\"\"); // Clear any previous errors\n    } catch (error) {\n      console.error(\"Error fetching available symbols:\", error);\n      setSymbolError(\"Failed to fetch US stock symbols. This might be due to API rate limits or an invalid Finnhub API key (free tier keys have limited symbol access).\");\n      setAvailableSymbols([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, [FINNHUB_API_KEY]);\n\n  // --- Calculate PnL and Holdings ---\n  const calculatePnL = useCallback(() => {\n    let holdings = {};\n    let totalRealizedPnl = 0;\n    trades.forEach(trade => {\n      if (!holdings[trade.symbol]) {\n        holdings[trade.symbol] = {\n          symbol: trade.symbol,\n          netQty: 0,\n          totalCost: 0,\n          avgBuyPrice: 0\n        };\n      }\n      if (trade.type === \"buy\") {\n        holdings[trade.symbol].totalCost += trade.quantity * trade.price;\n        holdings[trade.symbol].netQty += trade.quantity;\n        holdings[trade.symbol].avgBuyPrice = holdings[trade.symbol].totalCost / holdings[trade.symbol].netQty;\n      } else {\n        // Sell logic: Calculate realized P&L based on average buy price\n        const {\n          netQty: currentNetQty,\n          avgBuyPrice\n        } = holdings[trade.symbol];\n        if (currentNetQty > 0) {\n          const sellProfit = (trade.price - avgBuyPrice) * trade.quantity;\n          totalRealizedPnl += sellProfit;\n        }\n        holdings[trade.symbol].netQty -= trade.quantity;\n        // If netQty becomes 0 or negative, reset cost/avg price\n        if (holdings[trade.symbol].netQty <= 0) {\n          holdings[trade.symbol].totalCost = 0;\n          holdings[trade.symbol].avgBuyPrice = 0;\n        } else {\n          // If selling partial, totalCost needs to be adjusted proportionally\n          holdings[trade.symbol].totalCost = holdings[trade.symbol].netQty * holdings[trade.symbol].avgBuyPrice;\n        }\n      }\n    });\n    let totalUnrealizedPnl = 0;\n    // Calculate unrealized P&L for current holdings\n    Object.values(holdings).forEach(holding => {\n      if (holding.netQty > 0 && livePrices[holding.symbol]) {\n        const livePrice = livePrices[holding.symbol];\n        const unrealized = (livePrice - holding.avgBuyPrice) * holding.netQty;\n        holding.unrealizedPnl = unrealized.toFixed(2);\n        totalUnrealizedPnl += unrealized;\n      } else {\n        holding.unrealizedPnl = \"0.00\";\n      }\n    });\n    return {\n      holdings: Object.values(holdings),\n      totalRealizedPnl: totalRealizedPnl.toFixed(2),\n      totalUnrealizedPnl: totalUnrealizedPnl.toFixed(2)\n    };\n  }, [trades, livePrices]);\n\n  // --- Calculate total portfolio value ---\n  const calculateTotalPortfolioValue = useCallback(() => {\n    const {\n      holdings\n    } = calculatePnL();\n    let holdingsValue = 0;\n    holdings.forEach(holding => {\n      if (holding.netQty > 0 && livePrices[holding.symbol]) {\n        holdingsValue += holding.netQty * livePrices[holding.symbol];\n      }\n    });\n    return (capital + holdingsValue).toFixed(2);\n  }, [capital, calculatePnL, livePrices]);\n\n  // --- NEW: Remove trade logic ---\n  const removeTrade = useCallback(async tradeToRemove => {\n    if (!(user === null || user === void 0 ? void 0 : user.id)) throw new Error(\"User not authenticated.\");\n    try {\n      const {\n        error: deleteError\n      } = await supabase.from(\"trades\").delete().eq(\"id\", tradeToRemove.id).eq(\"user_id\", user.id); // Ensure user owns the trade\n\n      if (deleteError) throw deleteError;\n\n      // Re-fetch all trades to get the accurate state after deletion\n      // and recalculate capital based on the new trade history\n      await fetchTrades(user.id);\n\n      // Re-calculate capital based on the *entire* trade history from scratch\n      // This is the safest way to ensure capital is correct after a trade is removed.\n      const {\n        data: allTradesAfterDeletion,\n        error: fetchAllTradesError\n      } = await supabase.from(\"trades\").select(\"*\").eq(\"user_id\", user.id).order(\"created_at\", {\n        ascending: true\n      }); // Need historical order for accurate capital calculation\n\n      if (fetchAllTradesError) throw fetchAllTradesError;\n      let calculatedCapital = 10000; // Start with initial capital\n      allTradesAfterDeletion.forEach(trade => {\n        if (trade.type === 'buy') {\n          calculatedCapital -= trade.quantity * trade.price;\n        } else {\n          // sell\n          calculatedCapital += trade.quantity * trade.price;\n        }\n      });\n      await handleSetCapital(calculatedCapital); // Update capital in DB and local state\n\n      // Since trades are re-fetched, the calculatePnL in consuming components will also update.\n    } catch (error) {\n      console.error(\"Error removing trade:\", error.message);\n      throw error;\n    }\n  }, [user, fetchTrades, handleSetCapital]);\n\n  // --- Initial Data Load on Mount or User Change ---\n  useEffect(() => {\n    const {\n      data: authListener\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      setSession(session);\n      const currentUser = (session === null || session === void 0 ? void 0 : session.user) || null;\n      setUser(currentUser);\n      if (currentUser) {\n        setLoadingData(true);\n        await fetchCapital(currentUser.id);\n        await fetchTrades(currentUser.id);\n        await fetchWatchlist(currentUser.id); // Fetch watchlist\n        setLoadingData(false);\n      } else {\n        // Clear states if user logs out\n        setCapital(10000);\n        setTrades([]);\n        setWatchListSymbols([]); // Clear watchlist\n        setLivePrices({});\n        setUser(null);\n        setLoadingData(false);\n      }\n    });\n\n    // Initial check for session\n    const checkSession = async () => {\n      setLoadingData(true);\n      const {\n        data: {\n          session\n        }\n      } = await supabase.auth.getSession();\n      setSession(session);\n      const currentUser = (session === null || session === void 0 ? void 0 : session.user) || null;\n      setUser(currentUser);\n      if (currentUser) {\n        await fetchCapital(currentUser.id);\n        await fetchTrades(currentUser.id);\n        await fetchWatchlist(currentUser.id); // Fetch watchlist\n      }\n      setLoadingData(false);\n    };\n    checkSession();\n    fetchAvailableSymbols(); // Fetch symbols once on load\n\n    return () => {\n      authListener.subscription.unsubscribe();\n    };\n  }, [fetchCapital, fetchTrades, fetchAvailableSymbols, fetchWatchlist]);\n\n  // --- Effect to fetch live prices for all relevant symbols ---\n  useEffect(() => {\n    // Collect all unique symbols from trades and watchlist\n    const allSymbols = [...new Set([...trades.map(t => t.symbol), ...watchListSymbols,\n    // Include watchlist symbols\n    ...Object.keys(livePrices) // Keep previously fetched symbols\n    ])].filter(Boolean); // Filter out any null/undefined symbols\n\n    if (allSymbols.length > 0) {\n      fetchLivePrices(allSymbols);\n\n      // Set up an interval for live price updates (e.g., every 15-30 seconds)\n      const interval = setInterval(() => {\n        fetchLivePrices(allSymbols);\n      }, 20000); // Update every 20 seconds\n\n      return () => clearInterval(interval); // Cleanup interval\n    }\n  }, [trades, watchListSymbols, fetchLivePrices]);\n\n  // Memoize the context value to prevent unnecessary re-renders\n  const contextValue = useMemo(() => ({\n    user,\n    trades,\n    capital,\n    setCapital: handleSetCapital,\n    // Use the wrapped setter\n    livePrices,\n    availableSymbols,\n    symbolError,\n    setSymbolError,\n    fetchTrades,\n    fetchLivePrices,\n    calculatePnL,\n    calculateTotalPortfolioValue,\n    isInvalidApiKey,\n    FINNHUB_API_KEY,\n    CURRENCY_SYMBOL,\n    loadingData,\n    removeTrade,\n    watchListSymbols,\n    // Add to context value\n    addToWatchlist,\n    // Add to context value\n    removeFromWatchlist // Add to context value\n  }), [user, trades, capital, handleSetCapital, livePrices, availableSymbols, symbolError, setSymbolError, fetchTrades, fetchLivePrices, calculatePnL, calculateTotalPortfolioValue, isInvalidApiKey,\n  // Consider removing if truly a constant\n  FINNHUB_API_KEY,\n  // Consider removing if truly a constant\n  CURRENCY_SYMBOL,\n  // Consider removing if truly a constant\n  loadingData, removeTrade, watchListSymbols, addToWatchlist, removeFromWatchlist]);\n  return /*#__PURE__*/React.createElement(TradingDataContext.Provider, {\n    value: contextValue,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 531,\n      columnNumber: 5\n    }\n  }, children);\n};\nexport const useTradingData = () => useContext(TradingDataContext);","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useCallback","useMemo","supabase","axios","TradingDataContext","FINNHUB_API_KEY","process","env","REACT_APP_FINNHUB_API_KEY","CURRENCY_SYMBOL","REACT_APP_CURRENCY_SYMBOL","isInvalidApiKey","key","length","TradingDataProvider","children","user","setUser","trades","setTrades","capital","setCapital","livePrices","setLivePrices","availableSymbols","setAvailableSymbols","symbolError","setSymbolError","loadingData","setLoadingData","session","setSession","watchListSymbols","setWatchListSymbols","fetchLivePrices","symbolsToFetch","uniqueSymbols","Set","filter","s","prev","newPrices","forEach","sym","responses","Promise","all","map","symbol","get","res","index","data","c","error","console","errorPrices","fetchCapital","userId","from","select","eq","single","code","newProfile","insertError","insert","user_id","message","updateCapitalInDb","newCapital","warn","update","handleSetCapital","id","fetchTrades","order","ascending","fetchWatchlist","item","addToWatchlist","Error","normalizedSymbol","toUpperCase","includes","removeFromWatchlist","delete","fetchAvailableSymbols","filteredSymbols","type","sort","calculatePnL","holdings","totalRealizedPnl","trade","netQty","totalCost","avgBuyPrice","quantity","price","currentNetQty","sellProfit","totalUnrealizedPnl","Object","values","holding","livePrice","unrealized","unrealizedPnl","toFixed","calculateTotalPortfolioValue","holdingsValue","removeTrade","tradeToRemove","deleteError","allTradesAfterDeletion","fetchAllTradesError","calculatedCapital","authListener","auth","onAuthStateChange","event","currentUser","checkSession","getSession","subscription","unsubscribe","allSymbols","t","keys","Boolean","interval","setInterval","clearInterval","contextValue","createElement","Provider","value","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","useTradingData"],"sources":["/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js"],"sourcesContent":["// src/TradingDataContext.js\nimport React, { createContext, useContext, useState, useEffect, useCallback, useMemo } from \"react\";\nimport { supabase } from \"./supabaseClient\";\nimport axios from \"axios\";\n\nconst TradingDataContext = createContext();\n\n// Constants for API Key and Currency Symbol - Replace with your actual values\nconst FINNHUB_API_KEY = process.env.REACT_APP_FINNHUB_API_KEY || \"YOUR_FINNHUB_API_KEY\"; // Get from .env or replace\nconst CURRENCY_SYMBOL = process.env.REACT_APP_CURRENCY_SYMBOL || \"$\"; // Get from .env or replace\n\n// Helper to check if API key is valid (simple check)\nconst isInvalidApiKey = (key) => {\n  return !key || key === \"YOUR_FINNHUB_API_KEY\" || key.length < 10; // Basic check\n};\n\nexport const TradingDataProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [trades, setTrades] = useState([]);\n  const [capital, setCapital] = useState(10000); // Initial capital\n  const [livePrices, setLivePrices] = useState({});\n  const [availableSymbols, setAvailableSymbols] = useState([]);\n  const [symbolError, setSymbolError] = useState(\"\");\n  const [loadingData, setLoadingData] = useState(true);\n  const [session, setSession] = useState(null); // Supabase session\n  const [watchListSymbols, setWatchListSymbols] = useState([]); // NEW STATE for watchlist symbols\n\n  // --- Fetch live prices for a given list of symbols (MOVED UP) ---\n  const fetchLivePrices = useCallback(async (symbolsToFetch) => {\n    // Filter out invalid symbols or duplicates\n    const uniqueSymbols = [...new Set(symbolsToFetch)].filter(s => s && typeof s === 'string');\n\n    if (uniqueSymbols.length === 0 || isInvalidApiKey(FINNHUB_API_KEY)) {\n      setLivePrices((prev) => { // Clear prices for symbols not being fetched\n        const newPrices = {};\n        // Keep existing prices if they're for symbols currently being watched/held\n        // This logic needs to be careful not to remove valid prices if the input is empty\n        // For simplicity, if uniqueSymbols is empty, we don't update prices here.\n        if (uniqueSymbols.length === 0) return prev;\n\n        // If specific symbols are requested, only keep those\n        uniqueSymbols.forEach(sym => {\n            if (prev[sym]) newPrices[sym] = prev[sym];\n        });\n        return newPrices;\n      });\n      return;\n    }\n\n    try {\n      const responses = await Promise.all(\n        uniqueSymbols.map((symbol) =>\n          axios.get(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`)\n        )\n      );\n\n      const newPrices = {};\n      responses.forEach((res, index) => {\n        const symbol = uniqueSymbols[index];\n        if (res.data && res.data.c !== 0) { // 'c' is current price, 0 often means no data\n          newPrices[symbol] = res.data.c;\n        } else {\n          newPrices[symbol] = null; // Mark as unavailable\n        }\n      });\n\n      setLivePrices((prev) => ({ ...prev, ...newPrices }));\n    } catch (error) {\n      console.error(\"Error fetching live prices:\", error);\n      // Mark all requested symbols as unavailable on error\n      const errorPrices = {};\n      uniqueSymbols.forEach(symbol => { errorPrices[symbol] = null; });\n      setLivePrices((prev) => ({ ...prev, ...errorPrices }));\n    }\n  }, [FINNHUB_API_KEY]); // FINNHUB_API_KEY is a constant, can be removed if strictly adhering to exhaustive-deps for non-changing values\n\n  // --- Helper to fetch user's capital from Supabase ---\n  const fetchCapital = useCallback(async (userId) => {\n    if (!userId) {\n      setCapital(10000); // Reset to default if no user\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { data, error } = await supabase\n        .from(\"user_profiles\")\n        .select(\"capital\")\n        .eq(\"user_id\", userId)\n        .single();\n\n      if (error && error.code !== 'PGRST116') { // PGRST116 means no rows found (new user)\n        throw error;\n      }\n\n      if (data) {\n        setCapital(data.capital);\n      } else {\n        // If no profile exists, create one with default capital\n        const { data: newProfile, error: insertError } = await supabase\n          .from(\"user_profiles\")\n          .insert([{ user_id: userId, capital: 10000 }])\n          .select(\"capital\")\n          .single();\n\n        if (insertError) throw insertError;\n        setCapital(newProfile.capital);\n      }\n    } catch (error) {\n      console.error(\"Error fetching or setting capital:\", error.message);\n      // Fallback to default capital if DB operation fails\n      setCapital(10000);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Function to update capital in Supabase ---\n  const updateCapitalInDb = useCallback(async (newCapital, userId) => {\n    if (!userId) {\n      console.warn(\"updateCapitalInDb: No user ID, not updating DB.\");\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { error } = await supabase\n        .from(\"user_profiles\")\n        .update({ capital: newCapital })\n        .eq(\"user_id\", userId);\n\n      if (error) throw error;\n      setCapital(newCapital); // Update local state only after successful DB update\n    } catch (error) {\n      console.error(\"Error updating capital in DB:\", error.message);\n      // You might want to revert the local state or show an error to the user\n      // if the DB update fails, or trigger a re-fetch.\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Wrapped setCapital to update DB as well ---\n  const handleSetCapital = useCallback(async (newCapital) => {\n    // Optimistic update\n    setCapital(newCapital);\n    // Then attempt to update DB\n    if (user?.id) {\n      await updateCapitalInDb(newCapital, user.id);\n    } else {\n      console.warn(\"No user ID available for DB capital update.\");\n    }\n  }, [user, updateCapitalInDb]);\n\n  // --- Fetch trades for the current user ---\n  const fetchTrades = useCallback(async (userId) => {\n    if (!userId) {\n      setTrades([]); // Clear trades if no user\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { data, error } = await supabase\n        .from(\"trades\")\n        .select(\"*\")\n        .eq(\"user_id\", userId)\n        .order(\"created_at\", { ascending: false });\n\n      if (error) throw error;\n      setTrades(data);\n    } catch (error) {\n      console.error(\"Error fetching trades:\", error.message);\n      setTrades([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- NEW: Fetch watchlist symbols for the current user ---\n  const fetchWatchlist = useCallback(async (userId) => {\n    if (!userId) {\n      setWatchListSymbols([]);\n      return;\n    }\n    try {\n      const { data, error } = await supabase\n        .from(\"watchlists\")\n        .select(\"symbol\")\n        .eq(\"user_id\", userId)\n        .order(\"created_at\", { ascending: true }); // Order by creation for consistent display\n\n      if (error) throw error;\n      setWatchListSymbols(data.map(item => item.symbol));\n    } catch (error) {\n      console.error(\"Error fetching watchlist:\", error.message);\n      setWatchListSymbols([]);\n    }\n  }, []);\n\n  // --- NEW: Add symbol to watchlist ---\n  const addToWatchlist = useCallback(async (symbol) => {\n    if (!user?.id) {\n      throw new Error(\"User not authenticated.\");\n    }\n    const normalizedSymbol = symbol.toUpperCase();\n    if (watchListSymbols.includes(normalizedSymbol)) {\n      throw new Error(`'${normalizedSymbol}' is already in your watchlist.`);\n    }\n\n    try {\n      const { data, error } = await supabase\n        .from(\"watchlists\")\n        .insert([{ user_id: user.id, symbol: normalizedSymbol }])\n        .select(\"symbol\")\n        .single();\n\n      if (error) throw error;\n      setWatchListSymbols((prev) => [...prev, data.symbol]);\n      // Also fetch live price for this new symbol\n      fetchLivePrices([normalizedSymbol]); // This call is now safe as fetchLivePrices is defined\n    } catch (error) {\n      console.error(\"Error adding to watchlist:\", error.message);\n      throw error; // Re-throw to be handled by UI\n    }\n  }, [user, watchListSymbols, fetchLivePrices]);\n\n  // --- NEW: Remove symbol from watchlist ---\n  const removeFromWatchlist = useCallback(async (symbol) => {\n    if (!user?.id) {\n      throw new Error(\"User not authenticated.\");\n    }\n    try {\n      const { error } = await supabase\n        .from(\"watchlists\")\n        .delete()\n        .eq(\"user_id\", user.id)\n        .eq(\"symbol\", symbol.toUpperCase());\n\n      if (error) throw error;\n      setWatchListSymbols((prev) => prev.filter((s) => s !== symbol.toUpperCase()));\n      // Optionally remove price from livePrices if it's no longer needed anywhere else\n      setLivePrices((prev) => {\n        const newPrices = { ...prev };\n        delete newPrices[symbol.toUpperCase()];\n        return newPrices;\n      });\n    } catch (error) {\n      console.error(\"Error removing from watchlist:\", error.message);\n      throw error; // Re-throw to be handled by UI\n    }\n  }, [user]);\n\n  // --- Fetch available US stock symbols from Finnhub ---\n  const fetchAvailableSymbols = useCallback(async () => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      setSymbolError(\"Invalid Finnhub API Key. Cannot fetch US stock symbols.\");\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { data } = await axios.get(\n        `https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`\n      );\n      // Filter for common stock types (e.g., 'Common Stock', 'ADR', 'REIT', 'ETP')\n      const filteredSymbols = data\n        .filter(\n          (s) =>\n            s.type === \"Common Stock\" ||\n            s.type === \"ADR\" ||\n            s.type === \"REIT\" ||\n            s.type === \"ETP\" ||\n            s.type === \"ETF\"\n        )\n        .map((s) => s.symbol)\n        .sort(); // Sort alphabetically\n\n      setAvailableSymbols(filteredSymbols);\n      setSymbolError(\"\"); // Clear any previous errors\n    } catch (error) {\n      console.error(\"Error fetching available symbols:\", error);\n      setSymbolError(\n        \"Failed to fetch US stock symbols. This might be due to API rate limits or an invalid Finnhub API key (free tier keys have limited symbol access).\"\n      );\n      setAvailableSymbols([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, [FINNHUB_API_KEY]);\n\n\n  // --- Calculate PnL and Holdings ---\n  const calculatePnL = useCallback(() => {\n    let holdings = {};\n    let totalRealizedPnl = 0;\n\n    trades.forEach((trade) => {\n      if (!holdings[trade.symbol]) {\n        holdings[trade.symbol] = {\n          symbol: trade.symbol,\n          netQty: 0,\n          totalCost: 0,\n          avgBuyPrice: 0,\n        };\n      }\n\n      if (trade.type === \"buy\") {\n        holdings[trade.symbol].totalCost += trade.quantity * trade.price;\n        holdings[trade.symbol].netQty += trade.quantity;\n        holdings[trade.symbol].avgBuyPrice =\n          holdings[trade.symbol].totalCost / holdings[trade.symbol].netQty;\n      } else {\n        // Sell logic: Calculate realized P&L based on average buy price\n        const { netQty: currentNetQty, avgBuyPrice } = holdings[trade.symbol];\n        if (currentNetQty > 0) {\n          const sellProfit = (trade.price - avgBuyPrice) * trade.quantity;\n          totalRealizedPnl += sellProfit;\n        }\n        holdings[trade.symbol].netQty -= trade.quantity;\n        // If netQty becomes 0 or negative, reset cost/avg price\n        if (holdings[trade.symbol].netQty <= 0) {\n          holdings[trade.symbol].totalCost = 0;\n          holdings[trade.symbol].avgBuyPrice = 0;\n        } else {\n          // If selling partial, totalCost needs to be adjusted proportionally\n          holdings[trade.symbol].totalCost = holdings[trade.symbol].netQty * holdings[trade.symbol].avgBuyPrice;\n        }\n      }\n    });\n\n    let totalUnrealizedPnl = 0;\n    // Calculate unrealized P&L for current holdings\n    Object.values(holdings).forEach((holding) => {\n      if (holding.netQty > 0 && livePrices[holding.symbol]) {\n        const livePrice = livePrices[holding.symbol];\n        const unrealized = (livePrice - holding.avgBuyPrice) * holding.netQty;\n        holding.unrealizedPnl = unrealized.toFixed(2);\n        totalUnrealizedPnl += unrealized;\n      } else {\n        holding.unrealizedPnl = \"0.00\";\n      }\n    });\n\n    return {\n      holdings: Object.values(holdings),\n      totalRealizedPnl: totalRealizedPnl.toFixed(2),\n      totalUnrealizedPnl: totalUnrealizedPnl.toFixed(2),\n    };\n  }, [trades, livePrices]);\n\n  // --- Calculate total portfolio value ---\n  const calculateTotalPortfolioValue = useCallback(() => {\n    const { holdings } = calculatePnL();\n    let holdingsValue = 0;\n    holdings.forEach(holding => {\n      if (holding.netQty > 0 && livePrices[holding.symbol]) {\n        holdingsValue += holding.netQty * livePrices[holding.symbol];\n      }\n    });\n    return (capital + holdingsValue).toFixed(2);\n  }, [capital, calculatePnL, livePrices]);\n\n\n  // --- NEW: Remove trade logic ---\n  const removeTrade = useCallback(async (tradeToRemove) => {\n    if (!user?.id) throw new Error(\"User not authenticated.\");\n\n    try {\n      const { error: deleteError } = await supabase\n        .from(\"trades\")\n        .delete()\n        .eq(\"id\", tradeToRemove.id)\n        .eq(\"user_id\", user.id); // Ensure user owns the trade\n\n      if (deleteError) throw deleteError;\n\n      // Re-fetch all trades to get the accurate state after deletion\n      // and recalculate capital based on the new trade history\n      await fetchTrades(user.id);\n\n      // Re-calculate capital based on the *entire* trade history from scratch\n      // This is the safest way to ensure capital is correct after a trade is removed.\n      const { data: allTradesAfterDeletion, error: fetchAllTradesError } = await supabase\n          .from(\"trades\")\n          .select(\"*\")\n          .eq(\"user_id\", user.id)\n          .order(\"created_at\", { ascending: true }); // Need historical order for accurate capital calculation\n\n      if (fetchAllTradesError) throw fetchAllTradesError;\n\n      let calculatedCapital = 10000; // Start with initial capital\n      allTradesAfterDeletion.forEach(trade => {\n          if (trade.type === 'buy') {\n              calculatedCapital -= (trade.quantity * trade.price);\n          } else { // sell\n              calculatedCapital += (trade.quantity * trade.price);\n          }\n      });\n\n      await handleSetCapital(calculatedCapital); // Update capital in DB and local state\n      \n      // Since trades are re-fetched, the calculatePnL in consuming components will also update.\n\n    } catch (error) {\n      console.error(\"Error removing trade:\", error.message);\n      throw error;\n    }\n  }, [user, fetchTrades, handleSetCapital]);\n\n\n  // --- Initial Data Load on Mount or User Change ---\n  useEffect(() => {\n    const { data: authListener } = supabase.auth.onAuthStateChange(\n      async (event, session) => {\n        setSession(session);\n        const currentUser = session?.user || null;\n        setUser(currentUser);\n\n        if (currentUser) {\n          setLoadingData(true);\n          await fetchCapital(currentUser.id);\n          await fetchTrades(currentUser.id);\n          await fetchWatchlist(currentUser.id); // Fetch watchlist\n          setLoadingData(false);\n        } else {\n          // Clear states if user logs out\n          setCapital(10000);\n          setTrades([]);\n          setWatchListSymbols([]); // Clear watchlist\n          setLivePrices({});\n          setUser(null);\n          setLoadingData(false);\n        }\n      }\n    );\n\n    // Initial check for session\n    const checkSession = async () => {\n      setLoadingData(true);\n      const { data: { session } } = await supabase.auth.getSession();\n      setSession(session);\n      const currentUser = session?.user || null;\n      setUser(currentUser);\n\n      if (currentUser) {\n        await fetchCapital(currentUser.id);\n        await fetchTrades(currentUser.id);\n        await fetchWatchlist(currentUser.id); // Fetch watchlist\n      }\n      setLoadingData(false);\n    };\n\n    checkSession();\n    fetchAvailableSymbols(); // Fetch symbols once on load\n\n    return () => {\n      authListener.subscription.unsubscribe();\n    };\n  }, [fetchCapital, fetchTrades, fetchAvailableSymbols, fetchWatchlist]);\n\n  // --- Effect to fetch live prices for all relevant symbols ---\n  useEffect(() => {\n    // Collect all unique symbols from trades and watchlist\n    const allSymbols = [\n      ...new Set([\n        ...trades.map((t) => t.symbol),\n        ...watchListSymbols, // Include watchlist symbols\n        ...Object.keys(livePrices) // Keep previously fetched symbols\n      ])\n    ].filter(Boolean); // Filter out any null/undefined symbols\n\n    if (allSymbols.length > 0) {\n      fetchLivePrices(allSymbols);\n\n      // Set up an interval for live price updates (e.g., every 15-30 seconds)\n      const interval = setInterval(() => {\n        fetchLivePrices(allSymbols);\n      }, 20000); // Update every 20 seconds\n\n      return () => clearInterval(interval); // Cleanup interval\n    }\n  }, [trades, watchListSymbols, fetchLivePrices]);\n\n\n  // Memoize the context value to prevent unnecessary re-renders\n  const contextValue = useMemo(\n    () => ({\n      user,\n      trades,\n      capital,\n      setCapital: handleSetCapital, // Use the wrapped setter\n      livePrices,\n      availableSymbols,\n      symbolError,\n      setSymbolError,\n      fetchTrades,\n      fetchLivePrices,\n      calculatePnL,\n      calculateTotalPortfolioValue,\n      isInvalidApiKey,\n      FINNHUB_API_KEY,\n      CURRENCY_SYMBOL,\n      loadingData,\n      removeTrade,\n      watchListSymbols, // Add to context value\n      addToWatchlist,   // Add to context value\n      removeFromWatchlist, // Add to context value\n    }),\n    [\n      user,\n      trades,\n      capital,\n      handleSetCapital,\n      livePrices,\n      availableSymbols,\n      symbolError,\n      setSymbolError,\n      fetchTrades,\n      fetchLivePrices,\n      calculatePnL,\n      calculateTotalPortfolioValue,\n      isInvalidApiKey, // Consider removing if truly a constant\n      FINNHUB_API_KEY, // Consider removing if truly a constant\n      CURRENCY_SYMBOL, // Consider removing if truly a constant\n      loadingData,\n      removeTrade,\n      watchListSymbols,\n      addToWatchlist,\n      removeFromWatchlist,\n    ]\n  );\n\n  return (\n    <TradingDataContext.Provider value={contextValue}>\n      {children}\n    </TradingDataContext.Provider>\n  );\n};\n\nexport const useTradingData = () => useContext(TradingDataContext);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}