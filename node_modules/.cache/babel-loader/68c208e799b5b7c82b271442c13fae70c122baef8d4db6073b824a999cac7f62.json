{"ast":null,"code":"var _jsxFileName = \"/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// src/TradingDataContext.js\nimport React, { createContext, useContext, useState, useEffect, useCallback, useMemo, useRef } from \"react\";\nimport { supabase } from \"./supabaseClient\";\nimport axios from \"axios\";\n\n// Constants for API Key and Currency Symbol\n// WARNING: Hardcoding API keys directly in source code is not recommended for security.\n// Consider using environment variables (.env file) for production deployment.\n// For now, I'm keeping your original hardcoded keys as per your request.\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const FINNHUB_API_KEY = \"d108911r01qhkqr8ggb0d108911r01qhkqr8ggbg\"; // YOUR FINNHUB API KEY\nexport const ALPHA_VANTAGE_API_KEY = \"DR0O9MY1P0QU6ZEL\"; // YOUR ALPHA VANTAGE API KEY HERE\nexport const CURRENCY_SYMBOL = \"$\"; // Your currency symbol\n\n// Helper to check if API key is valid (simple check)\nexport const isInvalidApiKey = key => {\n  const trimmedKey = key ? key.trim() : '';\n  // Check for empty string, Finnhub placeholder, or Alpha Vantage placeholder\n  return !trimmedKey || trimmedKey === \"YOUR_FINNHUB_API_KEY_HERE\" || trimmedKey === \"YOUR_ALPHA_VANTAGE_API_KEY\" || trimmedKey.length < 10;\n};\n\n// --- Caching Helpers (can be moved to utils/cache.js if desired later) ---\nconst getCachedData = (key, durationMs) => {\n  try {\n    const cachedItem = localStorage.getItem(key);\n    if (cachedItem) {\n      const {\n        data,\n        timestamp\n      } = JSON.parse(cachedItem);\n      if (Date.now() - timestamp < durationMs) {\n        return data;\n      }\n    }\n  } catch (e) {\n    console.error(`[Cache Error] Failed to retrieve or parse cached data for ${key}:`, e);\n    localStorage.removeItem(key); // Clear corrupted cache entry\n  }\n  return null;\n};\nconst setCachedData = (key, data) => {\n  try {\n    localStorage.setItem(key, JSON.stringify({\n      data,\n      timestamp: Date.now()\n    }));\n  } catch (e) {\n    console.error(`[Cache Error] Failed to set cached data for ${key}:`, e);\n  }\n};\n\n// --- Cache Durations (Adjust these values based on API limits and data freshness needs) ---\n// Finnhub free tier: 60 calls/min. Alpha Vantage free tier: 5 calls/min, 25 calls/day.\nconst LIVE_PRICE_CACHE_DURATION = 15 * 1000; // 15 seconds for live prices to stay within Finnhub limits\nconst AVAILABLE_SYMBOLS_CACHE_DURATION = 7 * 24 * 60 * 60 * 1000; // 7 days for available symbols\nconst API_CALL_DELAY = 200; // Milliseconds delay between consecutive API calls in a batch (e.g., for live prices)\n\nconst TradingDataContext = /*#__PURE__*/createContext();\nexport const TradingDataProvider = ({\n  children\n}) => {\n  _s();\n  const [user, setUser] = useState(null);\n  const [trades, setTrades] = useState([]);\n  const [capital, setCapital] = useState(10000); // Initial capital\n  const [livePrices, setLivePrices] = useState({});\n  const [availableSymbols, setAvailableSymbols] = useState([]);\n  const [symbolError, setSymbolError] = useState(\"\");\n  const [loadingData, setLoadingData] = useState(true);\n  const [session, setSession] = useState(null); // Supabase session\n  const [watchListSymbols, setWatchListSymbols] = useState([]);\n  const [holdings, setHoldings] = useState({}); // New state for holdings\n\n  // --- API Call Queueing/Throttling using useRef ---\n  const apiCallQueue = useRef([]);\n  const isProcessingQueue = useRef(false);\n  const processApiCallQueue = useCallback(async () => {\n    if (isProcessingQueue.current || apiCallQueue.current.length === 0) {\n      return;\n    }\n    isProcessingQueue.current = true;\n    while (apiCallQueue.current.length > 0) {\n      const {\n        symbol,\n        resolve,\n        reject,\n        type\n      } = apiCallQueue.current.shift(); // Get oldest task\n\n      try {\n        let price = null;\n        if (type === 'quote') {\n          const res = await axios.get(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`);\n          price = res.data && res.data.c !== 0 ? res.data.c : null;\n        }\n\n        // Update local cache and state immediately after successful fetch\n        if (price !== null) {\n          setCachedData(`finnhub_quote_${symbol}`, price); // Cache the price directly\n          setLivePrices(prev => ({\n            ...prev,\n            [symbol]: price\n          }));\n        } else {\n          setLivePrices(prev => ({\n            ...prev,\n            [symbol]: null\n          })); // Mark as unavailable\n        }\n        resolve(price);\n      } catch (error) {\n        console.error(`Error fetching ${type} for ${symbol}:`, error);\n        if (axios.isAxiosError(error) && error.response && error.response.status === 429) {\n          console.warn(`Rate limit hit for ${symbol}. Consider increasing API_CALL_DELAY.`);\n          // Potentially re-add to queue with exponential backoff or set specific error state\n        }\n        setLivePrices(prev => ({\n          ...prev,\n          [symbol]: null\n        })); // Mark as unavailable on error\n        reject(error);\n      }\n      await new Promise(res => setTimeout(res, API_CALL_DELAY)); // Wait before next call\n    }\n    isProcessingQueue.current = false;\n  }, [FINNHUB_API_KEY]); // Dependency for API key\n\n  const addApiCallToQueue = useCallback((symbol, type = 'quote') => {\n    return new Promise((resolve, reject) => {\n      apiCallQueue.current.push({\n        symbol,\n        resolve,\n        reject,\n        type\n      });\n      if (!isProcessingQueue.current) {\n        processApiCallQueue();\n      }\n    });\n  }, [processApiCallQueue]);\n\n  // --- Fetch live prices for a given list of symbols (uses Finnhub) ---\n  const fetchLivePrices = useCallback(async symbolsToFetch => {\n    const uniqueSymbols = [...new Set(symbolsToFetch)].filter(s => s && typeof s === 'string');\n    const newPrices = {};\n    const symbolsToQueueForApi = [];\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      setLivePrices(prev => {\n        const updated = {};\n        uniqueSymbols.forEach(sym => {\n          updated[sym] = prev[sym] || null;\n        }); // Keep existing or set null\n        return {\n          ...prev,\n          ...updated\n        };\n      });\n      console.warn(\"Invalid Finnhub API Key. Cannot fetch live prices.\");\n      return;\n    }\n    for (const symbol of uniqueSymbols) {\n      const cachedPrice = getCachedData(`finnhub_quote_${symbol}`, LIVE_PRICE_CACHE_DURATION);\n      if (cachedPrice !== null) {\n        newPrices[symbol] = cachedPrice;\n      } else {\n        symbolsToQueueForApi.push(symbol);\n      }\n    }\n\n    // Update with immediately available cached prices\n    setLivePrices(prev => ({\n      ...prev,\n      ...newPrices\n    }));\n\n    // Now, queue only the uncached symbols with delay/throttling\n    if (symbolsToQueueForApi.length > 0) {\n      console.log(`[Finnhub] Queuing ${symbolsToQueueForApi.length} uncached live prices for fetch...`);\n      // Add each uncached symbol to the queue\n      symbolsToQueueForApi.forEach(symbol => {\n        addApiCallToQueue(symbol, 'quote');\n      });\n    }\n  }, [addApiCallToQueue, FINNHUB_API_KEY, isInvalidApiKey]);\n\n  // --- Helper to fetch user's capital from Supabase ---\n  const fetchCapital = useCallback(async userId => {\n    if (!userId) {\n      setCapital(10000);\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"user_profiles\").select(\"capital\").eq(\"user_id\", userId).single();\n      if (error && error.code !== 'PGRST116') {\n        // PGRST116 means \"no row found\"\n        throw error;\n      }\n      if (data) {\n        setCapital(data.capital);\n      } else {\n        // If no profile exists, create one with initial capital\n        const {\n          data: newProfile,\n          error: insertError\n        } = await supabase.from(\"user_profiles\").insert([{\n          user_id: userId,\n          capital: 10000\n        }]).select(\"capital\").single();\n        if (insertError) throw insertError;\n        setCapital(newProfile.capital);\n      }\n    } catch (error) {\n      console.error(\"Error fetching or setting capital:\", error.message);\n      setCapital(10000); // Default to initial capital on error\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Function to update capital in Supabase ---\n  const updateCapitalInDb = useCallback(async (newCapital, userId) => {\n    if (!userId) {\n      console.warn(\"updateCapitalInDb: No user ID, not updating DB.\");\n      return;\n    }\n    setLoadingData(true); // Can be optimized, maybe a separate loading state for capital\n    try {\n      const {\n        error\n      } = await supabase.from(\"user_profiles\").update({\n        capital: newCapital\n      }).eq(\"user_id\", userId);\n      if (error) throw error;\n      setCapital(newCapital); // Update local state after successful DB update\n    } catch (error) {\n      console.error(\"Error updating capital in DB:\", error.message);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Wrapped setCapital to update DB as well ---\n  const handleSetCapital = useCallback(async newCapital => {\n    setCapital(newCapital); // Optimistically update local state\n    if (user !== null && user !== void 0 && user.id) {\n      await updateCapitalInDb(newCapital, user.id);\n    } else {\n      console.warn(\"No user ID available for DB capital update.\");\n    }\n  }, [user, updateCapitalInDb]);\n\n  // --- Fetch trades for the current user ---\n  const fetchTrades = useCallback(async userId => {\n    if (!userId) {\n      setTrades([]);\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"trades\").select(\"*\").eq(\"user_id\", userId).order(\"created_at\", {\n        ascending: false\n      });\n      if (error) throw error;\n      setTrades(data);\n    } catch (error) {\n      console.error(\"Error fetching trades:\", error.message);\n      setTrades([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Fetch holdings for the current user ---\n  const fetchHoldings = useCallback(async userId => {\n    if (!userId) {\n      setHoldings({});\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"holdings\").select(\"*\").eq(\"user_id\", userId);\n      if (error) throw error;\n      const newHoldings = {};\n      data.forEach(holding => {\n        newHoldings[holding.symbol] = {\n          symbol: holding.symbol,\n          netQty: holding.net_qty,\n          totalCost: holding.total_cost,\n          avgBuyPrice: holding.avg_buy_price\n        };\n      });\n      setHoldings(newHoldings);\n    } catch (error) {\n      console.error(\"Error fetching holdings:\", error.message);\n      setHoldings({});\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Update holdings in Supabase ---\n  const updateHoldingInDb = useCallback(async (userId, symbol, netQty, totalCost, avgBuyPrice) => {\n    if (!userId) {\n      console.warn(\"updateHoldingInDb: No user ID, not updating DB.\");\n      return;\n    }\n    try {\n      if (netQty === 0) {\n        // If netQty is 0, delete the holding\n        const {\n          error\n        } = await supabase.from(\"holdings\").delete().eq(\"user_id\", userId).eq(\"symbol\", symbol);\n        if (error) throw error;\n      } else {\n        // Upsert the holding\n        const {\n          error\n        } = await supabase.from(\"holdings\").upsert({\n          user_id: userId,\n          symbol,\n          net_qty: netQty,\n          total_cost: totalCost,\n          avg_buy_price: avgBuyPrice\n        }, {\n          onConflict: ['user_id', 'symbol']\n        });\n        if (error) throw error;\n      }\n      // Re-fetch holdings to ensure state is in sync\n      await fetchHoldings(userId);\n    } catch (error) {\n      console.error(\"Error updating holding in DB:\", error.message);\n      throw error;\n    }\n  }, [fetchHoldings]);\n\n  // --- Fetch watchlist symbols for the current user ---\n  const fetchWatchlist = useCallback(async userId => {\n    if (!userId) {\n      setWatchListSymbols([]);\n      return;\n    }\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"watchlists\").select(\"symbol\").eq(\"user_id\", userId).order(\"created_at\", {\n        ascending: true\n      });\n      if (error) throw error;\n      setWatchListSymbols(data.map(item => item.symbol));\n    } catch (error) {\n      console.error(\"Error fetching watchlist:\", error.message);\n      setWatchListSymbols([]);\n    }\n  }, []);\n\n  // --- Add symbol to watchlist ---\n  const addToWatchlist = useCallback(async symbol => {\n    if (!(user !== null && user !== void 0 && user.id)) {\n      throw new Error(\"User not authenticated.\");\n    }\n    const normalizedSymbol = symbol.toUpperCase();\n    if (watchListSymbols.includes(normalizedSymbol)) {\n      throw new Error(`'${normalizedSymbol}' is already in your watchlist.`);\n    }\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"watchlists\").insert([{\n        user_id: user.id,\n        symbol: normalizedSymbol\n      }]).select(\"symbol\").single();\n      if (error) throw error;\n      setWatchListSymbols(prev => [...prev, data.symbol]);\n      // Trigger fetch for this new symbol specifically to get its price quickly\n      fetchLivePrices([normalizedSymbol]);\n    } catch (error) {\n      console.error(\"Error adding to watchlist:\", error.message);\n      throw error;\n    }\n  }, [user, watchListSymbols, fetchLivePrices]);\n\n  // --- Remove symbol from watchlist ---\n  const removeFromWatchlist = useCallback(async symbol => {\n    if (!(user !== null && user !== void 0 && user.id)) {\n      throw new Error(\"User not authenticated.\");\n    }\n    try {\n      const {\n        error\n      } = await supabase.from(\"watchlists\").delete().eq(\"user_id\", user.id).eq(\"symbol\", symbol.toUpperCase());\n      if (error) throw error;\n      setWatchListSymbols(prev => prev.filter(s => s !== symbol.toUpperCase()));\n      setLivePrices(prev => {\n        // Clear live price for removed symbol if not needed elsewhere\n        const newPrices = {\n          ...prev\n        };\n        delete newPrices[symbol.toUpperCase()];\n        return newPrices;\n      });\n    } catch (error) {\n      console.error(\"Error removing from watchlist:\", error.message);\n      throw error;\n    }\n  }, [user]);\n\n  // --- Fetch available US stock symbols from Finnhub (uses Finnhub) ---\n  const fetchAvailableSymbols = useCallback(async () => {\n    // --- Attempt to get from cache first ---\n    const cachedSymbols = getCachedData(`finnhub_available_symbols`, AVAILABLE_SYMBOLS_CACHE_DURATION);\n    if (cachedSymbols) {\n      setAvailableSymbols(cachedSymbols);\n      setSymbolError(\"\"); // Clear any previous error\n      return;\n    }\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      setSymbolError(\"Invalid Finnhub API Key. Cannot fetch US stock symbols.\");\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        data\n      } = await axios.get(`https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`);\n      const filteredSymbols = data.filter(s => s.type === \"Common Stock\" || s.type === \"ADR\" || s.type === \"REIT\" || s.type === \"ETP\" || s.type === \"ETF\").map(s => s.symbol).sort();\n      setAvailableSymbols(filteredSymbols);\n      setSymbolError(\"\");\n      setCachedData(`finnhub_available_symbols`, filteredSymbols); // Cache the fetched symbols\n    } catch (error) {\n      console.error(\"Error fetching available symbols:\", error);\n      if (axios.isAxiosError(error) && error.response && error.response.status === 429) {\n        setSymbolError(\"Finnhub API rate limit hit for symbol list. Please wait a bit.\");\n      } else if (error.message === 'Network Error') {\n        setSymbolError(\"Network error: Could not fetch stock symbols. Check your internet connection.\");\n      } else {\n        setSymbolError(\"Failed to fetch US stock symbols. This might be due to an invalid Finnhub API key (free tier keys have limited symbol access).\");\n      }\n      setAvailableSymbols([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, [FINNHUB_API_KEY, isInvalidApiKey]);\n\n  // --- Calculate PnL and Holdings (now uses `holdings` state directly) ---\n  const calculatePnL = useCallback(() => {\n    let totalRealizedPnl = 0;\n    let currentHoldingsCalculated = {};\n    Object.values(holdings).forEach(holding => {\n      let unrealizedPnl = 0;\n      // Ensure livePrice is a number before calculation\n      const livePrice = typeof livePrices[holding.symbol] === 'number' ? livePrices[holding.symbol] : 0;\n      const avgBuyPrice = typeof holding.avgBuyPrice === 'number' ? holding.avgBuyPrice : 0;\n      if (holding.netQty > 0 && livePrice !== 0) {\n        // Check if livePrice is available and not zero\n        unrealizedPnl = (livePrice - avgBuyPrice) * holding.netQty;\n      }\n      currentHoldingsCalculated[holding.symbol] = {\n        ...holding,\n        unrealizedPnl: parseFloat(unrealizedPnl || 0).toFixed(2) // Ensure it's a number, default to 0\n      };\n    });\n    const totalUnrealizedPnl = Object.values(currentHoldingsCalculated).reduce((sum, holding) => {\n      // Ensure holding.unrealizedPnl is treated as a number\n      return sum + parseFloat(holding.unrealizedPnl || 0);\n    }, 0);\n    let realizedPnlFromTrades = 0;\n    const tempHoldingsForRealizedPnl = {};\n    // Process trades in chronological order to correctly calculate realized PnL\n    trades.slice().sort((a, b) => new Date(a.created_at) - new Date(b.created_at)).forEach(trade => {\n      if (!tempHoldingsForRealizedPnl[trade.symbol]) {\n        tempHoldingsForRealizedPnl[trade.symbol] = {\n          netQty: 0,\n          totalCost: 0,\n          avgBuyPrice: 0\n        };\n      }\n      const tradePrice = typeof trade.price === 'number' ? trade.price : 0;\n      const tradeQuantity = typeof trade.quantity === 'number' ? trade.quantity : 0;\n      if (trade.type === \"buy\") {\n        tempHoldingsForRealizedPnl[trade.symbol].totalCost += tradeQuantity * tradePrice;\n        tempHoldingsForRealizedPnl[trade.symbol].netQty += tradeQuantity;\n        tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice = tempHoldingsForRealizedPnl[trade.symbol].netQty > 0 ? tempHoldingsForRealizedPnl[trade.symbol].totalCost / tempHoldingsForRealizedPnl[trade.symbol].netQty : 0;\n      } else {\n        // sell\n        const qtySold = tradeQuantity;\n        const currentNetQty = tempHoldingsForRealizedPnl[trade.symbol].netQty;\n        const currentAvgBuyPrice = tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice;\n        if (currentNetQty > 0) {\n          const sellCostBasis = currentAvgBuyPrice * Math.min(qtySold, currentNetQty);\n          const sellProceeds = tradePrice * qtySold;\n          realizedPnlFromTrades += sellProceeds - sellCostBasis;\n        }\n        tempHoldingsForRealizedPnl[trade.symbol].netQty -= qtySold;\n        if (tempHoldingsForRealizedPnl[trade.symbol].netQty <= 0) {\n          tempHoldingsForRealizedPnl[trade.symbol].totalCost = 0;\n          tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice = 0;\n          tempHoldingsForRealizedPnl[trade.symbol].netQty = 0;\n        } else {\n          tempHoldingsForRealizedPnl[trade.symbol].totalCost = tempHoldingsForRealizedPnl[trade.symbol].netQty * tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice;\n        }\n      }\n    });\n    return {\n      holdings: Object.values(currentHoldingsCalculated),\n      totalRealizedPnl: parseFloat(realizedPnlFromTrades || 0).toFixed(2),\n      // Ensure it's a number\n      totalUnrealizedPnl: parseFloat(totalUnrealizedPnl || 0).toFixed(2) // Ensure it's a number\n    };\n  }, [holdings, livePrices, trades]);\n\n  // --- Calculate total portfolio value ---\n  const calculateTotalPortfolioValue = useCallback(() => {\n    const {\n      holdings: calculatedHoldings\n    } = calculatePnL(); // Use the holdings from calculatePnL\n    let holdingsValue = 0;\n    Object.values(calculatedHoldings).forEach(holding => {\n      // Ensure livePrices[holding.symbol] is a number before calculation\n      const livePrice = typeof livePrices[holding.symbol] === 'number' ? livePrices[holding.symbol] : 0;\n      if (holding.netQty > 0 && livePrice !== 0) {\n        // Check if livePrice is available and not zero\n        holdingsValue += holding.netQty * livePrice;\n      }\n    });\n    // Ensure capital and holdingsValue are numbers before summing and calling toFixed\n    const totalValue = parseFloat(capital || 0) + parseFloat(holdingsValue || 0);\n    return totalValue.toFixed(2);\n  }, [capital, calculatePnL, livePrices]);\n\n  // --- Add trade logic (modified to update holdings as well) ---\n  const addTrade = useCallback(async newTrade => {\n    if (!(user !== null && user !== void 0 && user.id)) throw new Error(\"User not authenticated.\");\n    const normalizedSymbol = newTrade.symbol.toUpperCase();\n    const tradePrice = typeof newTrade.price === 'number' ? newTrade.price : 0;\n    const tradeQuantity = typeof newTrade.quantity === 'number' ? newTrade.quantity : 0;\n    const tradeCost = tradeQuantity * tradePrice;\n    let newCapital = typeof capital === 'number' ? capital : 10000; // Ensure capital is a number\n    let currentHolding = holdings[normalizedSymbol] || {\n      netQty: 0,\n      totalCost: 0,\n      avgBuyPrice: 0\n    };\n    let newNetQty = typeof currentHolding.netQty === 'number' ? currentHolding.netQty : 0;\n    let newTotalCost = typeof currentHolding.totalCost === 'number' ? currentHolding.totalCost : 0;\n    let newAvgBuyPrice = typeof currentHolding.avgBuyPrice === 'number' ? currentHolding.avgBuyPrice : 0;\n    if (newTrade.type === \"buy\") {\n      newCapital -= tradeCost;\n      newNetQty += tradeQuantity;\n      newTotalCost += tradeCost;\n      newAvgBuyPrice = newNetQty > 0 ? newTotalCost / newNetQty : 0;\n    } else {\n      // sell\n      newCapital += tradeCost;\n      const qtySold = tradeQuantity;\n      if (newNetQty < qtySold) {\n        // Use newNetQty for the check\n        throw new Error(\"Insufficient shares to sell.\");\n      }\n      newNetQty -= qtySold;\n      if (newNetQty <= 0) {\n        newTotalCost = 0;\n        newAvgBuyPrice = 0;\n        newNetQty = 0; // Ensure netQty doesn't go negative\n      } else {\n        // For partial sell, adjust totalCost for remaining shares\n        newTotalCost = newNetQty * currentHolding.avgBuyPrice; // The average buy price remains the same\n      }\n    }\n    try {\n      // 1. Insert the trade\n      const {\n        data: insertedTrade,\n        error: tradeError\n      } = await supabase.from(\"trades\").insert([{\n        user_id: user.id,\n        symbol: normalizedSymbol,\n        type: newTrade.type,\n        quantity: tradeQuantity,\n        // Use validated quantity\n        price: tradePrice,\n        // Use validated price\n        created_at: new Date().toISOString()\n      }]).select().single();\n      if (tradeError) throw tradeError;\n\n      // 2. Update capital\n      await handleSetCapital(newCapital);\n\n      // 3. Update holdings\n      await updateHoldingInDb(user.id, normalizedSymbol, newNetQty, newTotalCost, newAvgBuyPrice);\n\n      // Refresh trades and holdings from DB to ensure state is consistent\n      await fetchTrades(user.id);\n      await fetchHoldings(user.id);\n    } catch (error) {\n      console.error(\"Error adding trade:\", error.message);\n      throw error;\n    }\n  }, [user, capital, holdings, handleSetCapital, updateHoldingInDb, fetchTrades, fetchHoldings]);\n\n  // --- Remove trade logic (modified to correctly recalculate capital and holdings) ---\n  const removeTrade = useCallback(async tradeToRemove => {\n    if (!(user !== null && user !== void 0 && user.id)) throw new Error(\"User not authenticated.\");\n    try {\n      const {\n        error: deleteError\n      } = await supabase.from(\"trades\").delete().eq(\"id\", tradeToRemove.id).eq(\"user_id\", user.id);\n      if (deleteError) throw deleteError;\n\n      // After deleting a trade, we need to recalculate capital and holdings from scratch\n      // to ensure accuracy. This is a common pattern for financial transaction systems.\n\n      // 1. Fetch all remaining trades for the user\n      const {\n        data: remainingTrades,\n        error: fetchTradesError\n      } = await supabase.from(\"trades\").select(\"*\").eq(\"user_id\", user.id).order(\"created_at\", {\n        ascending: true\n      }); // Crucial: process in chronological order\n\n      if (fetchTradesError) throw fetchTradesError;\n\n      // 2. Recalculate capital and holdings\n      let recalculatedCapital = 10000; // Start with initial capital\n      let recalculatedHoldings = {};\n      remainingTrades.forEach(trade => {\n        const symbol = trade.symbol;\n        // Ensure quantity and price are numbers\n        const quantity = typeof trade.quantity === 'number' ? trade.quantity : 0;\n        const price = typeof trade.price === 'number' ? trade.price : 0;\n        if (!recalculatedHoldings[symbol]) {\n          recalculatedHoldings[symbol] = {\n            netQty: 0,\n            totalCost: 0,\n            avgBuyPrice: 0\n          };\n        }\n        if (trade.type === 'buy') {\n          recalculatedCapital -= quantity * price;\n          recalculatedHoldings[symbol].totalCost += quantity * price;\n          recalculatedHoldings[symbol].netQty += quantity;\n          recalculatedHoldings[symbol].avgBuyPrice = recalculatedHoldings[symbol].netQty > 0 ? recalculatedHoldings[symbol].totalCost / recalculatedHoldings[symbol].netQty : 0;\n        } else {\n          // sell\n          recalculatedCapital += quantity * price;\n          const currentNetQty = recalculatedHoldings[symbol].netQty;\n          const currentAvgBuyPrice = recalculatedHoldings[symbol].avgBuyPrice;\n\n          // Only adjust holdings if selling existing shares\n          if (currentNetQty > 0) {\n            const qtyToSellFromHolding = Math.min(quantity, currentNetQty);\n            recalculatedHoldings[symbol].netQty -= qtyToSellFromHolding;\n            if (recalculatedHoldings[symbol].netQty <= 0) {\n              recalculatedHoldings[symbol].totalCost = 0;\n              recalculatedHoldings[symbol].avgBuyPrice = 0;\n              recalculatedHoldings[symbol].netQty = 0; // Ensure it's not negative\n            } else {\n              // If partial sell, totalCost adjusts proportionally\n              recalculatedHoldings[symbol].totalCost = recalculatedHoldings[symbol].netQty * currentAvgBuyPrice;\n            }\n          }\n        }\n      });\n\n      // 3. Update capital in DB and state\n      await handleSetCapital(recalculatedCapital);\n\n      // 4. Update all holdings in DB based on recalculation\n      // First, delete all existing holdings for the user\n      const {\n        error: deleteHoldingsError\n      } = await supabase.from(\"holdings\").delete().eq(\"user_id\", user.id);\n      if (deleteHoldingsError) throw deleteHoldingsError;\n\n      // Then, insert the recalculated holdings\n      const holdingsToInsert = Object.values(recalculatedHoldings).filter(h => h.netQty > 0) // Only insert holdings with positive quantity\n      .map(h => ({\n        user_id: user.id,\n        symbol: h.symbol,\n        net_qty: h.netQty,\n        total_cost: h.totalCost,\n        avg_buy_price: h.avgBuyPrice\n      }));\n      if (holdingsToInsert.length > 0) {\n        const {\n          error: insertHoldingsError\n        } = await supabase.from(\"holdings\").insert(holdingsToInsert);\n        if (insertHoldingsError) throw insertHoldingsError;\n      }\n\n      // Finally, re-fetch all state to ensure consistency\n      await fetchTrades(user.id);\n      await fetchHoldings(user.id);\n    } catch (error) {\n      console.error(\"Error removing trade:\", error.message);\n      throw error;\n    }\n  }, [user, handleSetCapital, fetchTrades, fetchHoldings]);\n\n  // --- Initial Data Load on Mount or User Change ---\n  useEffect(() => {\n    const {\n      data: authListener\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      setSession(session);\n      const currentUser = (session === null || session === void 0 ? void 0 : session.user) || null;\n      setUser(currentUser);\n      if (currentUser) {\n        setLoadingData(true);\n        await fetchCapital(currentUser.id);\n        await fetchTrades(currentUser.id);\n        await fetchHoldings(currentUser.id); // Fetch holdings on user change\n        await fetchWatchlist(currentUser.id);\n        setLoadingData(false);\n      } else {\n        setCapital(10000); // Reset to initial capital for logged-out state\n        setTrades([]);\n        setHoldings({}); // Clear holdings on logout\n        setWatchListSymbols([]);\n        setLivePrices({});\n        setUser(null);\n        setLoadingData(false);\n      }\n    });\n\n    // Initial check for session on component mount\n    const checkSession = async () => {\n      setLoadingData(true);\n      const {\n        data: {\n          session\n        }\n      } = await supabase.auth.getSession();\n      setSession(session);\n      const currentUser = (session === null || session === void 0 ? void 0 : session.user) || null;\n      setUser(currentUser);\n      if (currentUser) {\n        await fetchCapital(currentUser.id);\n        await fetchTrades(currentUser.id);\n        await fetchHoldings(currentUser.id); // Initial fetch of holdings\n        await fetchWatchlist(currentUser.id);\n      }\n      setLoadingData(false);\n    };\n    checkSession();\n    fetchAvailableSymbols(); // Fetch symbols once on load for everyone\n\n    return () => {\n      authListener.subscription.unsubscribe();\n      $;\n    };\n  }, [fetchCapital, fetchTrades, fetchHoldings, fetchAvailableSymbols, fetchWatchlist]); // Dependencies for initial data load\n\n  // --- Effect to fetch live prices for all relevant symbols ---\n  useEffect(() => {\n    // Combine symbols from trades, watchlist, and holdings\n    const allSymbols = [...new Set([...trades.map(t => t.symbol), ...watchListSymbols, ...Object.keys(holdings) // Include symbols from holdings\n    ])].filter(Boolean); // Filter out any null/undefined/empty symbols\n\n    if (allSymbols.length > 0) {\n      // Fetch immediately (this call will use caching and queueing internally)\n      fetchLivePrices(allSymbols);\n\n      // Set up interval for periodic refresh\n      const interval = setInterval(() => {\n        fetchLivePrices(allSymbols); // Subsequent calls will primarily hit cache or queue\n      }, LIVE_PRICE_CACHE_DURATION); // Use the same duration as cache to ensure refresh when stale\n\n      return () => clearInterval(interval); // Cleanup on unmount or dependency change\n    }\n  }, [trades, watchListSymbols, holdings, fetchLivePrices]); // Re-run if trades, watchlist, or holdings change\n\n  // Memoize the context value to prevent unnecessary re-renders\n  const contextValue = useMemo(() => ({\n    user,\n    trades,\n    capital,\n    setCapital: handleSetCapital,\n    // Use the wrapped function\n    livePrices,\n    availableSymbols,\n    symbolError,\n    setSymbolError,\n    fetchTrades,\n    fetchLivePrices,\n    calculatePnL,\n    calculateTotalPortfolioValue,\n    loadingData,\n    removeTrade,\n    addTrade,\n    // Expose addTrade function\n    watchListSymbols,\n    addToWatchlist,\n    removeFromWatchlist,\n    holdings: Object.values(holdings) // Provide holdings as an array for easier consumption\n  }), [user, trades, capital, handleSetCapital, livePrices, availableSymbols, symbolError, setSymbolError, fetchTrades, fetchLivePrices, calculatePnL, calculateTotalPortfolioValue, loadingData, removeTrade, addTrade, addToWatchlist, removeFromWatchlist, watchListSymbols, holdings]);\n  return /*#__PURE__*/_jsxDEV(TradingDataContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 836,\n    columnNumber: 5\n  }, this);\n};\n_s(TradingDataProvider, \"7i5JBbTFxmrV91UmotJwzfDvKyc=\");\n_c = TradingDataProvider;\nexport const useTradingData = () => {\n  _s2();\n  const context = useContext(TradingDataContext);\n  if (context === undefined) {\n    throw new Error(\"useTradingData must be used within a TradingDataProvider\");\n  }\n  return context;\n};\n_s2(useTradingData, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"TradingDataProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useCallback","useMemo","useRef","supabase","axios","jsxDEV","_jsxDEV","FINNHUB_API_KEY","ALPHA_VANTAGE_API_KEY","CURRENCY_SYMBOL","isInvalidApiKey","key","trimmedKey","trim","length","getCachedData","durationMs","cachedItem","localStorage","getItem","data","timestamp","JSON","parse","Date","now","e","console","error","removeItem","setCachedData","setItem","stringify","LIVE_PRICE_CACHE_DURATION","AVAILABLE_SYMBOLS_CACHE_DURATION","API_CALL_DELAY","TradingDataContext","TradingDataProvider","children","_s","user","setUser","trades","setTrades","capital","setCapital","livePrices","setLivePrices","availableSymbols","setAvailableSymbols","symbolError","setSymbolError","loadingData","setLoadingData","session","setSession","watchListSymbols","setWatchListSymbols","holdings","setHoldings","apiCallQueue","isProcessingQueue","processApiCallQueue","current","symbol","resolve","reject","type","shift","price","res","get","c","prev","isAxiosError","response","status","warn","Promise","setTimeout","addApiCallToQueue","push","fetchLivePrices","symbolsToFetch","uniqueSymbols","Set","filter","s","newPrices","symbolsToQueueForApi","updated","forEach","sym","cachedPrice","log","fetchCapital","userId","from","select","eq","single","code","newProfile","insertError","insert","user_id","message","updateCapitalInDb","newCapital","update","handleSetCapital","id","fetchTrades","order","ascending","fetchHoldings","newHoldings","holding","netQty","net_qty","totalCost","total_cost","avgBuyPrice","avg_buy_price","updateHoldingInDb","delete","upsert","onConflict","fetchWatchlist","map","item","addToWatchlist","Error","normalizedSymbol","toUpperCase","includes","removeFromWatchlist","fetchAvailableSymbols","cachedSymbols","filteredSymbols","sort","calculatePnL","totalRealizedPnl","currentHoldingsCalculated","Object","values","unrealizedPnl","livePrice","parseFloat","toFixed","totalUnrealizedPnl","reduce","sum","realizedPnlFromTrades","tempHoldingsForRealizedPnl","slice","a","b","created_at","trade","tradePrice","tradeQuantity","quantity","qtySold","currentNetQty","currentAvgBuyPrice","sellCostBasis","Math","min","sellProceeds","calculateTotalPortfolioValue","calculatedHoldings","holdingsValue","totalValue","addTrade","newTrade","tradeCost","currentHolding","newNetQty","newTotalCost","newAvgBuyPrice","insertedTrade","tradeError","toISOString","removeTrade","tradeToRemove","deleteError","remainingTrades","fetchTradesError","recalculatedCapital","recalculatedHoldings","qtyToSellFromHolding","deleteHoldingsError","holdingsToInsert","h","insertHoldingsError","authListener","auth","onAuthStateChange","event","currentUser","checkSession","getSession","subscription","unsubscribe","$","allSymbols","t","keys","Boolean","interval","setInterval","clearInterval","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useTradingData","_s2","context","undefined","$RefreshReg$"],"sources":["/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js"],"sourcesContent":["// src/TradingDataContext.js\nimport React, { createContext, useContext, useState, useEffect, useCallback, useMemo, useRef } from \"react\";\nimport { supabase } from \"./supabaseClient\";\nimport axios from \"axios\";\n\n// Constants for API Key and Currency Symbol\n// WARNING: Hardcoding API keys directly in source code is not recommended for security.\n// Consider using environment variables (.env file) for production deployment.\n// For now, I'm keeping your original hardcoded keys as per your request.\nexport const FINNHUB_API_KEY = \"d108911r01qhkqr8ggb0d108911r01qhkqr8ggbg\"; // YOUR FINNHUB API KEY\nexport const ALPHA_VANTAGE_API_KEY = \"DR0O9MY1P0QU6ZEL\"; // YOUR ALPHA VANTAGE API KEY HERE\nexport const CURRENCY_SYMBOL = \"$\"; // Your currency symbol\n\n// Helper to check if API key is valid (simple check)\nexport const isInvalidApiKey = (key) => {\n  const trimmedKey = key ? key.trim() : '';\n  // Check for empty string, Finnhub placeholder, or Alpha Vantage placeholder\n  return !trimmedKey || trimmedKey === \"YOUR_FINNHUB_API_KEY_HERE\" || trimmedKey === \"YOUR_ALPHA_VANTAGE_API_KEY\" || trimmedKey.length < 10;\n};\n\n// --- Caching Helpers (can be moved to utils/cache.js if desired later) ---\nconst getCachedData = (key, durationMs) => {\n    try {\n        const cachedItem = localStorage.getItem(key);\n        if (cachedItem) {\n            const { data, timestamp } = JSON.parse(cachedItem);\n            if (Date.now() - timestamp < durationMs) {\n                return data;\n            }\n        }\n    } catch (e) {\n        console.error(`[Cache Error] Failed to retrieve or parse cached data for ${key}:`, e);\n        localStorage.removeItem(key); // Clear corrupted cache entry\n    }\n    return null;\n};\n\nconst setCachedData = (key, data) => {\n    try {\n        localStorage.setItem(key, JSON.stringify({ data, timestamp: Date.now() }));\n    } catch (e) {\n        console.error(`[Cache Error] Failed to set cached data for ${key}:`, e);\n    }\n};\n\n// --- Cache Durations (Adjust these values based on API limits and data freshness needs) ---\n// Finnhub free tier: 60 calls/min. Alpha Vantage free tier: 5 calls/min, 25 calls/day.\nconst LIVE_PRICE_CACHE_DURATION = 15 * 1000; // 15 seconds for live prices to stay within Finnhub limits\nconst AVAILABLE_SYMBOLS_CACHE_DURATION = 7 * 24 * 60 * 60 * 1000; // 7 days for available symbols\nconst API_CALL_DELAY = 200; // Milliseconds delay between consecutive API calls in a batch (e.g., for live prices)\n\nconst TradingDataContext = createContext();\n\nexport const TradingDataProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [trades, setTrades] = useState([]);\n  const [capital, setCapital] = useState(10000); // Initial capital\n  const [livePrices, setLivePrices] = useState({});\n  const [availableSymbols, setAvailableSymbols] = useState([]);\n  const [symbolError, setSymbolError] = useState(\"\");\n  const [loadingData, setLoadingData] = useState(true);\n  const [session, setSession] = useState(null); // Supabase session\n  const [watchListSymbols, setWatchListSymbols] = useState([]);\n  const [holdings, setHoldings] = useState({}); // New state for holdings\n\n  // --- API Call Queueing/Throttling using useRef ---\n  const apiCallQueue = useRef([]);\n  const isProcessingQueue = useRef(false);\n\n  const processApiCallQueue = useCallback(async () => {\n    if (isProcessingQueue.current || apiCallQueue.current.length === 0) {\n      return;\n    }\n\n    isProcessingQueue.current = true;\n    while (apiCallQueue.current.length > 0) {\n      const { symbol, resolve, reject, type } = apiCallQueue.current.shift(); // Get oldest task\n\n      try {\n        let price = null;\n        if (type === 'quote') {\n            const res = await axios.get(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`);\n            price = res.data && res.data.c !== 0 ? res.data.c : null;\n        }\n        \n        // Update local cache and state immediately after successful fetch\n        if (price !== null) {\n            setCachedData(`finnhub_quote_${symbol}`, price); // Cache the price directly\n            setLivePrices(prev => ({ ...prev, [symbol]: price }));\n        } else {\n            setLivePrices(prev => ({ ...prev, [symbol]: null })); // Mark as unavailable\n        }\n        resolve(price);\n      } catch (error) {\n        console.error(`Error fetching ${type} for ${symbol}:`, error);\n        if (axios.isAxiosError(error) && error.response && error.response.status === 429) {\n            console.warn(`Rate limit hit for ${symbol}. Consider increasing API_CALL_DELAY.`);\n            // Potentially re-add to queue with exponential backoff or set specific error state\n        }\n        setLivePrices(prev => ({ ...prev, [symbol]: null })); // Mark as unavailable on error\n        reject(error);\n      }\n      await new Promise(res => setTimeout(res, API_CALL_DELAY)); // Wait before next call\n    }\n    isProcessingQueue.current = false;\n  }, [FINNHUB_API_KEY]); // Dependency for API key\n\n  const addApiCallToQueue = useCallback((symbol, type = 'quote') => {\n    return new Promise((resolve, reject) => {\n      apiCallQueue.current.push({ symbol, resolve, reject, type });\n      if (!isProcessingQueue.current) {\n        processApiCallQueue();\n      }\n    });\n  }, [processApiCallQueue]);\n\n  // --- Fetch live prices for a given list of symbols (uses Finnhub) ---\n  const fetchLivePrices = useCallback(async (symbolsToFetch) => {\n    const uniqueSymbols = [...new Set(symbolsToFetch)].filter(s => s && typeof s === 'string');\n    const newPrices = {};\n    const symbolsToQueueForApi = [];\n\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n        setLivePrices((prev) => {\n            const updated = {};\n            uniqueSymbols.forEach(sym => { updated[sym] = prev[sym] || null; }); // Keep existing or set null\n            return { ...prev, ...updated };\n        });\n        console.warn(\"Invalid Finnhub API Key. Cannot fetch live prices.\");\n        return;\n    }\n\n    for (const symbol of uniqueSymbols) {\n        const cachedPrice = getCachedData(`finnhub_quote_${symbol}`, LIVE_PRICE_CACHE_DURATION);\n        if (cachedPrice !== null) {\n            newPrices[symbol] = cachedPrice;\n        } else {\n            symbolsToQueueForApi.push(symbol);\n        }\n    }\n\n    // Update with immediately available cached prices\n    setLivePrices(prev => ({ ...prev, ...newPrices }));\n\n    // Now, queue only the uncached symbols with delay/throttling\n    if (symbolsToQueueForApi.length > 0) {\n        console.log(`[Finnhub] Queuing ${symbolsToQueueForApi.length} uncached live prices for fetch...`);\n        // Add each uncached symbol to the queue\n        symbolsToQueueForApi.forEach(symbol => {\n            addApiCallToQueue(symbol, 'quote');\n        });\n    }\n  }, [addApiCallToQueue, FINNHUB_API_KEY, isInvalidApiKey]);\n\n\n  // --- Helper to fetch user's capital from Supabase ---\n  const fetchCapital = useCallback(async (userId) => {\n    if (!userId) {\n      setCapital(10000);\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { data, error } = await supabase\n        .from(\"user_profiles\")\n        .select(\"capital\")\n        .eq(\"user_id\", userId)\n        .single();\n\n      if (error && error.code !== 'PGRST116') { // PGRST116 means \"no row found\"\n        throw error;\n      }\n\n      if (data) {\n        setCapital(data.capital);\n      } else {\n        // If no profile exists, create one with initial capital\n        const { data: newProfile, error: insertError } = await supabase\n          .from(\"user_profiles\")\n          .insert([{ user_id: userId, capital: 10000 }])\n          .select(\"capital\")\n          .single();\n\n        if (insertError) throw insertError;\n        setCapital(newProfile.capital);\n      }\n    } catch (error) {\n      console.error(\"Error fetching or setting capital:\", error.message);\n      setCapital(10000); // Default to initial capital on error\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Function to update capital in Supabase ---\n  const updateCapitalInDb = useCallback(async (newCapital, userId) => {\n    if (!userId) {\n      console.warn(\"updateCapitalInDb: No user ID, not updating DB.\");\n      return;\n    }\n    setLoadingData(true); // Can be optimized, maybe a separate loading state for capital\n    try {\n      const { error } = await supabase\n        .from(\"user_profiles\")\n        .update({ capital: newCapital })\n        .eq(\"user_id\", userId);\n\n      if (error) throw error;\n      setCapital(newCapital); // Update local state after successful DB update\n    } catch (error) {\n      console.error(\"Error updating capital in DB:\", error.message);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Wrapped setCapital to update DB as well ---\n  const handleSetCapital = useCallback(async (newCapital) => {\n    setCapital(newCapital); // Optimistically update local state\n    if (user?.id) {\n      await updateCapitalInDb(newCapital, user.id);\n    } else {\n      console.warn(\"No user ID available for DB capital update.\");\n    }\n  }, [user, updateCapitalInDb]);\n\n  // --- Fetch trades for the current user ---\n  const fetchTrades = useCallback(async (userId) => {\n    if (!userId) {\n      setTrades([]);\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { data, error } = await supabase\n        .from(\"trades\")\n        .select(\"*\")\n        .eq(\"user_id\", userId)\n        .order(\"created_at\", { ascending: false });\n\n      if (error) throw error;\n      setTrades(data);\n    } catch (error) {\n      console.error(\"Error fetching trades:\", error.message);\n      setTrades([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Fetch holdings for the current user ---\n  const fetchHoldings = useCallback(async (userId) => {\n    if (!userId) {\n      setHoldings({});\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { data, error } = await supabase\n        .from(\"holdings\")\n        .select(\"*\")\n        .eq(\"user_id\", userId);\n\n      if (error) throw error;\n\n      const newHoldings = {};\n      data.forEach(holding => {\n        newHoldings[holding.symbol] = {\n          symbol: holding.symbol,\n          netQty: holding.net_qty,\n          totalCost: holding.total_cost,\n          avgBuyPrice: holding.avg_buy_price,\n        };\n      });\n      setHoldings(newHoldings);\n    } catch (error) {\n      console.error(\"Error fetching holdings:\", error.message);\n      setHoldings({});\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Update holdings in Supabase ---\n  const updateHoldingInDb = useCallback(async (userId, symbol, netQty, totalCost, avgBuyPrice) => {\n    if (!userId) {\n      console.warn(\"updateHoldingInDb: No user ID, not updating DB.\");\n      return;\n    }\n\n    try {\n      if (netQty === 0) {\n        // If netQty is 0, delete the holding\n        const { error } = await supabase\n          .from(\"holdings\")\n          .delete()\n          .eq(\"user_id\", userId)\n          .eq(\"symbol\", symbol);\n        if (error) throw error;\n      } else {\n        // Upsert the holding\n        const { error } = await supabase\n          .from(\"holdings\")\n          .upsert(\n            { user_id: userId, symbol, net_qty: netQty, total_cost: totalCost, avg_buy_price: avgBuyPrice },\n            { onConflict: ['user_id', 'symbol'] }\n          );\n        if (error) throw error;\n      }\n      // Re-fetch holdings to ensure state is in sync\n      await fetchHoldings(userId);\n    } catch (error) {\n      console.error(\"Error updating holding in DB:\", error.message);\n      throw error;\n    }\n  }, [fetchHoldings]);\n\n  // --- Fetch watchlist symbols for the current user ---\n  const fetchWatchlist = useCallback(async (userId) => {\n    if (!userId) {\n      setWatchListSymbols([]);\n      return;\n    }\n    try {\n      const { data, error } = await supabase\n        .from(\"watchlists\")\n        .select(\"symbol\")\n        .eq(\"user_id\", userId)\n        .order(\"created_at\", { ascending: true });\n\n      if (error) throw error;\n      setWatchListSymbols(data.map(item => item.symbol));\n    } catch (error) {\n      console.error(\"Error fetching watchlist:\", error.message);\n      setWatchListSymbols([]);\n    }\n  }, []);\n\n  // --- Add symbol to watchlist ---\n  const addToWatchlist = useCallback(async (symbol) => {\n    if (!user?.id) {\n      throw new Error(\"User not authenticated.\");\n    }\n    const normalizedSymbol = symbol.toUpperCase();\n    if (watchListSymbols.includes(normalizedSymbol)) {\n      throw new Error(`'${normalizedSymbol}' is already in your watchlist.`);\n    }\n\n    try {\n      const { data, error } = await supabase\n        .from(\"watchlists\")\n        .insert([{ user_id: user.id, symbol: normalizedSymbol }])\n        .select(\"symbol\")\n        .single();\n\n      if (error) throw error;\n      setWatchListSymbols((prev) => [...prev, data.symbol]);\n      // Trigger fetch for this new symbol specifically to get its price quickly\n      fetchLivePrices([normalizedSymbol]);\n    } catch (error) {\n      console.error(\"Error adding to watchlist:\", error.message);\n      throw error;\n    }\n  }, [user, watchListSymbols, fetchLivePrices]);\n\n  // --- Remove symbol from watchlist ---\n  const removeFromWatchlist = useCallback(async (symbol) => {\n    if (!user?.id) {\n      throw new Error(\"User not authenticated.\");\n    }\n    try {\n      const { error } = await supabase\n        .from(\"watchlists\")\n        .delete()\n        .eq(\"user_id\", user.id)\n        .eq(\"symbol\", symbol.toUpperCase());\n\n      if (error) throw error;\n      setWatchListSymbols((prev) => prev.filter((s) => s !== symbol.toUpperCase()));\n      setLivePrices((prev) => { // Clear live price for removed symbol if not needed elsewhere\n        const newPrices = { ...prev };\n        delete newPrices[symbol.toUpperCase()];\n        return newPrices;\n      });\n    } catch (error) {\n      console.error(\"Error removing from watchlist:\", error.message);\n      throw error;\n    }\n  }, [user]);\n\n  // --- Fetch available US stock symbols from Finnhub (uses Finnhub) ---\n  const fetchAvailableSymbols = useCallback(async () => {\n    // --- Attempt to get from cache first ---\n    const cachedSymbols = getCachedData(`finnhub_available_symbols`, AVAILABLE_SYMBOLS_CACHE_DURATION);\n    if (cachedSymbols) {\n        setAvailableSymbols(cachedSymbols);\n        setSymbolError(\"\"); // Clear any previous error\n        return;\n    }\n\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      setSymbolError(\"Invalid Finnhub API Key. Cannot fetch US stock symbols.\");\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { data } = await axios.get(\n        `https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`\n      );\n      const filteredSymbols = data\n        .filter(\n          (s) =>\n            s.type === \"Common Stock\" ||\n            s.type === \"ADR\" ||\n            s.type === \"REIT\" ||\n            s.type === \"ETP\" ||\n            s.type === \"ETF\"\n        )\n        .map((s) => s.symbol)\n        .sort();\n\n      setAvailableSymbols(filteredSymbols);\n      setSymbolError(\"\");\n      setCachedData(`finnhub_available_symbols`, filteredSymbols); // Cache the fetched symbols\n    } catch (error) {\n      console.error(\"Error fetching available symbols:\", error);\n      if (axios.isAxiosError(error) && error.response && error.response.status === 429) {\n          setSymbolError(\"Finnhub API rate limit hit for symbol list. Please wait a bit.\");\n      } else if (error.message === 'Network Error') {\n          setSymbolError(\"Network error: Could not fetch stock symbols. Check your internet connection.\");\n      } else {\n          setSymbolError(\n              \"Failed to fetch US stock symbols. This might be due to an invalid Finnhub API key (free tier keys have limited symbol access).\"\n          );\n      }\n      setAvailableSymbols([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, [FINNHUB_API_KEY, isInvalidApiKey]);\n\n  // --- Calculate PnL and Holdings (now uses `holdings` state directly) ---\n  const calculatePnL = useCallback(() => {\n    let totalRealizedPnl = 0;\n\n    let currentHoldingsCalculated = {};\n    Object.values(holdings).forEach((holding) => {\n        let unrealizedPnl = 0;\n        // Ensure livePrice is a number before calculation\n        const livePrice = typeof livePrices[holding.symbol] === 'number' ? livePrices[holding.symbol] : 0;\n        const avgBuyPrice = typeof holding.avgBuyPrice === 'number' ? holding.avgBuyPrice : 0;\n\n        if (holding.netQty > 0 && livePrice !== 0) { // Check if livePrice is available and not zero\n            unrealizedPnl = (livePrice - avgBuyPrice) * holding.netQty;\n        }\n        currentHoldingsCalculated[holding.symbol] = {\n            ...holding,\n            unrealizedPnl: parseFloat(unrealizedPnl || 0).toFixed(2), // Ensure it's a number, default to 0\n        };\n    });\n\n    const totalUnrealizedPnl = Object.values(currentHoldingsCalculated).reduce((sum, holding) => {\n        // Ensure holding.unrealizedPnl is treated as a number\n        return sum + parseFloat(holding.unrealizedPnl || 0);\n    }, 0);\n\n    let realizedPnlFromTrades = 0;\n    const tempHoldingsForRealizedPnl = {}; \n    // Process trades in chronological order to correctly calculate realized PnL\n    trades.slice().sort((a, b) => new Date(a.created_at) - new Date(b.created_at)).forEach((trade) => {\n        if (!tempHoldingsForRealizedPnl[trade.symbol]) {\n            tempHoldingsForRealizedPnl[trade.symbol] = { netQty: 0, totalCost: 0, avgBuyPrice: 0 };\n        }\n\n        const tradePrice = typeof trade.price === 'number' ? trade.price : 0;\n        const tradeQuantity = typeof trade.quantity === 'number' ? trade.quantity : 0;\n\n        if (trade.type === \"buy\") {\n            tempHoldingsForRealizedPnl[trade.symbol].totalCost += tradeQuantity * tradePrice;\n            tempHoldingsForRealizedPnl[trade.symbol].netQty += tradeQuantity; \n            tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice =\n                tempHoldingsForRealizedPnl[trade.symbol].netQty > 0\n                    ? tempHoldingsForRealizedPnl[trade.symbol].totalCost / tempHoldingsForRealizedPnl[trade.symbol].netQty\n                    : 0;\n        } else { // sell\n            const qtySold = tradeQuantity;\n            const currentNetQty = tempHoldingsForRealizedPnl[trade.symbol].netQty;\n            const currentAvgBuyPrice = tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice;\n\n            if (currentNetQty > 0) {\n                const sellCostBasis = (currentAvgBuyPrice * Math.min(qtySold, currentNetQty));\n                const sellProceeds = tradePrice * qtySold;\n                realizedPnlFromTrades += (sellProceeds - sellCostBasis);\n            }\n\n            tempHoldingsForRealizedPnl[trade.symbol].netQty -= qtySold;\n            if (tempHoldingsForRealizedPnl[trade.symbol].netQty <= 0) {\n                tempHoldingsForRealizedPnl[trade.symbol].totalCost = 0;\n                tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice = 0;\n                tempHoldingsForRealizedPnl[trade.symbol].netQty = 0;\n            } else {\n                tempHoldingsForRealizedPnl[trade.symbol].totalCost = tempHoldingsForRealizedPnl[trade.symbol].netQty * tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice;\n            }\n        }\n    });\n\n\n    return {\n      holdings: Object.values(currentHoldingsCalculated),\n      totalRealizedPnl: parseFloat(realizedPnlFromTrades || 0).toFixed(2), // Ensure it's a number\n      totalUnrealizedPnl: parseFloat(totalUnrealizedPnl || 0).toFixed(2), // Ensure it's a number\n    };\n  }, [holdings, livePrices, trades]);\n\n  // --- Calculate total portfolio value ---\n  const calculateTotalPortfolioValue = useCallback(() => {\n    const { holdings: calculatedHoldings } = calculatePnL(); // Use the holdings from calculatePnL\n    let holdingsValue = 0;\n    Object.values(calculatedHoldings).forEach(holding => {\n      // Ensure livePrices[holding.symbol] is a number before calculation\n      const livePrice = typeof livePrices[holding.symbol] === 'number' ? livePrices[holding.symbol] : 0;\n      if (holding.netQty > 0 && livePrice !== 0) { // Check if livePrice is available and not zero\n        holdingsValue += holding.netQty * livePrice;\n      }\n    });\n    // Ensure capital and holdingsValue are numbers before summing and calling toFixed\n    const totalValue = parseFloat(capital || 0) + parseFloat(holdingsValue || 0);\n    return totalValue.toFixed(2);\n  }, [capital, calculatePnL, livePrices]);\n\n  // --- Add trade logic (modified to update holdings as well) ---\n  const addTrade = useCallback(async (newTrade) => {\n    if (!user?.id) throw new Error(\"User not authenticated.\");\n\n    const normalizedSymbol = newTrade.symbol.toUpperCase();\n    const tradePrice = typeof newTrade.price === 'number' ? newTrade.price : 0;\n    const tradeQuantity = typeof newTrade.quantity === 'number' ? newTrade.quantity : 0;\n    const tradeCost = tradeQuantity * tradePrice;\n\n    let newCapital = typeof capital === 'number' ? capital : 10000; // Ensure capital is a number\n    let currentHolding = holdings[normalizedSymbol] || { netQty: 0, totalCost: 0, avgBuyPrice: 0 };\n    let newNetQty = typeof currentHolding.netQty === 'number' ? currentHolding.netQty : 0;\n    let newTotalCost = typeof currentHolding.totalCost === 'number' ? currentHolding.totalCost : 0;\n    let newAvgBuyPrice = typeof currentHolding.avgBuyPrice === 'number' ? currentHolding.avgBuyPrice : 0;\n\n    if (newTrade.type === \"buy\") {\n      newCapital -= tradeCost;\n      newNetQty += tradeQuantity;\n      newTotalCost += tradeCost;\n      newAvgBuyPrice = newNetQty > 0 ? newTotalCost / newNetQty : 0;\n    } else { // sell\n      newCapital += tradeCost;\n      const qtySold = tradeQuantity;\n\n      if (newNetQty < qtySold) { // Use newNetQty for the check\n          throw new Error(\"Insufficient shares to sell.\");\n      }\n\n      newNetQty -= qtySold;\n      if (newNetQty <= 0) {\n        newTotalCost = 0;\n        newAvgBuyPrice = 0;\n        newNetQty = 0; // Ensure netQty doesn't go negative\n      } else {\n        // For partial sell, adjust totalCost for remaining shares\n        newTotalCost = newNetQty * currentHolding.avgBuyPrice; // The average buy price remains the same\n      }\n    }\n\n    try {\n      // 1. Insert the trade\n      const { data: insertedTrade, error: tradeError } = await supabase\n        .from(\"trades\")\n        .insert([{\n          user_id: user.id,\n          symbol: normalizedSymbol,\n          type: newTrade.type,\n          quantity: tradeQuantity, // Use validated quantity\n          price: tradePrice, // Use validated price\n          created_at: new Date().toISOString(),\n        }])\n        .select()\n        .single();\n\n      if (tradeError) throw tradeError;\n\n      // 2. Update capital\n      await handleSetCapital(newCapital);\n\n      // 3. Update holdings\n      await updateHoldingInDb(user.id, normalizedSymbol, newNetQty, newTotalCost, newAvgBuyPrice);\n\n      // Refresh trades and holdings from DB to ensure state is consistent\n      await fetchTrades(user.id);\n      await fetchHoldings(user.id);\n\n    } catch (error) {\n      console.error(\"Error adding trade:\", error.message);\n      throw error;\n    }\n  }, [user, capital, holdings, handleSetCapital, updateHoldingInDb, fetchTrades, fetchHoldings]);\n\n  // --- Remove trade logic (modified to correctly recalculate capital and holdings) ---\n  const removeTrade = useCallback(async (tradeToRemove) => {\n    if (!user?.id) throw new Error(\"User not authenticated.\");\n\n    try {\n      const { error: deleteError } = await supabase\n        .from(\"trades\")\n        .delete()\n        .eq(\"id\", tradeToRemove.id)\n        .eq(\"user_id\", user.id);\n\n      if (deleteError) throw deleteError;\n\n      // After deleting a trade, we need to recalculate capital and holdings from scratch\n      // to ensure accuracy. This is a common pattern for financial transaction systems.\n\n      // 1. Fetch all remaining trades for the user\n      const { data: remainingTrades, error: fetchTradesError } = await supabase\n        .from(\"trades\")\n        .select(\"*\")\n        .eq(\"user_id\", user.id)\n        .order(\"created_at\", { ascending: true }); // Crucial: process in chronological order\n\n      if (fetchTradesError) throw fetchTradesError;\n\n      // 2. Recalculate capital and holdings\n      let recalculatedCapital = 10000; // Start with initial capital\n      let recalculatedHoldings = {};\n\n      remainingTrades.forEach(trade => {\n        const symbol = trade.symbol;\n        // Ensure quantity and price are numbers\n        const quantity = typeof trade.quantity === 'number' ? trade.quantity : 0;\n        const price = typeof trade.price === 'number' ? trade.price : 0;\n\n        if (!recalculatedHoldings[symbol]) {\n          recalculatedHoldings[symbol] = { netQty: 0, totalCost: 0, avgBuyPrice: 0 };\n        }\n\n        if (trade.type === 'buy') {\n          recalculatedCapital -= (quantity * price);\n          recalculatedHoldings[symbol].totalCost += (quantity * price);\n          recalculatedHoldings[symbol].netQty += quantity;\n          recalculatedHoldings[symbol].avgBuyPrice = recalculatedHoldings[symbol].netQty > 0\n            ? recalculatedHoldings[symbol].totalCost / recalculatedHoldings[symbol].netQty\n            : 0;\n        } else { // sell\n          recalculatedCapital += (quantity * price);\n          \n          const currentNetQty = recalculatedHoldings[symbol].netQty;\n          const currentAvgBuyPrice = recalculatedHoldings[symbol].avgBuyPrice;\n\n          // Only adjust holdings if selling existing shares\n          if (currentNetQty > 0) {\n              const qtyToSellFromHolding = Math.min(quantity, currentNetQty);\n              recalculatedHoldings[symbol].netQty -= qtyToSellFromHolding;\n              \n              if (recalculatedHoldings[symbol].netQty <= 0) {\n                  recalculatedHoldings[symbol].totalCost = 0;\n                  recalculatedHoldings[symbol].avgBuyPrice = 0;\n                  recalculatedHoldings[symbol].netQty = 0; // Ensure it's not negative\n              } else {\n                  // If partial sell, totalCost adjusts proportionally\n                  recalculatedHoldings[symbol].totalCost = recalculatedHoldings[symbol].netQty * currentAvgBuyPrice;\n              }\n          }\n        }\n      });\n\n      // 3. Update capital in DB and state\n      await handleSetCapital(recalculatedCapital);\n\n      // 4. Update all holdings in DB based on recalculation\n      // First, delete all existing holdings for the user\n      const { error: deleteHoldingsError } = await supabase\n        .from(\"holdings\")\n        .delete()\n        .eq(\"user_id\", user.id);\n      if (deleteHoldingsError) throw deleteHoldingsError;\n\n      // Then, insert the recalculated holdings\n      const holdingsToInsert = Object.values(recalculatedHoldings)\n        .filter(h => h.netQty > 0) // Only insert holdings with positive quantity\n        .map(h => ({\n          user_id: user.id,\n          symbol: h.symbol,\n          net_qty: h.netQty,\n          total_cost: h.totalCost,\n          avg_buy_price: h.avgBuyPrice,\n        }));\n\n      if (holdingsToInsert.length > 0) {\n        const { error: insertHoldingsError } = await supabase\n          .from(\"holdings\")\n          .insert(holdingsToInsert);\n        if (insertHoldingsError) throw insertHoldingsError;\n      }\n      \n      // Finally, re-fetch all state to ensure consistency\n      await fetchTrades(user.id);\n      await fetchHoldings(user.id);\n\n    } catch (error) {\n      console.error(\"Error removing trade:\", error.message);\n      throw error;\n    }\n  }, [user, handleSetCapital, fetchTrades, fetchHoldings]);\n\n\n  // --- Initial Data Load on Mount or User Change ---\n  useEffect(() => {\n    const { data: authListener } = supabase.auth.onAuthStateChange(\n      async (event, session) => {\n        setSession(session);\n        const currentUser = session?.user || null;\n        setUser(currentUser);\n\n        if (currentUser) {\n          setLoadingData(true);\n          await fetchCapital(currentUser.id);\n          await fetchTrades(currentUser.id);\n          await fetchHoldings(currentUser.id); // Fetch holdings on user change\n          await fetchWatchlist(currentUser.id);\n          setLoadingData(false);\n        } else {\n          setCapital(10000); // Reset to initial capital for logged-out state\n          setTrades([]);\n          setHoldings({}); // Clear holdings on logout\n          setWatchListSymbols([]);\n          setLivePrices({});\n          setUser(null);\n          setLoadingData(false);\n        }\n      }\n    );\n\n    // Initial check for session on component mount\n    const checkSession = async () => {\n      setLoadingData(true);\n      const { data: { session } } = await supabase.auth.getSession();\n      setSession(session);\n      const currentUser = session?.user || null;\n      setUser(currentUser);\n\n      if (currentUser) {\n        await fetchCapital(currentUser.id);\n        await fetchTrades(currentUser.id);\n        await fetchHoldings(currentUser.id); // Initial fetch of holdings\n        await fetchWatchlist(currentUser.id);\n      }\n      setLoadingData(false);\n    };\n\n    checkSession();\n    fetchAvailableSymbols(); // Fetch symbols once on load for everyone\n\n    return () => {\n      authListener.subscription.unsubscribe();\n    $;\n    };\n  }, [fetchCapital, fetchTrades, fetchHoldings, fetchAvailableSymbols, fetchWatchlist]); // Dependencies for initial data load\n\n  // --- Effect to fetch live prices for all relevant symbols ---\n  useEffect(() => {\n    // Combine symbols from trades, watchlist, and holdings\n    const allSymbols = [\n      ...new Set([\n        ...trades.map((t) => t.symbol),\n        ...watchListSymbols,\n        ...Object.keys(holdings), // Include symbols from holdings\n      ])\n    ].filter(Boolean); // Filter out any null/undefined/empty symbols\n\n    if (allSymbols.length > 0) {\n      // Fetch immediately (this call will use caching and queueing internally)\n      fetchLivePrices(allSymbols);\n\n      // Set up interval for periodic refresh\n      const interval = setInterval(() => {\n        fetchLivePrices(allSymbols); // Subsequent calls will primarily hit cache or queue\n      }, LIVE_PRICE_CACHE_DURATION); // Use the same duration as cache to ensure refresh when stale\n\n      return () => clearInterval(interval); // Cleanup on unmount or dependency change\n    }\n  }, [trades, watchListSymbols, holdings, fetchLivePrices]); // Re-run if trades, watchlist, or holdings change\n\n  // Memoize the context value to prevent unnecessary re-renders\n  const contextValue = useMemo(\n    () => ({\n      user,\n      trades,\n      capital,\n      setCapital: handleSetCapital, // Use the wrapped function\n      livePrices,\n      availableSymbols,\n      symbolError,\n      setSymbolError,\n      fetchTrades,\n      fetchLivePrices,\n      calculatePnL,\n      calculateTotalPortfolioValue,\n      loadingData,\n      removeTrade,\n      addTrade, // Expose addTrade function\n      watchListSymbols,\n      addToWatchlist,\n      removeFromWatchlist,\n      holdings: Object.values(holdings), // Provide holdings as an array for easier consumption\n    }),\n    [\n      user,\n      trades,\n      capital,\n      handleSetCapital,\n      livePrices,\n      availableSymbols,\n      symbolError,\n      setSymbolError,\n      fetchTrades,\n      fetchLivePrices,\n      calculatePnL,\n      calculateTotalPortfolioValue,\n      loadingData,\n      removeTrade,\n      addTrade,\n      addToWatchlist,\n      removeFromWatchlist,\n      watchListSymbols,\n      holdings,\n    ]\n  );\n\n  return (\n    <TradingDataContext.Provider value={contextValue}>\n      {children}\n    </TradingDataContext.Provider>\n  );\n};\n\nexport const useTradingData = () => {\n  const context = useContext(TradingDataContext);\n  if (context === undefined) {\n    throw new Error(\"useTradingData must be used within a TradingDataProvider\");\n  }\n  return context;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}