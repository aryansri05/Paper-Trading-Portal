{"ast":null,"code":"var _jsxFileName = \"/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// src/TradingDataContext.js\nimport React, { createContext, useContext, useState, useEffect, useCallback, useMemo, useRef } from \"react\";\nimport { supabase } from \"./supabaseClient\";\nimport axios from \"axios\";\n\n// Constants for API Key and Currency Symbol\n// WARNING: Hardcoding API keys directly in source code is not recommended for security.\n// Consider using environment variables (.env file) for production deployment.\n\n// IMPORTANT: Use environment variables for production!\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const FINNHUB_API_KEY = process.env.REACT_APP_FINNHUB_API_KEY || \"YOUR_FINNHUB_API_KEY_HERE\";\nexport const ALPHA_VANTAGE_API_KEY = process.env.REACT_APP_ALPHA_VANTAGE_API_KEY || \"YOUR_ALPHA_VANTAGE_API_KEY\";\nexport const CURRENCY_SYMBOL = process.env.REACT_APP_CURRENCY_SYMBOL || \"$\";\n\n// Helper to check if API key is valid (simple check)\nexport const isInvalidApiKey = key => {\n  const trimmedKey = key ? key.trim() : '';\n  // Check for empty string, Finnhub placeholder, or Alpha Vantage placeholder, or short length\n  return !trimmedKey || trimmedKey === \"YOUR_FINNHUB_API_KEY_HERE\" || trimmedKey === \"YOUR_ALPHA_VANTAGE_API_KEY\" || trimmedKey.length < 10;\n};\n\n// --- In-memory cache for live prices ---\n// This cache lives outside the component to persist across re-renders\n// and function calls, preventing redundant API calls within a short window.\nconst livePriceCache = new Map();\nconst LIVE_PRICE_CACHE_DURATION = 15 * 1000; // Cache prices for 15 seconds\n\n// --- API Call Queue for Throttling Finnhub Requests ---\n// This helps prevent hitting rate limits when many symbols need fetching.\nconst apiCallQueue = [];\nlet isProcessingQueue = false;\nconst API_CALL_DELAY = 100; // Delay between each API call in the queue (ms)\n\nconst processApiCallQueue = async () => {\n  if (isProcessingQueue) return;\n  isProcessingQueue = true;\n  while (apiCallQueue.length > 0) {\n    const {\n      symbol,\n      resolve,\n      reject\n    } = apiCallQueue.shift();\n    const cachedPrice = livePriceCache.get(symbol);\n    if (cachedPrice && Date.now() < cachedPrice.timestamp + LIVE_PRICE_CACHE_DURATION) {\n      // Serve from cache if available and not expired\n      resolve(cachedPrice.price);\n    } else {\n      try {\n        const response = await axios.get(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`);\n        const price = response.data.c !== 0 ? response.data.c : null;\n        livePriceCache.set(symbol, {\n          price,\n          timestamp: Date.now()\n        });\n        resolve(price);\n      } catch (error) {\n        console.error(`Error fetching live price for ${symbol}:`, error);\n        livePriceCache.set(symbol, {\n          price: null,\n          timestamp: Date.now()\n        }); // Cache null on error\n        reject(error);\n      }\n    }\n    // Implement a delay to respect API rate limits\n    if (apiCallQueue.length > 0) {\n      await new Promise(resolve => setTimeout(resolve, API_CALL_DELAY));\n    }\n  }\n  isProcessingQueue = false;\n};\nconst TradingDataContext = /*#__PURE__*/createContext();\nexport const TradingDataProvider = ({\n  children\n}) => {\n  _s();\n  const [user, setUser] = useState(null);\n  const [trades, setTrades] = useState([]);\n  const [capital, setCapital] = useState(10000); // Initial capital\n  // livePrices state will now only store the most recent valid prices\n  const [livePrices, setLivePrices] = useState({});\n  const [availableSymbols, setAvailableSymbols] = useState([]);\n  const [symbolError, setSymbolError] = useState(\"\");\n  const [loadingData, setLoadingData] = useState(true);\n  const [session, setSession] = useState(null); // Supabase session\n  const [watchListSymbols, setWatchListSymbols] = useState([]);\n  const [holdings, setHoldings] = useState({}); // New state for holdings\n\n  // Ref to store the interval ID for live price fetching\n  const priceFetchIntervalRef = useRef(null);\n\n  // --- Fetch live prices for a given list of symbols (uses Finnhub and throttling) ---\n  const fetchLivePrices = useCallback(async symbolsToFetch => {\n    const uniqueSymbols = [...new Set(symbolsToFetch)].filter(s => s && typeof s === 'string');\n    if (uniqueSymbols.length === 0 || isInvalidApiKey(FINNHUB_API_KEY)) {\n      if (isInvalidApiKey(FINNHUB_API_KEY)) {\n        console.warn(\"Finnhub API Key is invalid. Cannot fetch live prices.\");\n        // Stop any ongoing price fetching intervals if API key becomes invalid\n        if (priceFetchIntervalRef.current) {\n          clearInterval(priceFetchIntervalRef.current);\n          priceFetchIntervalRef.current = null;\n        }\n      }\n      // Keep existing prices or set them to null if specific symbols are no longer valid.\n      setLivePrices(prev => {\n        const newPrices = {};\n        // If uniqueSymbols is empty, we don't want to clear all prices, just return prev\n        if (uniqueSymbols.length === 0) return prev;\n        uniqueSymbols.forEach(sym => {\n          // If symbol was previously fetched, retain its price; otherwise, mark as null/undefined.\n          newPrices[sym] = prev[sym] || null;\n        });\n        return newPrices;\n      });\n      return;\n    }\n    const pricePromises = uniqueSymbols.map(symbol => {\n      return new Promise((resolve, reject) => {\n        apiCallQueue.push({\n          symbol,\n          resolve,\n          reject\n        });\n        if (!isProcessingQueue) {\n          processApiCallQueue(); // Start processing if not already\n        }\n      }).then(price => {\n        // Return object structure that setLivePrices can handle\n        return {\n          symbol,\n          price\n        };\n      }).catch(error => {\n        // Catch and handle errors for individual symbols, return null price\n        return {\n          symbol,\n          price: null\n        };\n      });\n    });\n    try {\n      const results = await Promise.all(pricePromises);\n      const newPrices = {};\n      results.forEach(item => {\n        if (item.symbol) {\n          // Ensure symbol is not null/undefined\n          newPrices[item.symbol] = item.price;\n        }\n      });\n      setLivePrices(prev => ({\n        ...prev,\n        ...newPrices\n      }));\n    } catch (error) {\n      // This catch block would only be hit if Promise.all rejects,\n      // but we're resolving/rejecting individual promises, so it's less likely.\n      console.error(\"Error during batch price fetch:\", error);\n    }\n  }, []); // Dependencies: None, as FINNHUB_API_KEY is constant and apiCallQueue is managed outside\n\n  // --- Helper to fetch user's capital from Supabase ---\n  const fetchCapital = useCallback(async userId => {\n    if (!userId) {\n      setCapital(10000); // Default to initial capital if no user\n      return;\n    }\n    // setLoadingData(true); // Handled by the initial useEffect for all data\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"user_profiles\").select(\"capital\").eq(\"user_id\", userId).single();\n      if (error && error.code !== 'PGRST116') {\n        // PGRST116 means \"no row found\"\n        throw error;\n      }\n      if (data) {\n        setCapital(data.capital);\n      } else {\n        // If no profile exists, create one with initial capital\n        const {\n          data: newProfile,\n          error: insertError\n        } = await supabase.from(\"user_profiles\").insert([{\n          user_id: userId,\n          capital: 10000\n        }]).select(\"capital\").single();\n        if (insertError) throw insertError;\n        setCapital(newProfile.capital);\n      }\n    } catch (error) {\n      console.error(\"Error fetching or setting capital:\", error.message);\n      setCapital(10000); // Default to initial capital on error\n    } finally {\n      // setLoadingData(false); // Handled by the initial useEffect for all data\n    }\n  }, []);\n\n  // --- Function to update capital in Supabase ---\n  const updateCapitalInDb = useCallback(async (newCapital, userId) => {\n    if (!userId) {\n      console.warn(\"updateCapitalInDb: No user ID, not updating DB.\");\n      return;\n    }\n    // setLoadingData(true); // No need to set loading for every individual DB update\n    try {\n      const {\n        error\n      } = await supabase.from(\"user_profiles\").update({\n        capital: newCapital\n      }).eq(\"user_id\", userId);\n      if (error) throw error;\n      setCapital(newCapital); // Update local state after successful DB update\n    } catch (error) {\n      console.error(\"Error updating capital in DB:\", error.message);\n      // Optionally revert local state if DB update fails or show error to user\n    } finally {\n      // setLoadingData(false);\n    }\n  }, []);\n\n  // --- Wrapped setCapital to update DB as well ---\n  const handleSetCapital = useCallback(async newCapital => {\n    setCapital(newCapital); // Optimistically update local state immediately\n    if (user !== null && user !== void 0 && user.id) {\n      await updateCapitalInDb(newCapital, user.id);\n    } else {\n      console.warn(\"No user ID available for DB capital update.\");\n    }\n  }, [user, updateCapitalInDb]);\n\n  // --- Fetch trades for the current user ---\n  const fetchTrades = useCallback(async userId => {\n    if (!userId) {\n      setTrades([]);\n      return;\n    }\n    // setLoadingData(true); // Handled by the initial useEffect for all data\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"trades\").select(\"*\").eq(\"user_id\", userId).order(\"created_at\", {\n        ascending: false\n      });\n      if (error) throw error;\n      setTrades(data);\n    } catch (error) {\n      console.error(\"Error fetching trades:\", error.message);\n      setTrades([]);\n    } finally {\n      // setLoadingData(false); // Handled by the initial useEffect for all data\n    }\n  }, []);\n\n  // --- Fetch holdings for the current user ---\n  const fetchHoldings = useCallback(async userId => {\n    if (!userId) {\n      setHoldings({});\n      return;\n    }\n    // setLoadingData(true); // Handled by the initial useEffect for all data\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"holdings\").select(\"*\").eq(\"user_id\", userId);\n      if (error) throw error;\n      const newHoldings = {};\n      data.forEach(holding => {\n        newHoldings[holding.symbol] = {\n          symbol: holding.symbol,\n          netQty: holding.net_qty,\n          totalCost: holding.total_cost,\n          avgBuyPrice: holding.avg_buy_price\n        };\n      });\n      setHoldings(newHoldings);\n    } catch (error) {\n      console.error(\"Error fetching holdings:\", error.message);\n      setHoldings({});\n    } finally {\n      // setLoadingData(false); // Handled by the initial useEffect for all data\n    }\n  }, []);\n\n  // --- Update holdings in Supabase ---\n  const updateHoldingInDb = useCallback(async (userId, symbol, netQty, totalCost, avgBuyPrice) => {\n    if (!userId) {\n      console.warn(\"updateHoldingInDb: No user ID, not updating DB.\");\n      return;\n    }\n    try {\n      if (netQty === 0) {\n        // If netQty is 0, delete the holding\n        const {\n          error\n        } = await supabase.from(\"holdings\").delete().eq(\"user_id\", userId).eq(\"symbol\", symbol);\n        if (error) throw error;\n      } else {\n        // Upsert the holding\n        const {\n          error\n        } = await supabase.from(\"holdings\").upsert({\n          user_id: userId,\n          symbol,\n          net_qty: netQty,\n          total_cost: totalCost,\n          avg_buy_price: avgBuyPrice\n        }, {\n          onConflict: ['user_id', 'symbol']\n        });\n        if (error) throw error;\n      }\n      // Re-fetch holdings to ensure state is in sync. This can be made more optimistic\n      // but for financial data, a re-fetch ensures consistency.\n      await fetchHoldings(userId);\n    } catch (error) {\n      console.error(\"Error updating holding in DB:\", error.message);\n      throw error; // Re-throw to be caught by calling function (e.g., addTrade)\n    }\n  }, [fetchHoldings]);\n\n  // --- Fetch watchlist symbols for the current user ---\n  const fetchWatchlist = useCallback(async userId => {\n    if (!userId) {\n      setWatchListSymbols([]);\n      return;\n    }\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"watchlists\").select(\"symbol\").eq(\"user_id\", userId).order(\"created_at\", {\n        ascending: true\n      });\n      if (error) throw error;\n      setWatchListSymbols(data.map(item => item.symbol));\n    } catch (error) {\n      console.error(\"Error fetching watchlist:\", error.message);\n      setWatchListSymbols([]);\n    }\n  }, []);\n\n  // --- Add symbol to watchlist ---\n  const addToWatchlist = useCallback(async symbol => {\n    if (!(user !== null && user !== void 0 && user.id)) {\n      throw new Error(\"User not authenticated.\");\n    }\n    const normalizedSymbol = symbol.toUpperCase();\n    if (watchListSymbols.includes(normalizedSymbol)) {\n      throw new Error(`'${normalizedSymbol}' is already in your watchlist.`);\n    }\n\n    // Optimistic UI update for watchlist\n    setWatchListSymbols(prev => [...prev, normalizedSymbol]);\n    // Immediately trigger price fetch for the newly added symbol\n    fetchLivePrices([normalizedSymbol]);\n    try {\n      const {\n        error\n      } = await supabase.from(\"watchlists\").insert([{\n        user_id: user.id,\n        symbol: normalizedSymbol\n      }]);\n      if (error) throw error;\n\n      // No need to setWatchListSymbols again as we did it optimistically\n    } catch (error) {\n      console.error(\"Error adding to watchlist:\", error.message);\n      // Revert optimistic update on error\n      setWatchListSymbols(prev => prev.filter(s => s !== normalizedSymbol));\n      throw error;\n    }\n  }, [user, watchListSymbols, fetchLivePrices]);\n\n  // --- Remove symbol from watchlist ---\n  const removeFromWatchlist = useCallback(async symbol => {\n    if (!(user !== null && user !== void 0 && user.id)) {\n      throw new Error(\"User not authenticated.\");\n    }\n    const normalizedSymbol = symbol.toUpperCase();\n\n    // Optimistic UI update for watchlist\n    setWatchListSymbols(prev => prev.filter(s => s !== normalizedSymbol));\n    setLivePrices(prev => {\n      // Clear live price for removed symbol if not needed elsewhere\n      const newPrices = {\n        ...prev\n      };\n      delete newPrices[normalizedSymbol];\n      return newPrices;\n    });\n    try {\n      const {\n        error\n      } = await supabase.from(\"watchlists\").delete().eq(\"user_id\", user.id).eq(\"symbol\", normalizedSymbol);\n      if (error) throw error;\n\n      // No need to setWatchListSymbols or setLivePrices again as we did it optimistically\n    } catch (error) {\n      console.error(\"Error removing from watchlist:\", error.message);\n      // Revert optimistic update on error (requires re-fetching old watchlist)\n      await fetchWatchlist(user.id);\n      throw error;\n    }\n  }, [user, fetchWatchlist]); // fetchWatchlist added for error recovery\n\n  // --- Fetch available US stock symbols from Finnhub (uses Finnhub) ---\n  const fetchAvailableSymbols = useCallback(async () => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      setSymbolError(\"Invalid Finnhub API Key. Cannot fetch US stock symbols.\");\n      setAvailableSymbols([]);\n      return;\n    }\n    // setLoadingData(true); // Not part of core initial load, can have its own loading state if needed\n    try {\n      const {\n        data\n      } = await axios.get(`https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`);\n      const filteredSymbols = data.filter(s => s.type === \"Common Stock\" || s.type === \"ADR\" || s.type === \"REIT\" || s.type === \"ETP\" || s.type === \"ETF\").map(s => s.symbol).sort();\n      setAvailableSymbols(filteredSymbols);\n      setSymbolError(\"\");\n    } catch (error) {\n      console.error(\"Error fetching available symbols:\", error);\n      setSymbolError(\"Failed to fetch US stock symbols. This might be due to API rate limits or an invalid Finnhub API key (free tier keys have limited symbol access).\");\n      setAvailableSymbols([]);\n    } finally {\n      // setLoadingData(false);\n    }\n  }, []);\n\n  // --- Calculate PnL and Holdings (now uses `holdings` state directly) ---\n  const calculatePnL = useCallback(() => {\n    let totalRealizedPnl = 0;\n    let currentHoldingsCalculated = {};\n    Object.values(holdings).forEach(holding => {\n      let unrealizedPnl = 0;\n      // Ensure livePrices[holding.symbol] is a number before calculation\n      const currentPrice = typeof livePrices[holding.symbol] === 'number' ? livePrices[holding.symbol] : 0;\n      if (holding.netQty > 0 && currentPrice !== 0) {\n        unrealizedPnl = (currentPrice - holding.avgBuyPrice) * holding.netQty;\n      }\n      currentHoldingsCalculated[holding.symbol] = {\n        ...holding,\n        // Ensure unrealizedPnl is a number before toFixed\n        unrealizedPnl: (typeof unrealizedPnl === 'number' ? unrealizedPnl : 0).toFixed(2)\n      };\n    });\n    const totalUnrealizedPnl = Object.values(currentHoldingsCalculated).reduce((sum, holding) => {\n      // Ensure parseFloat input is valid, fallback to 0\n      return sum + parseFloat(holding.unrealizedPnl || 0);\n    }, 0);\n\n    // Recalculate realized PnL from trades (as trade history defines realized PnL)\n    let realizedPnlFromTrades = 0;\n    const tempHoldingsForRealizedPnl = {};\n    trades.slice().reverse().forEach(trade => {\n      // Process oldest to newest for accurate PnL\n      if (!tempHoldingsForRealizedPnl[trade.symbol]) {\n        tempHoldingsForRealizedPnl[trade.symbol] = {\n          netQty: 0,\n          totalCost: 0,\n          avgBuyPrice: 0\n        };\n      }\n      if (trade.type === \"buy\") {\n        tempHoldingsForRealizedPnl[trade.symbol].totalCost += trade.quantity * trade.price;\n        tempHoldingsForRealizedPnl[trade.symbol].netQty += trade.quantity;\n        tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice = tempHoldingsForRealizedPnl[trade.symbol].netQty > 0 ? tempHoldingsForRealizedPnl[trade.symbol].totalCost / tempHoldingsForRealizedPnl[trade.symbol].netQty : 0;\n      } else {\n        // sell\n        const qtySold = trade.quantity;\n        const currentNetQty = tempHoldingsForRealizedPnl[trade.symbol].netQty;\n        const currentAvgBuyPrice = tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice;\n        if (currentNetQty > 0) {\n          // Ensure we don't sell more than we currently hold in temp calculation\n          const qtyToSellAgainstCostBasis = Math.min(qtySold, currentNetQty);\n          const sellCostBasis = currentAvgBuyPrice * qtyToSellAgainstCostBasis;\n          const sellProceeds = trade.price * qtyToSellAgainstCostBasis; // Only proceeds for the qty actually sold from holding\n          realizedPnlFromTrades += sellProceeds - sellCostBasis;\n        }\n\n        // Update temporary holdings for subsequent trades\n        tempHoldingsForRealizedPnl[trade.symbol].netQty -= qtySold;\n        if (tempHoldingsForRealizedPnl[trade.symbol].netQty <= 0) {\n          tempHoldingsForRealizedPnl[trade.symbol].totalCost = 0;\n          tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice = 0;\n          tempHoldingsForRealizedPnl[trade.symbol].netQty = 0;\n        } else {\n          tempHoldingsForRealizedPnl[trade.symbol].totalCost = tempHoldingsForRealizedPnl[trade.symbol].netQty * tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice;\n        }\n      }\n    });\n    return {\n      holdings: Object.values(currentHoldingsCalculated),\n      // Ensure results are numbers before toFixed, fallback to 0\n      totalRealizedPnl: (typeof realizedPnlFromTrades === 'number' ? realizedPnlFromTrades : 0).toFixed(2),\n      totalUnrealizedPnl: (typeof totalUnrealizedPnl === 'number' ? totalUnrealizedPnl : 0).toFixed(2)\n    };\n  }, [holdings, livePrices, trades]); // `trades` is a dependency here because realized PnL depends on the full trade history.\n\n  // --- Calculate total portfolio value ---\n  const calculateTotalPortfolioValue = useCallback(() => {\n    // This now implicitly depends on `calculatePnL` which internally relies on `livePrices` and `holdings`\n    const {\n      holdings: calculatedHoldings\n    } = calculatePnL();\n    let holdingsValue = 0;\n    Object.values(calculatedHoldings).forEach(holding => {\n      // Ensure livePrices[holding.symbol] is a number before calculation, fallback to 0\n      const currentPrice = typeof livePrices[holding.symbol] === 'number' ? livePrices[holding.symbol] : 0;\n      if (holding.netQty > 0 && currentPrice !== 0) {\n        holdingsValue += holding.netQty * currentPrice;\n      }\n    });\n    // Ensure result is a number before toFixed, fallback to 0\n    return (typeof (capital + holdingsValue) === 'number' ? capital + holdingsValue : 0).toFixed(2);\n  }, [capital, calculatePnL, livePrices]); // Explicitly list `livePrices` here because `calculatePnL` uses it\n\n  // --- Add trade logic (modified to update holdings as well) ---\n  const addTrade = useCallback(async newTrade => {\n    if (!(user !== null && user !== void 0 && user.id)) throw new Error(\"User not authenticated.\");\n    const normalizedSymbol = newTrade.symbol.toUpperCase();\n    const tradeCost = newTrade.quantity * newTrade.price;\n    let newCapital = capital;\n    let currentHolding = holdings[normalizedSymbol] || {\n      netQty: 0,\n      totalCost: 0,\n      avgBuyPrice: 0\n    };\n    let newNetQty = currentHolding.netQty;\n    let newTotalCost = currentHolding.totalCost;\n    let newAvgBuyPrice = currentHolding.avgBuyPrice;\n    if (newTrade.type === \"buy\") {\n      newCapital -= tradeCost;\n      newNetQty += newTrade.quantity;\n      newTotalCost += tradeCost;\n      newAvgBuyPrice = newTotalCost / newNetQty;\n    } else {\n      // sell\n      newCapital += tradeCost;\n      const qtySold = newTrade.quantity;\n      if (currentHolding.netQty < qtySold) {\n        throw new Error(\"Insufficient shares to sell.\");\n      }\n      newNetQty -= qtySold;\n      if (newNetQty <= 0) {\n        newTotalCost = 0;\n        newAvgBuyPrice = 0;\n        newNetQty = 0; // Ensure netQty doesn't go negative\n      } else {\n        // For partial sell, adjust totalCost for remaining shares\n        newTotalCost = newNetQty * currentHolding.avgBuyPrice; // The average buy price remains the same\n      }\n    }\n    try {\n      // Optimistically update local capital and holdings BEFORE DB call for snappier UI\n      setCapital(newCapital);\n      setHoldings(prevHoldings => ({\n        ...prevHoldings,\n        [normalizedSymbol]: {\n          symbol: normalizedSymbol,\n          netQty: newNetQty,\n          totalCost: newTotalCost,\n          avgBuyPrice: newAvgBuyPrice\n        }\n      }));\n\n      // 1. Insert the trade\n      const {\n        error: tradeError\n      } = await supabase.from(\"trades\").insert([{\n        user_id: user.id,\n        symbol: normalizedSymbol,\n        type: newTrade.type,\n        quantity: newTrade.quantity,\n        price: newTrade.price,\n        created_at: new Date().toISOString()\n      }]);\n      if (tradeError) throw tradeError;\n\n      // 2. Update capital in DB (handleSetCapital does this)\n      await updateCapitalInDb(newCapital, user.id); // Call directly to avoid re-setting local state\n\n      // 3. Update holdings in DB\n      await updateHoldingInDb(user.id, normalizedSymbol, newNetQty, newTotalCost, newAvgBuyPrice);\n\n      // Refresh trades from DB to ensure state is consistent (holdings are already updated by updateHoldingInDb and its fetch)\n      await fetchTrades(user.id);\n    } catch (error) {\n      console.error(\"Error adding trade:\", error.message);\n      // Revert local state on error\n      await fetchCapital(user.id);\n      await fetchTrades(user.id);\n      await fetchHoldings(user.id);\n      throw error;\n    }\n  }, [user, capital, holdings, updateCapitalInDb, updateHoldingInDb, fetchTrades, fetchCapital, fetchHoldings]);\n\n  // --- Remove trade logic (modified to correctly recalculate capital and holdings) ---\n  const removeTrade = useCallback(async tradeToRemove => {\n    if (!(user !== null && user !== void 0 && user.id)) throw new Error(\"User not authenticated.\");\n    try {\n      // Optimistically remove trade from local state for snappier UI\n      setTrades(prevTrades => prevTrades.filter(t => t.id !== tradeToRemove.id));\n      const {\n        error: deleteError\n      } = await supabase.from(\"trades\").delete().eq(\"id\", tradeToRemove.id).eq(\"user_id\", user.id);\n      if (deleteError) throw deleteError;\n\n      // After deleting a trade, we need to recalculate capital and holdings from scratch\n      // This is robust for financial systems but can be a heavy operation for many trades.\n\n      // 1. Fetch all remaining trades for the user (chronological order is critical here)\n      const {\n        data: remainingTrades,\n        error: fetchTradesError\n      } = await supabase.from(\"trades\").select(\"*\").eq(\"user_id\", user.id).order(\"created_at\", {\n        ascending: true\n      });\n      if (fetchTradesError) throw fetchTradesError;\n\n      // 2. Recalculate capital and holdings from the ground up\n      let recalculatedCapital = 10000; // Start with initial capital\n      let recalculatedHoldings = {};\n      remainingTrades.forEach(trade => {\n        const symbol = trade.symbol;\n        const quantity = trade.quantity;\n        const price = trade.price;\n        if (!recalculatedHoldings[symbol]) {\n          recalculatedHoldings[symbol] = {\n            netQty: 0,\n            totalCost: 0,\n            avgBuyPrice: 0\n          };\n        }\n        if (trade.type === 'buy') {\n          recalculatedCapital -= quantity * price;\n          recalculatedHoldings[symbol].totalCost += quantity * price;\n          recalculatedHoldings[symbol].netQty += quantity;\n          recalculatedHoldings[symbol].avgBuyPrice = recalculatedHoldings[symbol].netQty > 0 ? recalculatedHoldings[symbol].totalCost / recalculatedHoldings[symbol].netQty : 0;\n        } else {\n          // sell\n          recalculatedCapital += quantity * price;\n          const currentNetQty = recalculatedHoldings[symbol].netQty;\n          const currentAvgBuyPrice = recalculatedHoldings[symbol].avgBuyPrice;\n          if (currentNetQty > 0) {\n            const qtyToSellFromHolding = Math.min(quantity, currentNetQty);\n            recalculatedHoldings[symbol].netQty -= qtyToSellFromHolding;\n            if (recalculatedHoldings[symbol].netQty <= 0) {\n              recalculatedHoldings[symbol].totalCost = 0;\n              recalculatedHoldings[symbol].avgBuyPrice = 0;\n              recalculatedHoldings[symbol].netQty = 0;\n            } else {\n              recalculatedHoldings[symbol].totalCost = recalculatedHoldings[symbol].netQty * currentAvgBuyPrice;\n            }\n          }\n        }\n      });\n\n      // 3. Update capital in DB (handleSetCapital does this)\n      await updateCapitalInDb(recalculatedCapital, user.id); // Direct call\n\n      // 4. Update all holdings in DB based on recalculation\n      // Transactional approach: delete all then insert new ones\n      const {\n        error: deleteHoldingsError\n      } = await supabase.from(\"holdings\").delete().eq(\"user_id\", user.id);\n      if (deleteHoldingsError) throw deleteHoldingsError;\n      const holdingsToInsert = Object.values(recalculatedHoldings).filter(h => h.netQty > 0).map(h => ({\n        user_id: user.id,\n        symbol: h.symbol,\n        net_qty: h.netQty,\n        total_cost: h.totalCost,\n        avg_buy_price: h.avgBuyPrice\n      }));\n      if (holdingsToInsert.length > 0) {\n        const {\n          error: insertHoldingsError\n        } = await supabase.from(\"holdings\").insert(holdingsToInsert);\n        if (insertHoldingsError) throw insertHoldingsError;\n      }\n\n      // Re-fetch all state from DB to ensure complete consistency, especially for edge cases\n      // after a complex re-calculation.\n      await fetchTrades(user.id);\n      await fetchHoldings(user.id);\n      await fetchCapital(user.id); // Ensure capital is also fresh from DB\n    } catch (error) {\n      console.error(\"Error removing trade:\", error.message);\n      // On error, revert all local state by re-fetching everything from DB\n      await fetchCapital(user.id);\n      await fetchTrades(user.id);\n      await fetchHoldings(user.id);\n      throw error;\n    }\n  }, [user, updateCapitalInDb, fetchTrades, fetchHoldings, fetchCapital]);\n\n  // --- Initial Data Load on Mount or User Change ---\n  useEffect(() => {\n    const {\n      data: authListener\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      setSession(session);\n      const currentUser = (session === null || session === void 0 ? void 0 : session.user) || null;\n      setUser(currentUser);\n      if (currentUser) {\n        setLoadingData(true);\n        // Await all initial fetches to ensure loadingData is accurate\n        await Promise.all([fetchCapital(currentUser.id), fetchTrades(currentUser.id), fetchHoldings(currentUser.id), fetchWatchlist(currentUser.id)]);\n        setLoadingData(false);\n      } else {\n        // Reset states on logout\n        setCapital(10000);\n        setTrades([]);\n        setHoldings({});\n        setWatchListSymbols([]);\n        setLivePrices({});\n        setUser(null);\n        setLoadingData(false);\n        // Clear Finnhub API Key warning if user logs out\n        setSymbolError(\"\");\n      }\n    });\n\n    // Initial check for session on component mount\n    const checkSession = async () => {\n      setLoadingData(true);\n      const {\n        data: {\n          session\n        }\n      } = await supabase.auth.getSession();\n      setSession(session);\n      const currentUser = (session === null || session === void 0 ? void 0 : session.user) || null;\n      setUser(currentUser);\n      if (currentUser) {\n        // Await all initial fetches\n        await Promise.all([fetchCapital(currentUser.id), fetchTrades(currentUser.id), fetchHoldings(currentUser.id), fetchWatchlist(currentUser.id)]);\n      }\n      setLoadingData(false);\n    };\n    checkSession();\n    // fetchAvailableSymbols is not dependent on user, so it can run once.\n    fetchAvailableSymbols();\n    return () => {\n      authListener.subscription.unsubscribe();\n      // Clear the interval when the component unmounts\n      if (priceFetchIntervalRef.current) {\n        clearInterval(priceFetchIntervalRef.current);\n      }\n    };\n  }, [fetchCapital, fetchTrades, fetchHoldings, fetchAvailableSymbols, fetchWatchlist]); // Dependencies for initial data load\n\n  // --- Effect to set up and manage live price fetching interval ---\n  useEffect(() => {\n    // Combine symbols from trades, watchlist, and holdings\n    const allSymbols = [...new Set([...trades.map(t => t.symbol), ...watchListSymbols, ...Object.keys(holdings)])].filter(Boolean); // Filter out any null/undefined/empty symbols\n\n    // Clear any existing interval to prevent multiple intervals running\n    if (priceFetchIntervalRef.current) {\n      clearInterval(priceFetchIntervalRef.current);\n    }\n    if (allSymbols.length > 0 && !isInvalidApiKey(FINNHUB_API_KEY)) {\n      // Fetch immediately on dependency change\n      fetchLivePrices(allSymbols);\n\n      // Set up new interval for periodic refresh\n      priceFetchIntervalRef.current = setInterval(() => {\n        fetchLivePrices(allSymbols);\n      }, 20000); // Every 20 seconds\n    } else if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      // If API key is invalid, ensure symbol error is set and prices are cleared (or handled)\n      setSymbolError(\"Finnhub API Key is invalid. Live prices may not be available.\");\n      setLivePrices({}); // Clear live prices if API key is not working\n    }\n    return () => {\n      // Cleanup interval on unmount or dependency change\n      if (priceFetchIntervalRef.current) {\n        clearInterval(priceFetchIntervalRef.current);\n        priceFetchIntervalRef.current = null;\n      }\n    };\n  }, [trades, watchListSymbols, holdings, fetchLivePrices]); // Re-run if trades, watchlist, or holdings change\n\n  // Memoize the context value to prevent unnecessary re-renders\n  const contextValue = useMemo(() => ({\n    user,\n    trades,\n    capital,\n    setCapital: handleSetCapital,\n    // Use the wrapped function\n    livePrices,\n    availableSymbols,\n    symbolError,\n    setSymbolError,\n    fetchTrades,\n    fetchLivePrices,\n    calculatePnL,\n    calculateTotalPortfolioValue,\n    loadingData,\n    removeTrade,\n    addTrade,\n    // Expose addTrade function\n    watchListSymbols,\n    addToWatchlist,\n    removeFromWatchlist,\n    holdings: Object.values(holdings) // Provide holdings as an array for easier consumption\n  }), [user, trades, capital, handleSetCapital, livePrices, availableSymbols, symbolError, setSymbolError, fetchTrades,\n  // Included in useMemo because it's a stable callback used by components\n  fetchLivePrices,\n  // Included for the same reason\n  calculatePnL, calculateTotalPortfolioValue, loadingData, removeTrade, addTrade, addToWatchlist, removeFromWatchlist, watchListSymbols, holdings // Include holdings directly here, as it's passed as an object to `contextValue`\n  ]);\n  return /*#__PURE__*/_jsxDEV(TradingDataContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 865,\n    columnNumber: 5\n  }, this);\n};\n_s(TradingDataProvider, \"4ODdn3x96negvNZdGF2v9o5JGeo=\");\n_c = TradingDataProvider;\nexport const useTradingData = () => {\n  _s2();\n  const context = useContext(TradingDataContext);\n  if (context === undefined) {\n    throw new Error(\"useTradingData must be used within a TradingDataProvider\");\n  }\n  return context;\n};\n_s2(useTradingData, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"TradingDataProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useCallback","useMemo","useRef","supabase","axios","jsxDEV","_jsxDEV","FINNHUB_API_KEY","process","env","REACT_APP_FINNHUB_API_KEY","ALPHA_VANTAGE_API_KEY","REACT_APP_ALPHA_VANTAGE_API_KEY","CURRENCY_SYMBOL","REACT_APP_CURRENCY_SYMBOL","isInvalidApiKey","key","trimmedKey","trim","length","livePriceCache","Map","LIVE_PRICE_CACHE_DURATION","apiCallQueue","isProcessingQueue","API_CALL_DELAY","processApiCallQueue","symbol","resolve","reject","shift","cachedPrice","get","Date","now","timestamp","price","response","data","c","set","error","console","Promise","setTimeout","TradingDataContext","TradingDataProvider","children","_s","user","setUser","trades","setTrades","capital","setCapital","livePrices","setLivePrices","availableSymbols","setAvailableSymbols","symbolError","setSymbolError","loadingData","setLoadingData","session","setSession","watchListSymbols","setWatchListSymbols","holdings","setHoldings","priceFetchIntervalRef","fetchLivePrices","symbolsToFetch","uniqueSymbols","Set","filter","s","warn","current","clearInterval","prev","newPrices","forEach","sym","pricePromises","map","push","then","catch","results","all","item","fetchCapital","userId","from","select","eq","single","code","newProfile","insertError","insert","user_id","message","updateCapitalInDb","newCapital","update","handleSetCapital","id","fetchTrades","order","ascending","fetchHoldings","newHoldings","holding","netQty","net_qty","totalCost","total_cost","avgBuyPrice","avg_buy_price","updateHoldingInDb","delete","upsert","onConflict","fetchWatchlist","addToWatchlist","Error","normalizedSymbol","toUpperCase","includes","removeFromWatchlist","fetchAvailableSymbols","filteredSymbols","type","sort","calculatePnL","totalRealizedPnl","currentHoldingsCalculated","Object","values","unrealizedPnl","currentPrice","toFixed","totalUnrealizedPnl","reduce","sum","parseFloat","realizedPnlFromTrades","tempHoldingsForRealizedPnl","slice","reverse","trade","quantity","qtySold","currentNetQty","currentAvgBuyPrice","qtyToSellAgainstCostBasis","Math","min","sellCostBasis","sellProceeds","calculateTotalPortfolioValue","calculatedHoldings","holdingsValue","addTrade","newTrade","tradeCost","currentHolding","newNetQty","newTotalCost","newAvgBuyPrice","prevHoldings","tradeError","created_at","toISOString","removeTrade","tradeToRemove","prevTrades","t","deleteError","remainingTrades","fetchTradesError","recalculatedCapital","recalculatedHoldings","qtyToSellFromHolding","deleteHoldingsError","holdingsToInsert","h","insertHoldingsError","authListener","auth","onAuthStateChange","event","currentUser","checkSession","getSession","subscription","unsubscribe","allSymbols","keys","Boolean","setInterval","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useTradingData","_s2","context","undefined","$RefreshReg$"],"sources":["/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js"],"sourcesContent":["// src/TradingDataContext.js\nimport React, { createContext, useContext, useState, useEffect, useCallback, useMemo, useRef } from \"react\";\nimport { supabase } from \"./supabaseClient\";\nimport axios from \"axios\";\n\n// Constants for API Key and Currency Symbol\n// WARNING: Hardcoding API keys directly in source code is not recommended for security.\n// Consider using environment variables (.env file) for production deployment.\n\n// IMPORTANT: Use environment variables for production!\nexport const FINNHUB_API_KEY = process.env.REACT_APP_FINNHUB_API_KEY || \"YOUR_FINNHUB_API_KEY_HERE\";\nexport const ALPHA_VANTAGE_API_KEY = process.env.REACT_APP_ALPHA_VANTAGE_API_KEY || \"YOUR_ALPHA_VANTAGE_API_KEY\";\nexport const CURRENCY_SYMBOL = process.env.REACT_APP_CURRENCY_SYMBOL || \"$\";\n\n// Helper to check if API key is valid (simple check)\nexport const isInvalidApiKey = (key) => {\n  const trimmedKey = key ? key.trim() : '';\n  // Check for empty string, Finnhub placeholder, or Alpha Vantage placeholder, or short length\n  return !trimmedKey || trimmedKey === \"YOUR_FINNHUB_API_KEY_HERE\" || trimmedKey === \"YOUR_ALPHA_VANTAGE_API_KEY\" || trimmedKey.length < 10;\n};\n\n// --- In-memory cache for live prices ---\n// This cache lives outside the component to persist across re-renders\n// and function calls, preventing redundant API calls within a short window.\nconst livePriceCache = new Map();\nconst LIVE_PRICE_CACHE_DURATION = 15 * 1000; // Cache prices for 15 seconds\n\n// --- API Call Queue for Throttling Finnhub Requests ---\n// This helps prevent hitting rate limits when many symbols need fetching.\nconst apiCallQueue = [];\nlet isProcessingQueue = false;\nconst API_CALL_DELAY = 100; // Delay between each API call in the queue (ms)\n\nconst processApiCallQueue = async () => {\n  if (isProcessingQueue) return;\n  isProcessingQueue = true;\n\n  while (apiCallQueue.length > 0) {\n    const { symbol, resolve, reject } = apiCallQueue.shift();\n    const cachedPrice = livePriceCache.get(symbol);\n\n    if (cachedPrice && Date.now() < cachedPrice.timestamp + LIVE_PRICE_CACHE_DURATION) {\n      // Serve from cache if available and not expired\n      resolve(cachedPrice.price);\n    } else {\n      try {\n        const response = await axios.get(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`);\n        const price = response.data.c !== 0 ? response.data.c : null;\n        livePriceCache.set(symbol, { price, timestamp: Date.now() });\n        resolve(price);\n      } catch (error) {\n        console.error(`Error fetching live price for ${symbol}:`, error);\n        livePriceCache.set(symbol, { price: null, timestamp: Date.now() }); // Cache null on error\n        reject(error);\n      }\n    }\n    // Implement a delay to respect API rate limits\n    if (apiCallQueue.length > 0) {\n      await new Promise(resolve => setTimeout(resolve, API_CALL_DELAY));\n    }\n  }\n  isProcessingQueue = false;\n};\n\n\nconst TradingDataContext = createContext();\n\nexport const TradingDataProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [trades, setTrades] = useState([]);\n  const [capital, setCapital] = useState(10000); // Initial capital\n  // livePrices state will now only store the most recent valid prices\n  const [livePrices, setLivePrices] = useState({});\n  const [availableSymbols, setAvailableSymbols] = useState([]);\n  const [symbolError, setSymbolError] = useState(\"\");\n  const [loadingData, setLoadingData] = useState(true);\n  const [session, setSession] = useState(null); // Supabase session\n  const [watchListSymbols, setWatchListSymbols] = useState([]);\n  const [holdings, setHoldings] = useState({}); // New state for holdings\n\n  // Ref to store the interval ID for live price fetching\n  const priceFetchIntervalRef = useRef(null);\n\n  // --- Fetch live prices for a given list of symbols (uses Finnhub and throttling) ---\n  const fetchLivePrices = useCallback(async (symbolsToFetch) => {\n    const uniqueSymbols = [...new Set(symbolsToFetch)].filter(s => s && typeof s === 'string');\n\n    if (uniqueSymbols.length === 0 || isInvalidApiKey(FINNHUB_API_KEY)) {\n      if (isInvalidApiKey(FINNHUB_API_KEY)) {\n        console.warn(\"Finnhub API Key is invalid. Cannot fetch live prices.\");\n        // Stop any ongoing price fetching intervals if API key becomes invalid\n        if (priceFetchIntervalRef.current) {\n          clearInterval(priceFetchIntervalRef.current);\n          priceFetchIntervalRef.current = null;\n        }\n      }\n      // Keep existing prices or set them to null if specific symbols are no longer valid.\n      setLivePrices((prev) => {\n        const newPrices = {};\n        // If uniqueSymbols is empty, we don't want to clear all prices, just return prev\n        if (uniqueSymbols.length === 0) return prev;\n\n        uniqueSymbols.forEach(sym => {\n            // If symbol was previously fetched, retain its price; otherwise, mark as null/undefined.\n            newPrices[sym] = prev[sym] || null;\n        });\n        return newPrices;\n      });\n      return;\n    }\n\n    const pricePromises = uniqueSymbols.map(symbol => {\n      return new Promise((resolve, reject) => {\n        apiCallQueue.push({ symbol, resolve, reject });\n        if (!isProcessingQueue) {\n          processApiCallQueue(); // Start processing if not already\n        }\n      }).then(price => {\n        // Return object structure that setLivePrices can handle\n        return { symbol, price };\n      }).catch(error => {\n        // Catch and handle errors for individual symbols, return null price\n        return { symbol, price: null };\n      });\n    });\n\n    try {\n      const results = await Promise.all(pricePromises);\n      const newPrices = {};\n      results.forEach(item => {\n        if (item.symbol) { // Ensure symbol is not null/undefined\n          newPrices[item.symbol] = item.price;\n        }\n      });\n      setLivePrices((prev) => ({ ...prev, ...newPrices }));\n    } catch (error) {\n      // This catch block would only be hit if Promise.all rejects,\n      // but we're resolving/rejecting individual promises, so it's less likely.\n      console.error(\"Error during batch price fetch:\", error);\n    }\n  }, []); // Dependencies: None, as FINNHUB_API_KEY is constant and apiCallQueue is managed outside\n\n  // --- Helper to fetch user's capital from Supabase ---\n  const fetchCapital = useCallback(async (userId) => {\n    if (!userId) {\n      setCapital(10000); // Default to initial capital if no user\n      return;\n    }\n    // setLoadingData(true); // Handled by the initial useEffect for all data\n    try {\n      const { data, error } = await supabase\n        .from(\"user_profiles\")\n        .select(\"capital\")\n        .eq(\"user_id\", userId)\n        .single();\n\n      if (error && error.code !== 'PGRST116') { // PGRST116 means \"no row found\"\n        throw error;\n      }\n\n      if (data) {\n        setCapital(data.capital);\n      } else {\n        // If no profile exists, create one with initial capital\n        const { data: newProfile, error: insertError } = await supabase\n          .from(\"user_profiles\")\n          .insert([{ user_id: userId, capital: 10000 }])\n          .select(\"capital\")\n          .single();\n\n        if (insertError) throw insertError;\n        setCapital(newProfile.capital);\n      }\n    } catch (error) {\n      console.error(\"Error fetching or setting capital:\", error.message);\n      setCapital(10000); // Default to initial capital on error\n    } finally {\n      // setLoadingData(false); // Handled by the initial useEffect for all data\n    }\n  }, []);\n\n  // --- Function to update capital in Supabase ---\n  const updateCapitalInDb = useCallback(async (newCapital, userId) => {\n    if (!userId) {\n      console.warn(\"updateCapitalInDb: No user ID, not updating DB.\");\n      return;\n    }\n    // setLoadingData(true); // No need to set loading for every individual DB update\n    try {\n      const { error } = await supabase\n        .from(\"user_profiles\")\n        .update({ capital: newCapital })\n        .eq(\"user_id\", userId);\n\n      if (error) throw error;\n      setCapital(newCapital); // Update local state after successful DB update\n    } catch (error) {\n      console.error(\"Error updating capital in DB:\", error.message);\n      // Optionally revert local state if DB update fails or show error to user\n    } finally {\n      // setLoadingData(false);\n    }\n  }, []);\n\n  // --- Wrapped setCapital to update DB as well ---\n  const handleSetCapital = useCallback(async (newCapital) => {\n    setCapital(newCapital); // Optimistically update local state immediately\n    if (user?.id) {\n      await updateCapitalInDb(newCapital, user.id);\n    } else {\n      console.warn(\"No user ID available for DB capital update.\");\n    }\n  }, [user, updateCapitalInDb]);\n\n  // --- Fetch trades for the current user ---\n  const fetchTrades = useCallback(async (userId) => {\n    if (!userId) {\n      setTrades([]);\n      return;\n    }\n    // setLoadingData(true); // Handled by the initial useEffect for all data\n    try {\n      const { data, error } = await supabase\n        .from(\"trades\")\n        .select(\"*\")\n        .eq(\"user_id\", userId)\n        .order(\"created_at\", { ascending: false });\n\n      if (error) throw error;\n      setTrades(data);\n    } catch (error) {\n      console.error(\"Error fetching trades:\", error.message);\n      setTrades([]);\n    } finally {\n      // setLoadingData(false); // Handled by the initial useEffect for all data\n    }\n  }, []);\n\n  // --- Fetch holdings for the current user ---\n  const fetchHoldings = useCallback(async (userId) => {\n    if (!userId) {\n      setHoldings({});\n      return;\n    }\n    // setLoadingData(true); // Handled by the initial useEffect for all data\n    try {\n      const { data, error } = await supabase\n        .from(\"holdings\")\n        .select(\"*\")\n        .eq(\"user_id\", userId);\n\n      if (error) throw error;\n\n      const newHoldings = {};\n      data.forEach(holding => {\n        newHoldings[holding.symbol] = {\n          symbol: holding.symbol,\n          netQty: holding.net_qty,\n          totalCost: holding.total_cost,\n          avgBuyPrice: holding.avg_buy_price,\n        };\n      });\n      setHoldings(newHoldings);\n    } catch (error) {\n      console.error(\"Error fetching holdings:\", error.message);\n      setHoldings({});\n    } finally {\n      // setLoadingData(false); // Handled by the initial useEffect for all data\n    }\n  }, []);\n\n  // --- Update holdings in Supabase ---\n  const updateHoldingInDb = useCallback(async (userId, symbol, netQty, totalCost, avgBuyPrice) => {\n    if (!userId) {\n      console.warn(\"updateHoldingInDb: No user ID, not updating DB.\");\n      return;\n    }\n\n    try {\n      if (netQty === 0) {\n        // If netQty is 0, delete the holding\n        const { error } = await supabase\n          .from(\"holdings\")\n          .delete()\n          .eq(\"user_id\", userId)\n          .eq(\"symbol\", symbol);\n        if (error) throw error;\n      } else {\n        // Upsert the holding\n        const { error } = await supabase\n          .from(\"holdings\")\n          .upsert(\n            { user_id: userId, symbol, net_qty: netQty, total_cost: totalCost, avg_buy_price: avgBuyPrice },\n            { onConflict: ['user_id', 'symbol'] }\n          );\n        if (error) throw error;\n      }\n      // Re-fetch holdings to ensure state is in sync. This can be made more optimistic\n      // but for financial data, a re-fetch ensures consistency.\n      await fetchHoldings(userId);\n    } catch (error) {\n      console.error(\"Error updating holding in DB:\", error.message);\n      throw error; // Re-throw to be caught by calling function (e.g., addTrade)\n    }\n  }, [fetchHoldings]);\n\n  // --- Fetch watchlist symbols for the current user ---\n  const fetchWatchlist = useCallback(async (userId) => {\n    if (!userId) {\n      setWatchListSymbols([]);\n      return;\n    }\n    try {\n      const { data, error } = await supabase\n        .from(\"watchlists\")\n        .select(\"symbol\")\n        .eq(\"user_id\", userId)\n        .order(\"created_at\", { ascending: true });\n\n      if (error) throw error;\n      setWatchListSymbols(data.map(item => item.symbol));\n    } catch (error) {\n      console.error(\"Error fetching watchlist:\", error.message);\n      setWatchListSymbols([]);\n    }\n  }, []);\n\n  // --- Add symbol to watchlist ---\n  const addToWatchlist = useCallback(async (symbol) => {\n    if (!user?.id) {\n      throw new Error(\"User not authenticated.\");\n    }\n    const normalizedSymbol = symbol.toUpperCase();\n    if (watchListSymbols.includes(normalizedSymbol)) {\n      throw new Error(`'${normalizedSymbol}' is already in your watchlist.`);\n    }\n\n    // Optimistic UI update for watchlist\n    setWatchListSymbols((prev) => [...prev, normalizedSymbol]);\n    // Immediately trigger price fetch for the newly added symbol\n    fetchLivePrices([normalizedSymbol]);\n\n    try {\n      const { error } = await supabase\n        .from(\"watchlists\")\n        .insert([{ user_id: user.id, symbol: normalizedSymbol }]);\n      if (error) throw error;\n\n      // No need to setWatchListSymbols again as we did it optimistically\n    } catch (error) {\n      console.error(\"Error adding to watchlist:\", error.message);\n      // Revert optimistic update on error\n      setWatchListSymbols((prev) => prev.filter((s) => s !== normalizedSymbol));\n      throw error;\n    }\n  }, [user, watchListSymbols, fetchLivePrices]);\n\n  // --- Remove symbol from watchlist ---\n  const removeFromWatchlist = useCallback(async (symbol) => {\n    if (!user?.id) {\n      throw new Error(\"User not authenticated.\");\n    }\n    const normalizedSymbol = symbol.toUpperCase();\n\n    // Optimistic UI update for watchlist\n    setWatchListSymbols((prev) => prev.filter((s) => s !== normalizedSymbol));\n    setLivePrices((prev) => { // Clear live price for removed symbol if not needed elsewhere\n      const newPrices = { ...prev };\n      delete newPrices[normalizedSymbol];\n      return newPrices;\n    });\n\n    try {\n      const { error } = await supabase\n        .from(\"watchlists\")\n        .delete()\n        .eq(\"user_id\", user.id)\n        .eq(\"symbol\", normalizedSymbol);\n      if (error) throw error;\n\n      // No need to setWatchListSymbols or setLivePrices again as we did it optimistically\n    } catch (error) {\n      console.error(\"Error removing from watchlist:\", error.message);\n      // Revert optimistic update on error (requires re-fetching old watchlist)\n      await fetchWatchlist(user.id);\n      throw error;\n    }\n  }, [user, fetchWatchlist]); // fetchWatchlist added for error recovery\n\n  // --- Fetch available US stock symbols from Finnhub (uses Finnhub) ---\n  const fetchAvailableSymbols = useCallback(async () => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      setSymbolError(\"Invalid Finnhub API Key. Cannot fetch US stock symbols.\");\n      setAvailableSymbols([]);\n      return;\n    }\n    // setLoadingData(true); // Not part of core initial load, can have its own loading state if needed\n    try {\n      const { data } = await axios.get(\n        `https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`\n      );\n      const filteredSymbols = data\n        .filter(\n          (s) =>\n            s.type === \"Common Stock\" ||\n            s.type === \"ADR\" ||\n            s.type === \"REIT\" ||\n            s.type === \"ETP\" ||\n            s.type === \"ETF\"\n        )\n        .map((s) => s.symbol)\n        .sort();\n\n      setAvailableSymbols(filteredSymbols);\n      setSymbolError(\"\");\n    } catch (error) {\n      console.error(\"Error fetching available symbols:\", error);\n      setSymbolError(\n        \"Failed to fetch US stock symbols. This might be due to API rate limits or an invalid Finnhub API key (free tier keys have limited symbol access).\"\n      );\n      setAvailableSymbols([]);\n    } finally {\n      // setLoadingData(false);\n    }\n  }, []);\n\n  // --- Calculate PnL and Holdings (now uses `holdings` state directly) ---\n  const calculatePnL = useCallback(() => {\n    let totalRealizedPnl = 0;\n\n    let currentHoldingsCalculated = {};\n    Object.values(holdings).forEach((holding) => {\n        let unrealizedPnl = 0;\n        // Ensure livePrices[holding.symbol] is a number before calculation\n        const currentPrice = typeof livePrices[holding.symbol] === 'number' ? livePrices[holding.symbol] : 0;\n\n        if (holding.netQty > 0 && currentPrice !== 0) {\n            unrealizedPnl = (currentPrice - holding.avgBuyPrice) * holding.netQty;\n        }\n        currentHoldingsCalculated[holding.symbol] = {\n            ...holding,\n            // Ensure unrealizedPnl is a number before toFixed\n            unrealizedPnl: (typeof unrealizedPnl === 'number' ? unrealizedPnl : 0).toFixed(2),\n        };\n    });\n\n    const totalUnrealizedPnl = Object.values(currentHoldingsCalculated).reduce((sum, holding) => {\n        // Ensure parseFloat input is valid, fallback to 0\n        return sum + parseFloat(holding.unrealizedPnl || 0);\n    }, 0);\n\n    // Recalculate realized PnL from trades (as trade history defines realized PnL)\n    let realizedPnlFromTrades = 0;\n    const tempHoldingsForRealizedPnl = {};\n    trades.slice().reverse().forEach((trade) => { // Process oldest to newest for accurate PnL\n        if (!tempHoldingsForRealizedPnl[trade.symbol]) {\n            tempHoldingsForRealizedPnl[trade.symbol] = { netQty: 0, totalCost: 0, avgBuyPrice: 0 };\n        }\n\n        if (trade.type === \"buy\") {\n            tempHoldingsForRealizedPnl[trade.symbol].totalCost += trade.quantity * trade.price;\n            tempHoldingsForRealizedPnl[trade.symbol].netQty += trade.quantity;\n            tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice =\n                tempHoldingsForRealizedPnl[trade.symbol].netQty > 0\n                    ? tempHoldingsForRealizedPnl[trade.symbol].totalCost / tempHoldingsForRealizedPnl[trade.symbol].netQty\n                    : 0;\n        } else { // sell\n            const qtySold = trade.quantity;\n            const currentNetQty = tempHoldingsForRealizedPnl[trade.symbol].netQty;\n            const currentAvgBuyPrice = tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice;\n\n            if (currentNetQty > 0) {\n                // Ensure we don't sell more than we currently hold in temp calculation\n                const qtyToSellAgainstCostBasis = Math.min(qtySold, currentNetQty);\n                const sellCostBasis = (currentAvgBuyPrice * qtyToSellAgainstCostBasis);\n                const sellProceeds = trade.price * qtyToSellAgainstCostBasis; // Only proceeds for the qty actually sold from holding\n                realizedPnlFromTrades += (sellProceeds - sellCostBasis);\n            }\n\n            // Update temporary holdings for subsequent trades\n            tempHoldingsForRealizedPnl[trade.symbol].netQty -= qtySold;\n            if (tempHoldingsForRealizedPnl[trade.symbol].netQty <= 0) {\n                tempHoldingsForRealizedPnl[trade.symbol].totalCost = 0;\n                tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice = 0;\n                tempHoldingsForRealizedPnl[trade.symbol].netQty = 0;\n            } else {\n                tempHoldingsForRealizedPnl[trade.symbol].totalCost = tempHoldingsForRealizedPnl[trade.symbol].netQty * tempHoldingsForRealizedPnl[trade.symbol].avgBuyPrice;\n            }\n        }\n    });\n\n    return {\n      holdings: Object.values(currentHoldingsCalculated),\n      // Ensure results are numbers before toFixed, fallback to 0\n      totalRealizedPnl: (typeof realizedPnlFromTrades === 'number' ? realizedPnlFromTrades : 0).toFixed(2),\n      totalUnrealizedPnl: (typeof totalUnrealizedPnl === 'number' ? totalUnrealizedPnl : 0).toFixed(2),\n    };\n  }, [holdings, livePrices, trades]); // `trades` is a dependency here because realized PnL depends on the full trade history.\n\n  // --- Calculate total portfolio value ---\n  const calculateTotalPortfolioValue = useCallback(() => {\n    // This now implicitly depends on `calculatePnL` which internally relies on `livePrices` and `holdings`\n    const { holdings: calculatedHoldings } = calculatePnL();\n    let holdingsValue = 0;\n    Object.values(calculatedHoldings).forEach(holding => {\n      // Ensure livePrices[holding.symbol] is a number before calculation, fallback to 0\n      const currentPrice = typeof livePrices[holding.symbol] === 'number' ? livePrices[holding.symbol] : 0;\n      if (holding.netQty > 0 && currentPrice !== 0) {\n        holdingsValue += holding.netQty * currentPrice;\n      }\n    });\n    // Ensure result is a number before toFixed, fallback to 0\n    return (typeof (capital + holdingsValue) === 'number' ? (capital + holdingsValue) : 0).toFixed(2);\n  }, [capital, calculatePnL, livePrices]); // Explicitly list `livePrices` here because `calculatePnL` uses it\n\n  // --- Add trade logic (modified to update holdings as well) ---\n  const addTrade = useCallback(async (newTrade) => {\n    if (!user?.id) throw new Error(\"User not authenticated.\");\n\n    const normalizedSymbol = newTrade.symbol.toUpperCase();\n    const tradeCost = newTrade.quantity * newTrade.price;\n    let newCapital = capital;\n    let currentHolding = holdings[normalizedSymbol] || { netQty: 0, totalCost: 0, avgBuyPrice: 0 };\n    let newNetQty = currentHolding.netQty;\n    let newTotalCost = currentHolding.totalCost;\n    let newAvgBuyPrice = currentHolding.avgBuyPrice;\n\n    if (newTrade.type === \"buy\") {\n      newCapital -= tradeCost;\n      newNetQty += newTrade.quantity;\n      newTotalCost += tradeCost;\n      newAvgBuyPrice = newTotalCost / newNetQty;\n    } else { // sell\n      newCapital += tradeCost;\n      const qtySold = newTrade.quantity;\n\n      if (currentHolding.netQty < qtySold) {\n          throw new Error(\"Insufficient shares to sell.\");\n      }\n      \n      newNetQty -= qtySold;\n      if (newNetQty <= 0) {\n        newTotalCost = 0;\n        newAvgBuyPrice = 0;\n        newNetQty = 0; // Ensure netQty doesn't go negative\n      } else {\n        // For partial sell, adjust totalCost for remaining shares\n        newTotalCost = newNetQty * currentHolding.avgBuyPrice; // The average buy price remains the same\n      }\n    }\n\n    try {\n      // Optimistically update local capital and holdings BEFORE DB call for snappier UI\n      setCapital(newCapital);\n      setHoldings(prevHoldings => ({\n        ...prevHoldings,\n        [normalizedSymbol]: {\n          symbol: normalizedSymbol,\n          netQty: newNetQty,\n          totalCost: newTotalCost,\n          avgBuyPrice: newAvgBuyPrice,\n        }\n      }));\n\n      // 1. Insert the trade\n      const { error: tradeError } = await supabase\n        .from(\"trades\")\n        .insert([{\n          user_id: user.id,\n          symbol: normalizedSymbol,\n          type: newTrade.type,\n          quantity: newTrade.quantity,\n          price: newTrade.price,\n          created_at: new Date().toISOString(),\n        }]);\n\n      if (tradeError) throw tradeError;\n\n      // 2. Update capital in DB (handleSetCapital does this)\n      await updateCapitalInDb(newCapital, user.id); // Call directly to avoid re-setting local state\n\n      // 3. Update holdings in DB\n      await updateHoldingInDb(user.id, normalizedSymbol, newNetQty, newTotalCost, newAvgBuyPrice);\n\n      // Refresh trades from DB to ensure state is consistent (holdings are already updated by updateHoldingInDb and its fetch)\n      await fetchTrades(user.id);\n\n    } catch (error) {\n      console.error(\"Error adding trade:\", error.message);\n      // Revert local state on error\n      await fetchCapital(user.id);\n      await fetchTrades(user.id);\n      await fetchHoldings(user.id);\n      throw error;\n    }\n  }, [user, capital, holdings, updateCapitalInDb, updateHoldingInDb, fetchTrades, fetchCapital, fetchHoldings]);\n\n  // --- Remove trade logic (modified to correctly recalculate capital and holdings) ---\n  const removeTrade = useCallback(async (tradeToRemove) => {\n    if (!user?.id) throw new Error(\"User not authenticated.\");\n\n    try {\n      // Optimistically remove trade from local state for snappier UI\n      setTrades(prevTrades => prevTrades.filter(t => t.id !== tradeToRemove.id));\n\n      const { error: deleteError } = await supabase\n        .from(\"trades\")\n        .delete()\n        .eq(\"id\", tradeToRemove.id)\n        .eq(\"user_id\", user.id);\n\n      if (deleteError) throw deleteError;\n\n      // After deleting a trade, we need to recalculate capital and holdings from scratch\n      // This is robust for financial systems but can be a heavy operation for many trades.\n\n      // 1. Fetch all remaining trades for the user (chronological order is critical here)\n      const { data: remainingTrades, error: fetchTradesError } = await supabase\n        .from(\"trades\")\n        .select(\"*\")\n        .eq(\"user_id\", user.id)\n        .order(\"created_at\", { ascending: true });\n\n      if (fetchTradesError) throw fetchTradesError;\n\n      // 2. Recalculate capital and holdings from the ground up\n      let recalculatedCapital = 10000; // Start with initial capital\n      let recalculatedHoldings = {};\n\n      remainingTrades.forEach(trade => {\n        const symbol = trade.symbol;\n        const quantity = trade.quantity;\n        const price = trade.price;\n\n        if (!recalculatedHoldings[symbol]) {\n          recalculatedHoldings[symbol] = { netQty: 0, totalCost: 0, avgBuyPrice: 0 };\n        }\n\n        if (trade.type === 'buy') {\n          recalculatedCapital -= (quantity * price);\n          recalculatedHoldings[symbol].totalCost += (quantity * price);\n          recalculatedHoldings[symbol].netQty += quantity;\n          recalculatedHoldings[symbol].avgBuyPrice = recalculatedHoldings[symbol].netQty > 0\n            ? recalculatedHoldings[symbol].totalCost / recalculatedHoldings[symbol].netQty\n            : 0;\n        } else { // sell\n          recalculatedCapital += (quantity * price);\n\n          const currentNetQty = recalculatedHoldings[symbol].netQty;\n          const currentAvgBuyPrice = recalculatedHoldings[symbol].avgBuyPrice;\n\n          if (currentNetQty > 0) {\n              const qtyToSellFromHolding = Math.min(quantity, currentNetQty);\n              recalculatedHoldings[symbol].netQty -= qtyToSellFromHolding;\n\n              if (recalculatedHoldings[symbol].netQty <= 0) {\n                  recalculatedHoldings[symbol].totalCost = 0;\n                  recalculatedHoldings[symbol].avgBuyPrice = 0;\n                  recalculatedHoldings[symbol].netQty = 0;\n              } else {\n                  recalculatedHoldings[symbol].totalCost = recalculatedHoldings[symbol].netQty * currentAvgBuyPrice;\n              }\n          }\n        }\n      });\n\n      // 3. Update capital in DB (handleSetCapital does this)\n      await updateCapitalInDb(recalculatedCapital, user.id); // Direct call\n\n      // 4. Update all holdings in DB based on recalculation\n      // Transactional approach: delete all then insert new ones\n      const { error: deleteHoldingsError } = await supabase\n        .from(\"holdings\")\n        .delete()\n        .eq(\"user_id\", user.id);\n      if (deleteHoldingsError) throw deleteHoldingsError;\n\n      const holdingsToInsert = Object.values(recalculatedHoldings)\n        .filter(h => h.netQty > 0)\n        .map(h => ({\n          user_id: user.id,\n          symbol: h.symbol,\n          net_qty: h.netQty,\n          total_cost: h.totalCost,\n          avg_buy_price: h.avgBuyPrice,\n        }));\n\n      if (holdingsToInsert.length > 0) {\n        const { error: insertHoldingsError } = await supabase\n          .from(\"holdings\")\n          .insert(holdingsToInsert);\n        if (insertHoldingsError) throw insertHoldingsError;\n      }\n\n      // Re-fetch all state from DB to ensure complete consistency, especially for edge cases\n      // after a complex re-calculation.\n      await fetchTrades(user.id);\n      await fetchHoldings(user.id);\n      await fetchCapital(user.id); // Ensure capital is also fresh from DB\n\n    } catch (error) {\n      console.error(\"Error removing trade:\", error.message);\n      // On error, revert all local state by re-fetching everything from DB\n      await fetchCapital(user.id);\n      await fetchTrades(user.id);\n      await fetchHoldings(user.id);\n      throw error;\n    }\n  }, [user, updateCapitalInDb, fetchTrades, fetchHoldings, fetchCapital]);\n\n\n  // --- Initial Data Load on Mount or User Change ---\n  useEffect(() => {\n    const { data: authListener } = supabase.auth.onAuthStateChange(\n      async (event, session) => {\n        setSession(session);\n        const currentUser = session?.user || null;\n        setUser(currentUser);\n\n        if (currentUser) {\n          setLoadingData(true);\n          // Await all initial fetches to ensure loadingData is accurate\n          await Promise.all([\n            fetchCapital(currentUser.id),\n            fetchTrades(currentUser.id),\n            fetchHoldings(currentUser.id),\n            fetchWatchlist(currentUser.id)\n          ]);\n          setLoadingData(false);\n        } else {\n          // Reset states on logout\n          setCapital(10000);\n          setTrades([]);\n          setHoldings({});\n          setWatchListSymbols([]);\n          setLivePrices({});\n          setUser(null);\n          setLoadingData(false);\n          // Clear Finnhub API Key warning if user logs out\n          setSymbolError(\"\");\n        }\n      }\n    );\n\n    // Initial check for session on component mount\n    const checkSession = async () => {\n      setLoadingData(true);\n      const { data: { session } } = await supabase.auth.getSession();\n      setSession(session);\n      const currentUser = session?.user || null;\n      setUser(currentUser);\n\n      if (currentUser) {\n        // Await all initial fetches\n        await Promise.all([\n          fetchCapital(currentUser.id),\n          fetchTrades(currentUser.id),\n          fetchHoldings(currentUser.id),\n          fetchWatchlist(currentUser.id)\n        ]);\n      }\n      setLoadingData(false);\n    };\n\n    checkSession();\n    // fetchAvailableSymbols is not dependent on user, so it can run once.\n    fetchAvailableSymbols();\n\n    return () => {\n      authListener.subscription.unsubscribe();\n      // Clear the interval when the component unmounts\n      if (priceFetchIntervalRef.current) {\n        clearInterval(priceFetchIntervalRef.current);\n      }\n    };\n  }, [fetchCapital, fetchTrades, fetchHoldings, fetchAvailableSymbols, fetchWatchlist]); // Dependencies for initial data load\n\n  // --- Effect to set up and manage live price fetching interval ---\n  useEffect(() => {\n    // Combine symbols from trades, watchlist, and holdings\n    const allSymbols = [\n      ...new Set([\n        ...trades.map((t) => t.symbol),\n        ...watchListSymbols,\n        ...Object.keys(holdings),\n      ])\n    ].filter(Boolean); // Filter out any null/undefined/empty symbols\n\n    // Clear any existing interval to prevent multiple intervals running\n    if (priceFetchIntervalRef.current) {\n      clearInterval(priceFetchIntervalRef.current);\n    }\n\n    if (allSymbols.length > 0 && !isInvalidApiKey(FINNHUB_API_KEY)) {\n      // Fetch immediately on dependency change\n      fetchLivePrices(allSymbols);\n\n      // Set up new interval for periodic refresh\n      priceFetchIntervalRef.current = setInterval(() => {\n        fetchLivePrices(allSymbols);\n      }, 20000); // Every 20 seconds\n    } else if (isInvalidApiKey(FINNHUB_API_KEY)) {\n       // If API key is invalid, ensure symbol error is set and prices are cleared (or handled)\n       setSymbolError(\"Finnhub API Key is invalid. Live prices may not be available.\");\n       setLivePrices({}); // Clear live prices if API key is not working\n    }\n\n\n    return () => {\n      // Cleanup interval on unmount or dependency change\n      if (priceFetchIntervalRef.current) {\n        clearInterval(priceFetchIntervalRef.current);\n        priceFetchIntervalRef.current = null;\n      }\n    };\n  }, [trades, watchListSymbols, holdings, fetchLivePrices]); // Re-run if trades, watchlist, or holdings change\n\n  // Memoize the context value to prevent unnecessary re-renders\n  const contextValue = useMemo(\n    () => ({\n      user,\n      trades,\n      capital,\n      setCapital: handleSetCapital, // Use the wrapped function\n      livePrices,\n      availableSymbols,\n      symbolError,\n      setSymbolError,\n      fetchTrades,\n      fetchLivePrices,\n      calculatePnL,\n      calculateTotalPortfolioValue,\n      loadingData,\n      removeTrade,\n      addTrade, // Expose addTrade function\n      watchListSymbols,\n      addToWatchlist,\n      removeFromWatchlist,\n      holdings: Object.values(holdings), // Provide holdings as an array for easier consumption\n    }),\n    [\n      user,\n      trades,\n      capital,\n      handleSetCapital,\n      livePrices,\n      availableSymbols,\n      symbolError,\n      setSymbolError,\n      fetchTrades, // Included in useMemo because it's a stable callback used by components\n      fetchLivePrices, // Included for the same reason\n      calculatePnL,\n      calculateTotalPortfolioValue,\n      loadingData,\n      removeTrade,\n      addTrade,\n      addToWatchlist,\n      removeFromWatchlist,\n      watchListSymbols,\n      holdings, // Include holdings directly here, as it's passed as an object to `contextValue`\n    ]\n  );\n\n  return (\n    <TradingDataContext.Provider value={contextValue}>\n      {children}\n    </TradingDataContext.Provider>\n  );\n};\n\nexport const useTradingData = () => {\n  const context = useContext(TradingDataContext);\n  if (context === undefined) {\n    throw new Error(\"useTradingData must be used within a TradingDataProvider\");\n  }\n  return context;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}