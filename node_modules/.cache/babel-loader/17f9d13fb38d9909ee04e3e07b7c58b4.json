{"ast":null,"code":"var _jsxFileName = \"/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js\";\nimport React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\nimport { supabase } from './supabaseClient';\nimport axios from 'axios';\nconst TradingDataContext = createContext();\n\n// Make sure your FINNHUB_API_KEY is correct.\n// IMPORTANT: For production, store this in a .env file and access it via process.env.REACT_APP_FINNHUB_API_KEY\n// For local development, it's fine to hardcode for now, but be aware of the security implications on live sites.\nconst FINNHUB_API_KEY = 'd108911r01qhkqr8ggb0d108911r01qhkqr8ggbg'; // <--- UPDATED API KEY\nconst CURRENCY_SYMBOL = '$';\n\n// Helper function to check if the API key is likely a placeholder or genuinely malformed\nconst isInvalidApiKey = key => {\n  return !key || key === \"YOUR_FINNHUB_API_KEY\" ||\n  // The previous key 'cn3c4q9r1ja9e20j4t0gcn3c4q9r1ja9e20j4t10' was here.\n  // Since you've provided a specific new key, this check is no longer needed for that specific old key.\n  // It's still good to keep generic checks like length and spaces if you anticipate typos.\n  key.length < 5 ||\n  // A real key should be much longer\n  key.includes(\" \");\n};\nexport const TradingDataProvider = ({\n  children,\n  user\n}) => {\n  const [trades, setTrades] = useState([]);\n  const [capital, setCapital] = useState(100000); // Starting capital\n  const [livePrices, setLivePrices] = useState({});\n  const [availableSymbols, setAvailableSymbols] = useState([]);\n  const [symbolError, setSymbolError] = useState(\"\");\n  const [loadingData, setLoadingData] = useState(true); // Manages overall loading of core data\n\n  // Memoize fetchTrades\n  const fetchTrades = useCallback(async () => {\n    if (!user || !user.id) {\n      console.log(\"No user ID available to fetch trades.\");\n      return []; // Return an empty array or null to indicate no trades fetched\n    }\n    console.log(\"Fetching trades for user:\", user.id);\n    const {\n      data,\n      error\n    } = await supabase.from(\"trades\").select(\"*\").eq(\"user_id\", user.id).order(\"created_at\", {\n      ascending: true\n    }); // Ensure trades are ordered by time for FIFO\n\n    if (error) {\n      console.error(\"Error fetching trades:\", error);\n      return []; // Return empty array on error\n    } else {\n      console.log(\"Trades fetched:\", data);\n      return data || []; // Return fetched data\n    }\n  }, [user]);\n\n  // Memoize fetchAvailableSymbols\n  const fetchAvailableSymbols = useCallback(async () => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      setSymbolError(\"Finnhub API key is invalid or not set. Cannot fetch available symbols.\");\n      console.warn(\"Finnhub API key is invalid or not set. Skipping symbol fetch.\");\n      return []; // Return empty array on invalid key\n    }\n    try {\n      console.log(\"Fetching available US market symbols from Finnhub...\");\n      const response = await axios.get(`https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`);\n      if (response.data && Array.isArray(response.data)) {\n        const usSymbols = response.data.filter(s => s.type === \"Common Stock\" && s.symbol && !s.symbol.includes(\".\") && !s.symbol.includes(\"-\")).map(s => s.symbol);\n        setSymbolError(\"\");\n        console.log(`Fetched ${usSymbols.length} US symbols.`);\n        return usSymbols; // Return fetched symbols\n      } else {\n        setSymbolError(\"No valid symbol data received from Finnhub.\");\n        return []; // Return empty array on invalid data\n      }\n    } catch (error) {\n      console.error(\"Error fetching available symbols:\", error);\n      setSymbolError(`Failed to fetch available symbols from Finnhub. Check API key and network. Error: ${error.message}`);\n      return []; // Return empty array on fetch error\n    }\n  }, [FINNHUB_API_KEY]);\n\n  // Memoize fetchLivePrices (no change here, as it's not part of the initial setLoadingData flow)\n  const fetchLivePrices = useCallback(async symbols => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      console.warn(\"Finnhub API key is invalid. Skipping live price fetch.\");\n      return;\n    }\n    if (!symbols || symbols.length === 0) return;\n    try {\n      const newPrices = {};\n      await Promise.all(symbols.map(async symbol => {\n        console.log(`Fetching price for ${symbol}...`);\n        const response = await axios.get(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`);\n        if (response.data && response.data.c > 0) {\n          newPrices[symbol] = response.data.c;\n        } else {\n          console.warn(`No valid live price found for ${symbol}. Response:`, response.data);\n          newPrices[symbol] = null;\n        }\n      }));\n      setLivePrices(prevPrices => ({\n        ...prevPrices,\n        ...newPrices\n      }));\n    } catch (error) {\n      console.error(\"Error fetching live prices:\", error);\n    }\n  }, [FINNHUB_API_KEY]);\n\n  // Initial data fetches on component mount or user change\n  useEffect(() => {\n    console.log(\"TradingDataProvider useEffect triggered. User:\", user);\n    if (user) {\n      setLoadingData(true); // Set true at the very beginning of the overall load\n      console.log(\"Starting initial data load for user:\", user.id);\n      const initializeData = async () => {\n        try {\n          // Await both fetches\n          const [fetchedTrades, fetchedSymbols] = await Promise.all([fetchTrades(), fetchAvailableSymbols()]);\n          setTrades(fetchedTrades); // Update trades state\n          setAvailableSymbols(fetchedSymbols); // Update available symbols state\n\n          console.log(\"All initial data fetches complete.\");\n        } catch (error) {\n          console.error(\"Error during initial data fetch:\", error);\n          // You might want to set a global error state here if needed\n        } finally {\n          // This ensures loadingData is set to false whether success or error\n          setLoadingData(false);\n          console.log(\"TradingDataProvider: setLoadingData(false) called.\");\n        }\n      };\n      initializeData();\n    } else {\n      // If user logs out, reset relevant states and set loading to false\n      setTrades([]);\n      setCapital(100000); // Reset capital on logout\n      setLivePrices({});\n      setAvailableSymbols([]);\n      setSymbolError(\"\");\n      setLoadingData(false); // Make sure it's false when no user is logged in\n      console.log(\"No user, resetting data and setting loadingData to false.\");\n    }\n  }, [user, fetchTrades, fetchAvailableSymbols]);\n\n  // Calculate P&L for portfolio holdings - UPDATED TO USE FIFO AND RETURN TOTALS\n  const calculatePnL = useCallback(currentTrades => {\n    const pnlSummary = {};\n    let totalRealizedPnl = 0; // Initialize total realized P&L for the entire portfolio\n\n    // It's crucial that `currentTrades` is sorted by `created_at` before this function is called\n    // The `fetchTrades` already sorts them, so we assume `currentTrades` here is sorted ascending by time.\n\n    currentTrades.forEach(trade => {\n      if (!pnlSummary[trade.symbol]) {\n        pnlSummary[trade.symbol] = {\n          netQty: 0,\n          realizedProfit: 0,\n          // Realized profit for this specific symbol\n          buyQueue: [] // To track individual buy lots for FIFO cost basis\n        };\n      }\n      if (trade.type === \"buy\") {\n        pnlSummary[trade.symbol].netQty += trade.quantity;\n        // Add to buy queue for FIFO\n        pnlSummary[trade.symbol].buyQueue.push({\n          quantity: trade.quantity,\n          price: trade.price\n        });\n      } else if (trade.type === \"sell\") {\n        let remainingQtyToSell = trade.quantity;\n        let costBasisForThisSale = 0;\n\n        // Process buyQueue in FIFO order\n        while (remainingQtyToSell > 0 && pnlSummary[trade.symbol].buyQueue.length > 0) {\n          const oldestBuy = pnlSummary[trade.symbol].buyQueue[0];\n          const qtyFromThisBuy = Math.min(oldestBuy.quantity, remainingQtyToSell);\n          costBasisForThisSale += qtyFromThisBuy * oldestBuy.price;\n          oldestBuy.quantity -= qtyFromThisBuy;\n          remainingQtyToSell -= qtyFromThisBuy;\n          if (oldestBuy.quantity === 0) {\n            pnlSummary[trade.symbol].buyQueue.shift(); // Remove fully utilized buy lot\n          }\n        }\n        pnlSummary[trade.symbol].netQty -= trade.quantity;\n\n        // Calculate realized profit for this sell transaction\n        const realizedProfitForThisSell = trade.quantity * trade.price - costBasisForThisSale;\n        pnlSummary[trade.symbol].realizedProfit += realizedProfitForThisSell; // Add to symbol's realized P&L\n        totalRealizedPnl += realizedProfitForThisSell; // Accumulate to total portfolio realized P&L\n      }\n    });\n    const holdings = Object.entries(pnlSummary).map(([symbol, data]) => {\n      // Calculate average buy price for currently held shares (from remaining buyQueue)\n      let avgBuyPrice = 0;\n      let remainingBuyCost = 0;\n      let remainingBuyQty = 0;\n      data.buyQueue.forEach(lot => {\n        remainingBuyCost += lot.quantity * lot.price;\n        remainingBuyQty += lot.quantity;\n      });\n      if (remainingBuyQty > 0) {\n        avgBuyPrice = remainingBuyCost / remainingBuyQty;\n      } else {\n        avgBuyPrice = 0; // If no shares are held, avgBuyPrice is 0\n      }\n      const currentPrice = livePrices[symbol];\n      const currentMarketValue = data.netQty > 0 && currentPrice ? data.netQty * currentPrice : 0;\n\n      // Unrealized P&L calculation for currently held shares\n      let unrealizedPnl = 0;\n      if (data.netQty > 0 && currentPrice && avgBuyPrice !== 0) {\n        // Ensure avgBuyPrice is not zero before calculating\n        unrealizedPnl = currentMarketValue - avgBuyPrice * data.netQty;\n      }\n      return {\n        symbol,\n        netQty: data.netQty,\n        avgBuyPrice: avgBuyPrice.toFixed(2),\n        // This is the average cost basis of remaining shares\n        realizedPnl: data.realizedProfit.toFixed(2),\n        // Realized P&L for this specific symbol\n        unrealizedPnl: unrealizedPnl.toFixed(2),\n        // Unrealized P&L for currently held shares\n        currentMarketValue: currentMarketValue.toFixed(2) // Live value of currently held shares\n      };\n    }).sort((a, b) => a.symbol.localeCompare(b.symbol));\n\n    // Calculate total unrealized P&L across all holdings\n    let totalUnrealizedPnl = holdings.reduce((sum, h) => sum + parseFloat(h.unrealizedPnl || 0), 0);\n\n    // Return an object containing both holdings data and total P&L figures\n    return {\n      holdings: holdings,\n      totalRealizedPnl: totalRealizedPnl.toFixed(2),\n      totalUnrealizedPnl: totalUnrealizedPnl.toFixed(2)\n    };\n  }, [livePrices]); // Dependency on livePrices is crucial for unrealized P&L\n\n  const calculateTotalPortfolioValue = useCallback(() => {\n    let holdingsValue = 0;\n    // Call calculatePnL and access the holdings array from its return\n    const {\n      holdings\n    } = calculatePnL(trades);\n    holdings.forEach(holding => {\n      if (holding.netQty > 0 && livePrices[holding.symbol]) {\n        holdingsValue += holding.netQty * livePrices[holding.symbol];\n      }\n    });\n    return (capital + holdingsValue).toFixed(2);\n  }, [capital, trades, livePrices, calculatePnL]);\n  const value = {\n    trades,\n    setTrades,\n    capital,\n    setCapital,\n    livePrices,\n    setLivePrices,\n    availableSymbols,\n    symbolError,\n    setSymbolError,\n    fetchTrades,\n    fetchAvailableSymbols,\n    fetchLivePrices,\n    calculatePnL,\n    // This now returns an object with holdings and total P&L\n    isInvalidApiKey,\n    FINNHUB_API_KEY,\n    CURRENCY_SYMBOL,\n    loadingData,\n    calculateTotalPortfolioValue\n  };\n  return /*#__PURE__*/React.createElement(TradingDataContext.Provider, {\n    value: value,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 299,\n      columnNumber: 5\n    }\n  }, children);\n};\nexport const useTradingData = () => {\n  const context = useContext(TradingDataContext);\n  if (!context) {\n    throw new Error('useTradingData must be used within a TradingDataProvider');\n  }\n  return context;\n};","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useCallback","supabase","axios","TradingDataContext","FINNHUB_API_KEY","CURRENCY_SYMBOL","isInvalidApiKey","key","length","includes","TradingDataProvider","children","user","trades","setTrades","capital","setCapital","livePrices","setLivePrices","availableSymbols","setAvailableSymbols","symbolError","setSymbolError","loadingData","setLoadingData","fetchTrades","id","console","log","data","error","from","select","eq","order","ascending","fetchAvailableSymbols","warn","response","get","Array","isArray","usSymbols","filter","s","type","symbol","map","message","fetchLivePrices","symbols","newPrices","Promise","all","c","prevPrices","initializeData","fetchedTrades","fetchedSymbols","calculatePnL","currentTrades","pnlSummary","totalRealizedPnl","forEach","trade","netQty","realizedProfit","buyQueue","quantity","push","price","remainingQtyToSell","costBasisForThisSale","oldestBuy","qtyFromThisBuy","Math","min","shift","realizedProfitForThisSell","holdings","Object","entries","avgBuyPrice","remainingBuyCost","remainingBuyQty","lot","currentPrice","currentMarketValue","unrealizedPnl","toFixed","realizedPnl","sort","a","b","localeCompare","totalUnrealizedPnl","reduce","sum","h","parseFloat","calculateTotalPortfolioValue","holdingsValue","holding","value","createElement","Provider","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","useTradingData","context","Error"],"sources":["/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\nimport { supabase } from './supabaseClient';\nimport axios from 'axios';\n\nconst TradingDataContext = createContext();\n\n// Make sure your FINNHUB_API_KEY is correct.\n// IMPORTANT: For production, store this in a .env file and access it via process.env.REACT_APP_FINNHUB_API_KEY\n// For local development, it's fine to hardcode for now, but be aware of the security implications on live sites.\nconst FINNHUB_API_KEY = 'd108911r01qhkqr8ggb0d108911r01qhkqr8ggbg'; // <--- UPDATED API KEY\nconst CURRENCY_SYMBOL = '$';\n\n// Helper function to check if the API key is likely a placeholder or genuinely malformed\nconst isInvalidApiKey = (key) => {\n  return !key ||\n         key === \"YOUR_FINNHUB_API_KEY\" ||\n         // The previous key 'cn3c4q9r1ja9e20j4t0gcn3c4q9r1ja9e20j4t10' was here.\n         // Since you've provided a specific new key, this check is no longer needed for that specific old key.\n         // It's still good to keep generic checks like length and spaces if you anticipate typos.\n         key.length < 5 || // A real key should be much longer\n         key.includes(\" \");\n};\n\nexport const TradingDataProvider = ({ children, user }) => {\n  const [trades, setTrades] = useState([]);\n  const [capital, setCapital] = useState(100000); // Starting capital\n  const [livePrices, setLivePrices] = useState({});\n  const [availableSymbols, setAvailableSymbols] = useState([]);\n  const [symbolError, setSymbolError] = useState(\"\");\n  const [loadingData, setLoadingData] = useState(true); // Manages overall loading of core data\n\n  // Memoize fetchTrades\n  const fetchTrades = useCallback(async () => {\n    if (!user || !user.id) {\n      console.log(\"No user ID available to fetch trades.\");\n      return []; // Return an empty array or null to indicate no trades fetched\n    }\n    console.log(\"Fetching trades for user:\", user.id);\n    const { data, error } = await supabase\n      .from(\"trades\")\n      .select(\"*\")\n      .eq(\"user_id\", user.id)\n      .order(\"created_at\", { ascending: true }); // Ensure trades are ordered by time for FIFO\n\n    if (error) {\n      console.error(\"Error fetching trades:\", error);\n      return []; // Return empty array on error\n    } else {\n      console.log(\"Trades fetched:\", data);\n      return data || []; // Return fetched data\n    }\n  }, [user]);\n\n  // Memoize fetchAvailableSymbols\n  const fetchAvailableSymbols = useCallback(async () => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      setSymbolError(\"Finnhub API key is invalid or not set. Cannot fetch available symbols.\");\n      console.warn(\"Finnhub API key is invalid or not set. Skipping symbol fetch.\");\n      return []; // Return empty array on invalid key\n    }\n    \n    try {\n      console.log(\"Fetching available US market symbols from Finnhub...\");\n      const response = await axios.get(\n        `https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`\n      );\n      if (response.data && Array.isArray(response.data)) {\n        const usSymbols = response.data\n          .filter(\n            (s) =>\n              s.type === \"Common Stock\" &&\n              s.symbol &&\n              !s.symbol.includes(\".\") &&\n              !s.symbol.includes(\"-\")\n          )\n          .map((s) => s.symbol);\n        setSymbolError(\"\");\n        console.log(`Fetched ${usSymbols.length} US symbols.`);\n        return usSymbols; // Return fetched symbols\n      } else {\n        setSymbolError(\"No valid symbol data received from Finnhub.\");\n        return []; // Return empty array on invalid data\n      }\n    } catch (error) {\n      console.error(\"Error fetching available symbols:\", error);\n      setSymbolError(\n        `Failed to fetch available symbols from Finnhub. Check API key and network. Error: ${error.message}`\n      );\n      return []; // Return empty array on fetch error\n    }\n  }, [FINNHUB_API_KEY]);\n\n  // Memoize fetchLivePrices (no change here, as it's not part of the initial setLoadingData flow)\n  const fetchLivePrices = useCallback(async (symbols) => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      console.warn(\"Finnhub API key is invalid. Skipping live price fetch.\");\n      return;\n    }\n    if (!symbols || symbols.length === 0) return;\n\n    try {\n      const newPrices = {};\n      await Promise.all(\n        symbols.map(async (symbol) => {\n          console.log(`Fetching price for ${symbol}...`);\n          const response = await axios.get(\n            `https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`\n          );\n          if (response.data && response.data.c > 0) {\n            newPrices[symbol] = response.data.c;\n          } else {\n            console.warn(`No valid live price found for ${symbol}. Response:`, response.data);\n            newPrices[symbol] = null;\n          }\n        })\n      );\n      setLivePrices((prevPrices) => ({ ...prevPrices, ...newPrices }));\n    } catch (error) {\n      console.error(\"Error fetching live prices:\", error);\n    }\n  }, [FINNHUB_API_KEY]);\n\n  // Initial data fetches on component mount or user change\n  useEffect(() => {\n    console.log(\"TradingDataProvider useEffect triggered. User:\", user);\n    if (user) {\n      setLoadingData(true); // Set true at the very beginning of the overall load\n      console.log(\"Starting initial data load for user:\", user.id);\n      \n      const initializeData = async () => {\n        try {\n          // Await both fetches\n          const [fetchedTrades, fetchedSymbols] = await Promise.all([\n            fetchTrades(),\n            fetchAvailableSymbols()\n          ]);\n          \n          setTrades(fetchedTrades); // Update trades state\n          setAvailableSymbols(fetchedSymbols); // Update available symbols state\n\n          console.log(\"All initial data fetches complete.\");\n\n        } catch (error) {\n          console.error(\"Error during initial data fetch:\", error);\n          // You might want to set a global error state here if needed\n        } finally {\n          // This ensures loadingData is set to false whether success or error\n          setLoadingData(false);\n          console.log(\"TradingDataProvider: setLoadingData(false) called.\");\n        }\n      };\n      initializeData();\n    } else {\n        // If user logs out, reset relevant states and set loading to false\n        setTrades([]);\n        setCapital(100000); // Reset capital on logout\n        setLivePrices({});\n        setAvailableSymbols([]);\n        setSymbolError(\"\");\n        setLoadingData(false); // Make sure it's false when no user is logged in\n        console.log(\"No user, resetting data and setting loadingData to false.\");\n    }\n  }, [user, fetchTrades, fetchAvailableSymbols]);\n\n\n  // Calculate P&L for portfolio holdings - UPDATED TO USE FIFO AND RETURN TOTALS\n  const calculatePnL = useCallback((currentTrades) => {\n    const pnlSummary = {};\n    let totalRealizedPnl = 0; // Initialize total realized P&L for the entire portfolio\n\n    // It's crucial that `currentTrades` is sorted by `created_at` before this function is called\n    // The `fetchTrades` already sorts them, so we assume `currentTrades` here is sorted ascending by time.\n\n    currentTrades.forEach((trade) => {\n      if (!pnlSummary[trade.symbol]) {\n        pnlSummary[trade.symbol] = {\n          netQty: 0,\n          realizedProfit: 0, // Realized profit for this specific symbol\n          buyQueue: [], // To track individual buy lots for FIFO cost basis\n        };\n      }\n\n      if (trade.type === \"buy\") {\n        pnlSummary[trade.symbol].netQty += trade.quantity;\n        // Add to buy queue for FIFO\n        pnlSummary[trade.symbol].buyQueue.push({\n            quantity: trade.quantity,\n            price: trade.price,\n        });\n      } else if (trade.type === \"sell\") {\n        let remainingQtyToSell = trade.quantity;\n        let costBasisForThisSale = 0;\n\n        // Process buyQueue in FIFO order\n        while (remainingQtyToSell > 0 && pnlSummary[trade.symbol].buyQueue.length > 0) {\n            const oldestBuy = pnlSummary[trade.symbol].buyQueue[0];\n            const qtyFromThisBuy = Math.min(oldestBuy.quantity, remainingQtyToSell);\n\n            costBasisForThisSale += qtyFromThisBuy * oldestBuy.price;\n            oldestBuy.quantity -= qtyFromThisBuy;\n            remainingQtyToSell -= qtyFromThisBuy;\n\n            if (oldestBuy.quantity === 0) {\n                pnlSummary[trade.symbol].buyQueue.shift(); // Remove fully utilized buy lot\n            }\n        }\n        \n        pnlSummary[trade.symbol].netQty -= trade.quantity;\n        \n        // Calculate realized profit for this sell transaction\n        const realizedProfitForThisSell = (trade.quantity * trade.price) - costBasisForThisSale;\n        pnlSummary[trade.symbol].realizedProfit += realizedProfitForThisSell; // Add to symbol's realized P&L\n        totalRealizedPnl += realizedProfitForThisSell; // Accumulate to total portfolio realized P&L\n      }\n    });\n\n    const holdings = Object.entries(pnlSummary)\n      .map(([symbol, data]) => {\n        // Calculate average buy price for currently held shares (from remaining buyQueue)\n        let avgBuyPrice = 0;\n        let remainingBuyCost = 0;\n        let remainingBuyQty = 0;\n        data.buyQueue.forEach(lot => {\n            remainingBuyCost += lot.quantity * lot.price;\n            remainingBuyQty += lot.quantity;\n        });\n        if (remainingBuyQty > 0) {\n            avgBuyPrice = remainingBuyCost / remainingBuyQty;\n        } else {\n            avgBuyPrice = 0; // If no shares are held, avgBuyPrice is 0\n        }\n\n        const currentPrice = livePrices[symbol];\n        const currentMarketValue = data.netQty > 0 && currentPrice ? (data.netQty * currentPrice) : 0;\n        \n        // Unrealized P&L calculation for currently held shares\n        let unrealizedPnl = 0;\n        if (data.netQty > 0 && currentPrice && avgBuyPrice !== 0) { // Ensure avgBuyPrice is not zero before calculating\n            unrealizedPnl = currentMarketValue - (avgBuyPrice * data.netQty);\n        }\n\n        return {\n          symbol,\n          netQty: data.netQty,\n          avgBuyPrice: avgBuyPrice.toFixed(2), // This is the average cost basis of remaining shares\n          realizedPnl: data.realizedProfit.toFixed(2), // Realized P&L for this specific symbol\n          unrealizedPnl: unrealizedPnl.toFixed(2), // Unrealized P&L for currently held shares\n          currentMarketValue: currentMarketValue.toFixed(2), // Live value of currently held shares\n        };\n      })\n      .sort((a, b) => a.symbol.localeCompare(b.symbol));\n\n    // Calculate total unrealized P&L across all holdings\n    let totalUnrealizedPnl = holdings.reduce((sum, h) => sum + parseFloat(h.unrealizedPnl || 0), 0);\n    \n    // Return an object containing both holdings data and total P&L figures\n    return {\n      holdings: holdings,\n      totalRealizedPnl: totalRealizedPnl.toFixed(2),\n      totalUnrealizedPnl: totalUnrealizedPnl.toFixed(2),\n    };\n  }, [livePrices]); // Dependency on livePrices is crucial for unrealized P&L\n\n  const calculateTotalPortfolioValue = useCallback(() => {\n    let holdingsValue = 0;\n    // Call calculatePnL and access the holdings array from its return\n    const { holdings } = calculatePnL(trades);\n    holdings.forEach(holding => {\n      if (holding.netQty > 0 && livePrices[holding.symbol]) {\n        holdingsValue += holding.netQty * livePrices[holding.symbol];\n      }\n    });\n    return (capital + holdingsValue).toFixed(2);\n  }, [capital, trades, livePrices, calculatePnL]);\n\n\n  const value = {\n    trades,\n    setTrades,\n    capital,\n    setCapital,\n    livePrices,\n    setLivePrices,\n    availableSymbols,\n    symbolError,\n    setSymbolError,\n    fetchTrades,\n    fetchAvailableSymbols,\n    fetchLivePrices,\n    calculatePnL, // This now returns an object with holdings and total P&L\n    isInvalidApiKey,\n    FINNHUB_API_KEY,\n    CURRENCY_SYMBOL,\n    loadingData,\n    calculateTotalPortfolioValue,\n  };\n\n  return (\n    <TradingDataContext.Provider value={value}>\n      {children}\n    </TradingDataContext.Provider>\n  );\n};\n\nexport const useTradingData = () => {\n  const context = useContext(TradingDataContext);\n  if (!context) {\n    throw new Error('useTradingData must be used within a TradingDataProvider');\n  }\n  return context;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}