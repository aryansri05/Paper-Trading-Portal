{"ast":null,"code":"var _jsxFileName = \"/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js\";\nimport React, { createContext, useContext, useState, useEffect, useCallback, useRef } from 'react';\nimport { supabase } from './supabaseClient';\nimport axios from 'axios';\nconst TradingDataContext = createContext();\nexport const useTradingData = () => useContext(TradingDataContext);\nexport const TradingDataProvider = ({\n  children\n}) => {\n  // Your Finnhub API Key. Replace with your actual key.\n  // This is a placeholder for demonstration. For production, consider environment variables.\n  const FINNHUB_API_KEY = process.env.REACT_APP_FINNHUB_API_KEY || 'YOUR_FINNHUB_API_KEY';\n\n  // Currency symbol for display\n  const CURRENCY_SYMBOL = '$';\n\n  // --- Core Trading States ---\n  const [user, setUser] = useState(null);\n  const [trades, setTrades] = useState([]);\n  const [livePrices, setLivePrices] = useState({}); // Stores { SYMBOL: price }\n  // --- CAPITAL STATE ---\n  const [capital, setCapitalState] = useState(100000); // Initial default, will be overridden by DB\n  // --- END CAPITAL STATE ---\n\n  const [availableSymbols, setAvailableSymbols] = useState([]); // List of available US stock symbols\n  const [symbolError, setSymbolError] = useState(null); // For errors related to symbol lookups\n  const [loadingData, setLoadingData] = useState(true); // Overall loading state for dashboard\n\n  // Function to check if API key is invalid (placeholder logic)\n  const isInvalidApiKey = key => {\n    // A very basic check: if it's the default placeholder, or empty/null\n    return !key || key === 'YOUR_FINNHUB_API_KEY';\n  };\n\n  // --- CAPITAL UPDATE FUNCTION ---\n  // This new function handles updating both local state AND Supabase\n  const setCapital = useCallback(async newCapitalValue => {\n    setCapitalState(newCapitalValue); // Update local React state\n\n    if (user === null || user === void 0 ? void 0 : user.id) {\n      // Only attempt to update Supabase if a user is logged in\n      try {\n        const {\n          error\n        } = await supabase.from('profiles').update({\n          paper_trading_capital: newCapitalValue\n        }) // Use your column name\n        .eq('id', user.id);\n        if (error) {\n          console.error(\"Error updating capital in database:\", error.message);\n          // You might want to add a user-facing warning here\n        }\n      } catch (err) {\n        console.error(\"Error updating capital in database (catch block):\", err);\n      }\n    }\n  }, [user]);\n  // --- END CAPITAL UPDATE FUNCTION ---\n\n  // --- Fetch Capital Function ---\n  const fetchUserCapital = useCallback(async userId => {\n    if (!userId) {\n      setCapitalState(100000); // Reset to default if no user\n      return;\n    }\n    try {\n      const {\n        data: profile,\n        error\n      } = await supabase.from('profiles').select('paper_trading_capital') // Select your capital column\n      .eq('id', userId).single();\n      if (error && error.code === 'PGRST116') {\n        // No rows found (first-time user or profile not created)\n        console.log('No profile found for user, creating one with default capital.');\n        const {\n          data: newProfile,\n          error: insertError\n        } = await supabase.from('profiles').insert({\n          id: userId,\n          paper_trading_capital: 100000\n        }) // Insert with default capital\n        .select('paper_trading_capital').single();\n        if (insertError) throw insertError;\n        setCapitalState(newProfile.paper_trading_capital); // Update local state with new profile's capital\n      } else if (error) {\n        throw error;\n      } else if (profile) {\n        setCapitalState(profile.paper_trading_capital); // Update local state with fetched capital\n      }\n    } catch (error) {\n      console.error(\"Error fetching or creating user capital:\", error);\n      // Fallback to default if there's an issue fetching\n      setCapitalState(100000);\n    }\n  }, [supabase]); // Depend on supabase to ensure callback stability\n\n  // --- Fetch Trades ---\n  const fetchTrades = useCallback(async userId => {\n    if (!userId) {\n      setTrades([]); // Clear trades if no user\n      return;\n    }\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('trades').select('*').eq('user_id', userId).order('created_at', {\n        ascending: false\n      });\n      if (error) throw error;\n      setTrades(data);\n    } catch (error) {\n      console.error(\"Error fetching trades:\", error);\n      setTrades([]);\n    }\n  }, [supabase]);\n\n  // --- Fetch Available Symbols (for datalist) ---\n  const fetchAvailableSymbols = useCallback(async () => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      setSymbolError(\"Invalid Finnhub API Key. Symbol list cannot be fetched.\");\n      setAvailableSymbols([]); // Clear symbols if API key is invalid\n      return;\n    }\n    try {\n      // Using a local proxy to avoid CORS issues and hide API key from client if desired\n      // Or directly call Finnhub if CORS is handled or API key is not sensitive client-side\n      const response = await axios.get(`https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`);\n      if (response.data && Array.isArray(response.data)) {\n        const symbols = response.data.map(stock => stock.symbol).filter(Boolean); // Ensure symbol exists and is not empty\n        setAvailableSymbols(symbols);\n        setSymbolError(null); // Clear any previous symbol errors\n      } else {\n        setAvailableSymbols([]);\n        setSymbolError(\"Failed to fetch available symbols. Empty or invalid response from API.\");\n      }\n    } catch (error) {\n      console.error(\"Error fetching available symbols from Finnhub:\", error);\n      setAvailableSymbols([]);\n      if (error.response && error.response.status === 429) {\n        setSymbolError(\"Finnhub API rate limit hit for symbols. Please wait a minute before trying again.\");\n      } else if (error.response && error.response.status === 401) {\n        setSymbolError(\"Finnhub API key is unauthorized for symbol list. Check your key.\");\n      } else {\n        setSymbolError(\"Error fetching available symbols. Check network or API key.\");\n      }\n    }\n  }, [FINNHUB_API_KEY, isInvalidApiKey]);\n\n  // --- Fetch Live Prices ---\n  const livePricesCache = useRef({}); // Cache to store fetched prices\n  const fetchLivePrices = useCallback(async symbolsToFetch => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      console.warn(\"Cannot fetch live prices: Invalid Finnhub API Key.\");\n      return;\n    }\n    const newPrices = {\n      ...livePricesCache.current\n    };\n    let anyNewSymbols = false;\n\n    // Filter out symbols we already have a price for, or are invalid\n    const uniqueSymbolsToFetch = [...new Set(symbolsToFetch)].filter(s => {\n      // Check if we already have a price and it's valid\n      const cachedPrice = livePricesCache.current[s];\n      return typeof cachedPrice !== 'number' || cachedPrice <= 0;\n    });\n    if (uniqueSymbolsToFetch.length === 0) {\n      // console.log(\"No new unique symbols to fetch prices for.\");\n      return;\n    }\n    try {\n      // Finnhub's quote endpoint only takes one symbol at a time for free tier.\n      // We'll make individual requests for each unique symbol.\n      await Promise.all(uniqueSymbolsToFetch.map(async symbol => {\n        try {\n          const response = await axios.get(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`);\n          if (response.data && typeof response.data.c === 'number' && response.data.c > 0) {\n            newPrices[symbol] = response.data.c;\n            anyNewSymbols = true;\n          } else {\n            console.warn(`No valid price data for ${symbol}. Response:`, response.data);\n            newPrices[symbol] = null; // Mark as null if no valid price\n          }\n        } catch (error) {\n          console.error(`Error fetching live price for ${symbol}:`, error);\n          newPrices[symbol] = null; // Mark as null on error\n          if (error.response && error.response.status === 429) {\n            console.error(\"Finnhub API rate limit hit for live prices.\");\n            // Consider stopping further requests temporarily or showing a global error\n          }\n        }\n      }));\n      if (anyNewSymbols) {\n        setLivePrices(prevPrices => {\n          const updated = {\n            ...prevPrices,\n            ...newPrices\n          };\n          livePricesCache.current = updated; // Update cache\n          return updated;\n        });\n      }\n    } catch (error) {\n      console.error(\"An unexpected error occurred during live price fetching:\", error);\n    }\n  }, [FINNHUB_API_KEY, isInvalidApiKey]);\n\n  // --- P&L Calculation ---\n  const calculatePnL = useCallback(currentTrades => {\n    const holdings = {};\n    let totalRealizedPnl = 0;\n    let totalUnrealizedPnl = 0;\n\n    // Step 1: Calculate average buy price and net quantity for each symbol\n    currentTrades.forEach(trade => {\n      if (!holdings[trade.symbol]) {\n        holdings[trade.symbol] = {\n          netQty: 0,\n          totalCost: 0,\n          avgBuyPrice: 0,\n          realizedPnl: 0,\n          unrealizedPnl: 0,\n          lastPrice: livePrices[trade.symbol] || 0 // Get last known live price\n        };\n      }\n      if (trade.type === 'buy') {\n        holdings[trade.symbol].netQty += trade.quantity;\n        holdings[trade.symbol].totalCost += trade.quantity * trade.price;\n        holdings[trade.symbol].avgBuyPrice = holdings[trade.symbol].totalCost / holdings[trade.symbol].netQty;\n      } else {\n        // sell\n        // Calculate realized PnL for sells\n        const sellQty = trade.quantity;\n        const currentHolding = holdings[trade.symbol];\n        if (currentHolding && currentHolding.netQty > 0) {\n          const pnl = sellQty * (trade.price - currentHolding.avgBuyPrice);\n          holdings[trade.symbol].realizedPnl += pnl;\n          totalRealizedPnl += pnl;\n        }\n        holdings[trade.symbol].netQty -= sellQty;\n      }\n    });\n\n    // Step 2: Calculate unrealized PnL for current holdings\n    Object.keys(holdings).forEach(symbol => {\n      const holding = holdings[symbol];\n      if (holding.netQty > 0 && livePrices[symbol]) {\n        holding.unrealizedPnl = holding.netQty * (livePrices[symbol] - holding.avgBuyPrice);\n        totalUnrealizedPnl += holding.unrealizedPnl;\n      } else {\n        holding.unrealizedPnl = 0;\n      }\n      // Ensure lastPrice is updated with current live price\n      holding.lastPrice = livePrices[symbol] || 0;\n    });\n\n    // Convert holdings object to an array for easier rendering\n    const holdingsArray = Object.values(holdings).map(h => ({\n      ...h,\n      avgBuyPrice: h.avgBuyPrice.toFixed(2),\n      realizedPnl: h.realizedPnl.toFixed(2),\n      unrealizedPnl: h.unrealizedPnl.toFixed(2)\n    }));\n    return {\n      holdings: holdingsArray,\n      totalRealizedPnl: totalRealizedPnl.toFixed(2),\n      totalUnrealizedPnl: totalUnrealizedPnl.toFixed(2)\n    };\n  }, [livePrices]); // Recalculate if livePrices change\n\n  // --- Main Data Fetching Effect (on component mount / user change) ---\n  useEffect(() => {\n    var _session$data, _session$data$session;\n    const session = supabase.auth.getSession();\n    setUser((session === null || session === void 0 ? void 0 : (_session$data = session.data) === null || _session$data === void 0 ? void 0 : (_session$data$session = _session$data.session) === null || _session$data$session === void 0 ? void 0 : _session$data$session.user) || null);\n    const {\n      data: authListener\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      setUser((session === null || session === void 0 ? void 0 : session.user) || null);\n      if (session === null || session === void 0 ? void 0 : session.user) {\n        setLoadingData(true);\n        await fetchUserCapital(session.user.id); // Fetch capital for the new user\n        await fetchTrades(session.user.id);\n        await fetchAvailableSymbols();\n        setLoadingData(false);\n      } else {\n        // Clear all data if user logs out\n        setTrades([]);\n        setLivePrices({});\n        setAvailableSymbols([]);\n        setCapitalState(100000); // Reset capital on logout\n        setLoadingData(false);\n      }\n    });\n\n    // Initial fetch if user is already logged in on mount\n    const initialLoad = async () => {\n      setLoadingData(true);\n      const {\n        data: {\n          user: currentUser\n        }\n      } = await supabase.auth.getUser();\n      setUser(currentUser);\n      if (currentUser) {\n        await fetchUserCapital(currentUser.id); // Fetch capital\n        await fetchTrades(currentUser.id);\n        await fetchAvailableSymbols();\n      }\n      setLoadingData(false);\n    };\n    initialLoad();\n    return () => {\n      authListener === null || authListener === void 0 ? void 0 : authListener.unsubscir;\n    };\n  }, [fetchTrades, fetchUserCapital, fetchAvailableSymbols, supabase]);\n\n  // Effect to continuously fetch live prices for all held symbols (optional: optimize this if too many calls)\n  useEffect(() => {\n    // Only fetch live prices for symbols currently held by the user or shown in datalist\n    const symbolsInPortfolio = trades.map(trade => trade.symbol.toUpperCase());\n    const symbolsToMonitor = [...new Set([...symbolsInPortfolio, ...availableSymbols])]; // Combine held and available\n\n    // Filter out symbols that are already in livePrices and are valid\n    const symbolsRequiringUpdate = symbolsToMonitor.filter(symbol => {\n      const currentPrice = livePrices[symbol];\n      return typeof currentPrice !== 'number' || currentPrice <= 0;\n    });\n\n    // Fetch initial prices for all symbols when trades or availableSymbols change\n    if (symbolsRequiringUpdate.length > 0) {\n      fetchLivePrices(symbolsRequiringUpdate);\n    }\n\n    // Set up interval for continuous updates, but be cautious with API limits\n    const interval = setInterval(() => {\n      // Fetch prices for symbols currently in the portfolio (excluding those already updated or invalid)\n      const activeSymbols = trades.map(trade => trade.symbol.toUpperCase());\n      const symbolsForInterval = [...new Set(activeSymbols)];\n      if (symbolsForInterval.length > 0) {\n        fetchLivePrices(symbolsForInterval);\n      }\n    }, 15000); // Fetch every 15 seconds (adjust based on Finnhub limits)\n\n    return () => clearInterval(interval);\n  }, [trades, availableSymbols, fetchLivePrices, livePrices]); // Dependencies for this effect\n\n  const value = {\n    user,\n    trades,\n    livePrices,\n    capital,\n    // Provide capital\n    setCapital,\n    // Provide the new setCapital function\n    availableSymbols,\n    symbolError,\n    setSymbolError,\n    fetchTrades,\n    fetchLivePrices,\n    calculatePnL,\n    isInvalidApiKey,\n    FINNHUB_API_KEY,\n    CURRENCY_SYMBOL,\n    loadingData\n  };\n  return /*#__PURE__*/React.createElement(TradingDataContext.Provider, {\n    value: value,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 367,\n      columnNumber: 5\n    }\n  }, children);\n};","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useCallback","useRef","supabase","axios","TradingDataContext","useTradingData","TradingDataProvider","children","FINNHUB_API_KEY","process","env","REACT_APP_FINNHUB_API_KEY","CURRENCY_SYMBOL","user","setUser","trades","setTrades","livePrices","setLivePrices","capital","setCapitalState","availableSymbols","setAvailableSymbols","symbolError","setSymbolError","loadingData","setLoadingData","isInvalidApiKey","key","setCapital","newCapitalValue","id","error","from","update","paper_trading_capital","eq","console","message","err","fetchUserCapital","userId","data","profile","select","single","code","log","newProfile","insertError","insert","fetchTrades","order","ascending","fetchAvailableSymbols","response","get","Array","isArray","symbols","map","stock","symbol","filter","Boolean","status","livePricesCache","fetchLivePrices","symbolsToFetch","warn","newPrices","current","anyNewSymbols","uniqueSymbolsToFetch","Set","s","cachedPrice","length","Promise","all","c","prevPrices","updated","calculatePnL","currentTrades","holdings","totalRealizedPnl","totalUnrealizedPnl","forEach","trade","netQty","totalCost","avgBuyPrice","realizedPnl","unrealizedPnl","lastPrice","type","quantity","price","sellQty","currentHolding","pnl","Object","keys","holding","holdingsArray","values","h","toFixed","_session$data","_session$data$session","session","auth","getSession","authListener","onAuthStateChange","event","initialLoad","currentUser","getUser","unsubscir","symbolsInPortfolio","toUpperCase","symbolsToMonitor","symbolsRequiringUpdate","currentPrice","interval","setInterval","activeSymbols","symbolsForInterval","clearInterval","value","createElement","Provider","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useCallback, useRef } from 'react';\nimport { supabase } from './supabaseClient';\nimport axios from 'axios';\n\nconst TradingDataContext = createContext();\n\nexport const useTradingData = () => useContext(TradingDataContext);\n\nexport const TradingDataProvider = ({ children }) => {\n  // Your Finnhub API Key. Replace with your actual key.\n  // This is a placeholder for demonstration. For production, consider environment variables.\n  const FINNHUB_API_KEY = process.env.REACT_APP_FINNHUB_API_KEY || 'YOUR_FINNHUB_API_KEY';\n\n  // Currency symbol for display\n  const CURRENCY_SYMBOL = '$';\n\n  // --- Core Trading States ---\n  const [user, setUser] = useState(null);\n  const [trades, setTrades] = useState([]);\n  const [livePrices, setLivePrices] = useState({}); // Stores { SYMBOL: price }\n  // --- CAPITAL STATE ---\n  const [capital, setCapitalState] = useState(100000); // Initial default, will be overridden by DB\n  // --- END CAPITAL STATE ---\n\n  const [availableSymbols, setAvailableSymbols] = useState([]); // List of available US stock symbols\n  const [symbolError, setSymbolError] = useState(null); // For errors related to symbol lookups\n  const [loadingData, setLoadingData] = useState(true); // Overall loading state for dashboard\n\n  // Function to check if API key is invalid (placeholder logic)\n  const isInvalidApiKey = (key) => {\n    // A very basic check: if it's the default placeholder, or empty/null\n    return !key || key === 'YOUR_FINNHUB_API_KEY';\n  };\n\n  // --- CAPITAL UPDATE FUNCTION ---\n  // This new function handles updating both local state AND Supabase\n  const setCapital = useCallback(async (newCapitalValue) => {\n    setCapitalState(newCapitalValue); // Update local React state\n\n    if (user?.id) { // Only attempt to update Supabase if a user is logged in\n      try {\n        const { error } = await supabase\n          .from('profiles')\n          .update({ paper_trading_capital: newCapitalValue }) // Use your column name\n          .eq('id', user.id);\n\n        if (error) {\n          console.error(\"Error updating capital in database:\", error.message);\n          // You might want to add a user-facing warning here\n        }\n      } catch (err) {\n        console.error(\"Error updating capital in database (catch block):\", err);\n      }\n    }\n  }, [user]);\n  // --- END CAPITAL UPDATE FUNCTION ---\n\n\n  // --- Fetch Capital Function ---\n  const fetchUserCapital = useCallback(async (userId) => {\n    if (!userId) {\n      setCapitalState(100000); // Reset to default if no user\n      return;\n    }\n    try {\n      const { data: profile, error } = await supabase\n        .from('profiles')\n        .select('paper_trading_capital') // Select your capital column\n        .eq('id', userId)\n        .single();\n\n      if (error && error.code === 'PGRST116') { // No rows found (first-time user or profile not created)\n        console.log('No profile found for user, creating one with default capital.');\n        const { data: newProfile, error: insertError } = await supabase\n          .from('profiles')\n          .insert({ id: userId, paper_trading_capital: 100000 }) // Insert with default capital\n          .select('paper_trading_capital')\n          .single();\n        if (insertError) throw insertError;\n        setCapitalState(newProfile.paper_trading_capital); // Update local state with new profile's capital\n      } else if (error) {\n        throw error;\n      } else if (profile) {\n        setCapitalState(profile.paper_trading_capital); // Update local state with fetched capital\n      }\n    } catch (error) {\n      console.error(\"Error fetching or creating user capital:\", error);\n      // Fallback to default if there's an issue fetching\n      setCapitalState(100000); \n    }\n  }, [supabase]); // Depend on supabase to ensure callback stability\n\n\n  // --- Fetch Trades ---\n  const fetchTrades = useCallback(async (userId) => {\n    if (!userId) {\n      setTrades([]); // Clear trades if no user\n      return;\n    }\n    try {\n      const { data, error } = await supabase\n        .from('trades')\n        .select('*')\n        .eq('user_id', userId)\n        .order('created_at', { ascending: false });\n\n      if (error) throw error;\n      setTrades(data);\n    } catch (error) {\n      console.error(\"Error fetching trades:\", error);\n      setTrades([]);\n    }\n  }, [supabase]);\n\n  // --- Fetch Available Symbols (for datalist) ---\n  const fetchAvailableSymbols = useCallback(async () => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      setSymbolError(\"Invalid Finnhub API Key. Symbol list cannot be fetched.\");\n      setAvailableSymbols([]); // Clear symbols if API key is invalid\n      return;\n    }\n    try {\n      // Using a local proxy to avoid CORS issues and hide API key from client if desired\n      // Or directly call Finnhub if CORS is handled or API key is not sensitive client-side\n      const response = await axios.get(`https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`);\n      if (response.data && Array.isArray(response.data)) {\n        const symbols = response.data.map(stock => stock.symbol).filter(Boolean); // Ensure symbol exists and is not empty\n        setAvailableSymbols(symbols);\n        setSymbolError(null); // Clear any previous symbol errors\n      } else {\n        setAvailableSymbols([]);\n        setSymbolError(\"Failed to fetch available symbols. Empty or invalid response from API.\");\n      }\n    } catch (error) {\n      console.error(\"Error fetching available symbols from Finnhub:\", error);\n      setAvailableSymbols([]);\n      if (error.response && error.response.status === 429) {\n        setSymbolError(\"Finnhub API rate limit hit for symbols. Please wait a minute before trying again.\");\n      } else if (error.response && error.response.status === 401) {\n        setSymbolError(\"Finnhub API key is unauthorized for symbol list. Check your key.\");\n      } else {\n        setSymbolError(\"Error fetching available symbols. Check network or API key.\");\n      }\n    }\n  }, [FINNHUB_API_KEY, isInvalidApiKey]);\n\n  // --- Fetch Live Prices ---\n  const livePricesCache = useRef({}); // Cache to store fetched prices\n  const fetchLivePrices = useCallback(async (symbolsToFetch) => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      console.warn(\"Cannot fetch live prices: Invalid Finnhub API Key.\");\n      return;\n    }\n\n    const newPrices = { ...livePricesCache.current };\n    let anyNewSymbols = false;\n\n    // Filter out symbols we already have a price for, or are invalid\n    const uniqueSymbolsToFetch = [...new Set(symbolsToFetch)].filter(s => {\n      // Check if we already have a price and it's valid\n      const cachedPrice = livePricesCache.current[s];\n      return typeof cachedPrice !== 'number' || cachedPrice <= 0;\n    });\n\n    if (uniqueSymbolsToFetch.length === 0) {\n      // console.log(\"No new unique symbols to fetch prices for.\");\n      return;\n    }\n\n    try {\n      // Finnhub's quote endpoint only takes one symbol at a time for free tier.\n      // We'll make individual requests for each unique symbol.\n      await Promise.all(uniqueSymbolsToFetch.map(async (symbol) => {\n        try {\n          const response = await axios.get(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`);\n          if (response.data && typeof response.data.c === 'number' && response.data.c > 0) {\n            newPrices[symbol] = response.data.c;\n            anyNewSymbols = true;\n          } else {\n            console.warn(`No valid price data for ${symbol}. Response:`, response.data);\n            newPrices[symbol] = null; // Mark as null if no valid price\n          }\n        } catch (error) {\n          console.error(`Error fetching live price for ${symbol}:`, error);\n          newPrices[symbol] = null; // Mark as null on error\n          if (error.response && error.response.status === 429) {\n            console.error(\"Finnhub API rate limit hit for live prices.\");\n            // Consider stopping further requests temporarily or showing a global error\n          }\n        }\n      }));\n\n      if (anyNewSymbols) {\n        setLivePrices(prevPrices => {\n          const updated = { ...prevPrices, ...newPrices };\n          livePricesCache.current = updated; // Update cache\n          return updated;\n        });\n      }\n    } catch (error) {\n      console.error(\"An unexpected error occurred during live price fetching:\", error);\n    }\n  }, [FINNHUB_API_KEY, isInvalidApiKey]);\n\n\n  // --- P&L Calculation ---\n  const calculatePnL = useCallback((currentTrades) => {\n    const holdings = {};\n    let totalRealizedPnl = 0;\n    let totalUnrealizedPnl = 0;\n\n    // Step 1: Calculate average buy price and net quantity for each symbol\n    currentTrades.forEach(trade => {\n      if (!holdings[trade.symbol]) {\n        holdings[trade.symbol] = {\n          netQty: 0,\n          totalCost: 0,\n          avgBuyPrice: 0,\n          realizedPnl: 0,\n          unrealizedPnl: 0,\n          lastPrice: livePrices[trade.symbol] || 0 // Get last known live price\n        };\n      }\n\n      if (trade.type === 'buy') {\n        holdings[trade.symbol].netQty += trade.quantity;\n        holdings[trade.symbol].totalCost += trade.quantity * trade.price;\n        holdings[trade.symbol].avgBuyPrice = holdings[trade.symbol].totalCost / holdings[trade.symbol].netQty;\n      } else { // sell\n        // Calculate realized PnL for sells\n        const sellQty = trade.quantity;\n        const currentHolding = holdings[trade.symbol];\n\n        if (currentHolding && currentHolding.netQty > 0) {\n          const pnl = sellQty * (trade.price - currentHolding.avgBuyPrice);\n          holdings[trade.symbol].realizedPnl += pnl;\n          totalRealizedPnl += pnl;\n        }\n        holdings[trade.symbol].netQty -= sellQty;\n      }\n    });\n\n    // Step 2: Calculate unrealized PnL for current holdings\n    Object.keys(holdings).forEach(symbol => {\n      const holding = holdings[symbol];\n      if (holding.netQty > 0 && livePrices[symbol]) {\n        holding.unrealizedPnl = holding.netQty * (livePrices[symbol] - holding.avgBuyPrice);\n        totalUnrealizedPnl += holding.unrealizedPnl;\n      } else {\n        holding.unrealizedPnl = 0;\n      }\n       // Ensure lastPrice is updated with current live price\n       holding.lastPrice = livePrices[symbol] || 0;\n    });\n\n    // Convert holdings object to an array for easier rendering\n    const holdingsArray = Object.values(holdings).map(h => ({\n        ...h,\n        avgBuyPrice: h.avgBuyPrice.toFixed(2),\n        realizedPnl: h.realizedPnl.toFixed(2),\n        unrealizedPnl: h.unrealizedPnl.toFixed(2)\n    }));\n\n\n    return {\n      holdings: holdingsArray,\n      totalRealizedPnl: totalRealizedPnl.toFixed(2),\n      totalUnrealizedPnl: totalUnrealizedPnl.toFixed(2)\n    };\n  }, [livePrices]); // Recalculate if livePrices change\n\n\n  // --- Main Data Fetching Effect (on component mount / user change) ---\n  useEffect(() => {\n    const session = supabase.auth.getSession();\n    setUser(session?.data?.session?.user || null);\n\n    const { data: authListener } = supabase.auth.onAuthStateChange(async (event, session) => {\n      setUser(session?.user || null);\n      if (session?.user) {\n        setLoadingData(true);\n        await fetchUserCapital(session.user.id); // Fetch capital for the new user\n        await fetchTrades(session.user.id);\n        await fetchAvailableSymbols();\n        setLoadingData(false);\n      } else {\n        // Clear all data if user logs out\n        setTrades([]);\n        setLivePrices({});\n        setAvailableSymbols([]);\n        setCapitalState(100000); // Reset capital on logout\n        setLoadingData(false);\n      }\n    });\n\n    // Initial fetch if user is already logged in on mount\n    const initialLoad = async () => {\n      setLoadingData(true);\n      const { data: { user: currentUser } } = await supabase.auth.getUser();\n      setUser(currentUser);\n      if (currentUser) {\n        await fetchUserCapital(currentUser.id); // Fetch capital\n        await fetchTrades(currentUser.id);\n        await fetchAvailableSymbols();\n      }\n      setLoadingData(false);\n    };\n\n    initialLoad();\n\n    return () => {\n      authListener?.unsubscir;\n    };\n  }, [fetchTrades, fetchUserCapital, fetchAvailableSymbols, supabase]);\n\n\n  // Effect to continuously fetch live prices for all held symbols (optional: optimize this if too many calls)\n  useEffect(() => {\n    // Only fetch live prices for symbols currently held by the user or shown in datalist\n    const symbolsInPortfolio = trades.map(trade => trade.symbol.toUpperCase());\n    const symbolsToMonitor = [...new Set([...symbolsInPortfolio, ...availableSymbols])]; // Combine held and available\n\n    // Filter out symbols that are already in livePrices and are valid\n    const symbolsRequiringUpdate = symbolsToMonitor.filter(symbol => {\n        const currentPrice = livePrices[symbol];\n        return typeof currentPrice !== 'number' || currentPrice <= 0;\n    });\n    \n    // Fetch initial prices for all symbols when trades or availableSymbols change\n    if (symbolsRequiringUpdate.length > 0) {\n      fetchLivePrices(symbolsRequiringUpdate);\n    }\n\n    // Set up interval for continuous updates, but be cautious with API limits\n    const interval = setInterval(() => {\n      // Fetch prices for symbols currently in the portfolio (excluding those already updated or invalid)\n      const activeSymbols = trades.map(trade => trade.symbol.toUpperCase());\n      const symbolsForInterval = [...new Set(activeSymbols)];\n      if (symbolsForInterval.length > 0) {\n        fetchLivePrices(symbolsForInterval);\n      }\n    }, 15000); // Fetch every 15 seconds (adjust based on Finnhub limits)\n\n    return () => clearInterval(interval);\n  }, [trades, availableSymbols, fetchLivePrices, livePrices]); // Dependencies for this effect\n\n\n  const value = {\n    user,\n    trades,\n    livePrices,\n    capital, // Provide capital\n    setCapital, // Provide the new setCapital function\n    availableSymbols,\n    symbolError,\n    setSymbolError,\n    fetchTrades,\n    fetchLivePrices,\n    calculatePnL,\n    isInvalidApiKey,\n    FINNHUB_API_KEY,\n    CURRENCY_SYMBOL,\n    loadingData,\n  };\n\n  return (\n    <TradingDataContext.Provider value={value}>\n      {children}\n    </TradingDataContext.Provider>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}