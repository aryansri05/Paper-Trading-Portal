{"ast":null,"code":"var _jsxFileName = \"/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js\";\n// src/TradingDataContext.js\nimport React, { createContext, useContext, useState, useEffect, useCallback, useMemo } from \"react\";\nimport { supabase } from \"./supabaseClient\";\nimport axios from \"axios\";\nconst TradingDataContext = createContext();\n\n// Constants for API Key and Currency Symbol - Replace with your actual values\nconst FINNHUB_API_KEY = process.env.REACT_APP_FINNHUB_API_KEY || \"YOUR_FINNHUB_API_KEY\"; // Get from .env or replace\nconst CURRENCY_SYMBOL = process.env.REACT_APP_CURRENCY_SYMBOL || \"$\"; // Get from .env or replace\n\n// Helper to check if API key is valid (simple check)\nconst isInvalidApiKey = key => {\n  return !key || key === \"YOUR_FINNHUB_API_KEY\" || key.length < 10; // Basic check\n};\nexport const TradingDataProvider = ({\n  children\n}) => {\n  const [user, setUser] = useState(null);\n  const [trades, setTrades] = useState([]);\n  const [capital, setCapital] = useState(10000); // Initial capital\n  const [livePrices, setLivePrices] = useState({});\n  const [availableSymbols, setAvailableSymbols] = useState([]);\n  const [symbolError, setSymbolError] = useState(\"\");\n  const [loadingData, setLoadingData] = useState(true);\n  const [session, setSession] = useState(null); // Supabase session\n  const [watchListSymbols, setWatchListSymbols] = useState([]); // NEW STATE for watchlist symbols <-- ADD THIS\n\n  // --- Helper to fetch user's capital from Supabase ---\n  const fetchCapital = useCallback(async userId => {\n    if (!userId) {\n      // console.warn(\"fetchCapital: No user ID provided. Setting default capital.\");\n      setCapital(10000); // Reset to default if no user\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"user_profiles\").select(\"capital\").eq(\"user_id\", userId).single();\n      if (error && error.code !== 'PGRST116') {\n        // PGRST116 means no rows found (new user)\n        throw error;\n      }\n      if (data) {\n        setCapital(data.capital);\n      } else {\n        // If no profile exists, create one with default capital\n        const {\n          data: newProfile,\n          error: insertError\n        } = await supabase.from(\"user_profiles\").insert([{\n          user_id: userId,\n          capital: 10000\n        }]).select(\"capital\").single();\n        if (insertError) throw insertError;\n        setCapital(newProfile.capital);\n      }\n    } catch (error) {\n      console.error(\"Error fetching or setting capital:\", error.message);\n      // Fallback to default capital if DB operation fails\n      setCapital(10000);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Function to update capital in Supabase ---\n  const updateCapitalInDb = useCallback(async (newCapital, userId) => {\n    if (!userId) {\n      console.warn(\"updateCapitalInDb: No user ID, not updating DB.\");\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        error\n      } = await supabase.from(\"user_profiles\").update({\n        capital: newCapital\n      }).eq(\"user_id\", userId);\n      if (error) throw error;\n      setCapital(newCapital); // Update local state only after successful DB update\n    } catch (error) {\n      console.error(\"Error updating capital in DB:\", error.message);\n      // You might want to revert the local state or show an error to the user\n      // if the DB update fails, or trigger a re-fetch.\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Wrapped setCapital to update DB as well ---\n  const handleSetCapital = useCallback(async newCapital => {\n    // Optimistic update\n    setCapital(newCapital);\n    // Then attempt to update DB\n    if (user === null || user === void 0 ? void 0 : user.id) {\n      await updateCapitalInDb(newCapital, user.id);\n    } else {\n      console.warn(\"No user ID available for DB capital update.\");\n    }\n  }, [user, updateCapitalInDb]);\n\n  // --- Fetch trades for the current user ---\n  const fetchTrades = useCallback(async userId => {\n    if (!userId) {\n      setTrades([]); // Clear trades if no user\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"trades\").select(\"*\").eq(\"user_id\", userId).order(\"created_at\", {\n        ascending: false\n      });\n      if (error) throw error;\n      setTrades(data);\n    } catch (error) {\n      console.error(\"Error fetching trades:\", error.message);\n      setTrades([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- NEW: Fetch watchlist symbols for the current user ---\n  const fetchWatchlist = useCallback(async userId => {\n    if (!userId) {\n      setWatchListSymbols([]);\n      return;\n    }\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"watchlists\").select(\"symbol\").eq(\"user_id\", userId).order(\"created_at\", {\n        ascending: true\n      }); // Order by creation for consistent display\n\n      if (error) throw error;\n      setWatchListSymbols(data.map(item => item.symbol));\n    } catch (error) {\n      console.error(\"Error fetching watchlist:\", error.message);\n      setWatchListSymbols([]);\n    }\n  }, []); // <-- ADD THIS FUNCTION\n\n  // --- NEW: Add symbol to watchlist ---\n  const addToWatchlist = useCallback(async symbol => {\n    if (!(user === null || user === void 0 ? void 0 : user.id)) {\n      throw new Error(\"User not authenticated.\");\n    }\n    const normalizedSymbol = symbol.toUpperCase();\n    if (watchListSymbols.includes(normalizedSymbol)) {\n      throw new Error(`'${normalizedSymbol}' is already in your watchlist.`);\n    }\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"watchlists\").insert([{\n        user_id: user.id,\n        symbol: normalizedSymbol\n      }]).select(\"symbol\").single();\n      if (error) throw error;\n      setWatchListSymbols(prev => [...prev, data.symbol]);\n      // Also fetch live price for this new symbol\n      fetchLivePrices([normalizedSymbol]);\n    } catch (error) {\n      console.error(\"Error adding to watchlist:\", error.message);\n      throw error; // Re-throw to be handled by UI\n    }\n  }, [user, watchListSymbols, fetchLivePrices]); // <-- ADD THIS FUNCTION\n\n  // --- NEW: Remove symbol from watchlist ---\n  const removeFromWatchlist = useCallback(async symbol => {\n    if (!(user === null || user === void 0 ? void 0 : user.id)) {\n      throw new Error(\"User not authenticated.\");\n    }\n    try {\n      const {\n        error\n      } = await supabase.from(\"watchlists\").delete().eq(\"user_id\", user.id).eq(\"symbol\", symbol.toUpperCase());\n      if (error) throw error;\n      setWatchListSymbols(prev => prev.filter(s => s !== symbol.toUpperCase()));\n      // Optionally remove price from livePrices if it's no longer needed anywhere else\n      setLivePrices(prev => {\n        const newPrices = {\n          ...prev\n        };\n        delete newPrices[symbol.toUpperCase()];\n        return newPrices;\n      });\n    } catch (error) {\n      console.error(\"Error removing from watchlist:\", error.message);\n      throw error; // Re-throw to be handled by UI\n    }\n  }, [user]); // <-- ADD THIS FUNCTION\n\n  // --- Fetch live prices for a given list of symbols ---\n  const fetchLivePrices = useCallback(async symbolsToFetch => {\n    // Filter out invalid symbols or duplicates\n    const uniqueSymbols = [...new Set(symbolsToFetch)].filter(s => s && typeof s === 'string');\n    if (uniqueSymbols.length === 0 || isInvalidApiKey(FINNHUB_API_KEY)) {\n      setLivePrices(prev => {\n        // Clear prices for symbols not being fetched\n        const newPrices = {};\n        // Keep existing prices if they're for symbols currently being watched/held\n        // This logic needs to be careful not to remove valid prices if the input is empty\n        // For simplicity, if symbolsToFetch is empty, we don't update prices here.\n        if (uniqueSymbols.length === 0) return prev;\n\n        // If specific symbols are requested, only keep those\n        uniqueSymbols.forEach(sym => {\n          if (prev[sym]) newPrices[sym] = prev[sym];\n        });\n        return newPrices;\n      });\n      return;\n    }\n    try {\n      const responses = await Promise.all(uniqueSymbols.map(symbol => axios.get(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`)));\n      const newPrices = {};\n      responses.forEach((res, index) => {\n        const symbol = uniqueSymbols[index];\n        if (res.data && res.data.c !== 0) {\n          // 'c' is current price, 0 often means no data\n          newPrices[symbol] = res.data.c;\n        } else {\n          newPrices[symbol] = null; // Mark as unavailable\n        }\n      });\n      setLivePrices(prev => ({\n        ...prev,\n        ...newPrices\n      }));\n    } catch (error) {\n      console.error(\"Error fetching live prices:\", error);\n      // Mark all requested symbols as unavailable on error\n      const errorPrices = {};\n      uniqueSymbols.forEach(symbol => {\n        errorPrices[symbol] = null;\n      });\n      setLivePrices(prev => ({\n        ...prev,\n        ...errorPrices\n      }));\n    }\n  }, [FINNHUB_API_KEY]);\n\n  // --- Fetch available US stock symbols from Finnhub ---\n  const fetchAvailableSymbols = useCallback(async () => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      setSymbolError(\"Invalid Finnhub API Key. Cannot fetch US stock symbols.\");\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        data\n      } = await axios.get(`https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`);\n      // Filter for common stock types (e.g., 'Common Stock', 'ADR', 'REIT', 'ETP')\n      const filteredSymbols = data.filter(s => s.type === \"Common Stock\" || s.type === \"ADR\" || s.type === \"REIT\" || s.type === \"ETP\" || s.type === \"ETF\").map(s => s.symbol).sort(); // Sort alphabetically\n\n      setAvailableSymbols(filteredSymbols);\n      setSymbolError(\"\"); // Clear any previous errors\n    } catch (error) {\n      console.error(\"Error fetching available symbols:\", error);\n      setSymbolError(\"Failed to fetch US stock symbols. This might be due to API rate limits or an invalid Finnhub API key (free tier keys have limited symbol access).\");\n      setAvailableSymbols([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, [FINNHUB_API_KEY]);\n\n  // --- Calculate PnL and Holdings ---\n  const calculatePnL = useCallback(() => {\n    let holdings = {};\n    let totalRealizedPnl = 0;\n    trades.forEach(trade => {\n      if (!holdings[trade.symbol]) {\n        holdings[trade.symbol] = {\n          symbol: trade.symbol,\n          netQty: 0,\n          totalCost: 0,\n          avgBuyPrice: 0\n        };\n      }\n      if (trade.type === \"buy\") {\n        holdings[trade.symbol].totalCost += trade.quantity * trade.price;\n        holdings[trade.symbol].netQty += trade.quantity;\n        holdings[trade.symbol].avgBuyPrice = holdings[trade.symbol].totalCost / holdings[trade.symbol].netQty;\n      } else {\n        // Sell logic: Calculate realized P&L based on average buy price\n        const {\n          netQty: currentNetQty,\n          avgBuyPrice\n        } = holdings[trade.symbol];\n        if (currentNetQty > 0) {\n          const sellProfit = (trade.price - avgBuyPrice) * trade.quantity;\n          totalRealizedPnl += sellProfit;\n        }\n        holdings[trade.symbol].netQty -= trade.quantity;\n        // If netQty becomes 0 or negative, reset cost/avg price\n        if (holdings[trade.symbol].netQty <= 0) {\n          holdings[trade.symbol].totalCost = 0;\n          holdings[trade.symbol].avgBuyPrice = 0;\n        } else {\n          // If selling partial, totalCost needs to be adjusted proportionally\n          holdings[trade.symbol].totalCost = holdings[trade.symbol].netQty * holdings[trade.symbol].avgBuyPrice;\n        }\n      }\n    });\n    let totalUnrealizedPnl = 0;\n    // Calculate unrealized P&L for current holdings\n    Object.values(holdings).forEach(holding => {\n      if (holding.netQty > 0 && livePrices[holding.symbol]) {\n        const livePrice = livePrices[holding.symbol];\n        const unrealized = (livePrice - holding.avgBuyPrice) * holding.netQty;\n        holding.unrealizedPnl = unrealized.toFixed(2);\n        totalUnrealizedPnl += unrealized;\n      } else {\n        holding.unrealizedPnl = \"0.00\";\n      }\n    });\n    return {\n      holdings: Object.values(holdings),\n      totalRealizedPnl: totalRealizedPnl.toFixed(2),\n      totalUnrealizedPnl: totalUnrealizedPnl.toFixed(2)\n    };\n  }, [trades, livePrices]);\n\n  // --- Calculate total portfolio value ---\n  const calculateTotalPortfolioValue = useCallback(() => {\n    const {\n      holdings\n    } = calculatePnL();\n    let holdingsValue = 0;\n    holdings.forEach(holding => {\n      if (holding.netQty > 0 && livePrices[holding.symbol]) {\n        holdingsValue += holding.netQty * livePrices[holding.symbol];\n      }\n    });\n    return (capital + holdingsValue).toFixed(2);\n  }, [capital, calculatePnL, livePrices]);\n\n  // --- NEW: Remove trade logic ---\n  const removeTrade = useCallback(async tradeToRemove => {\n    if (!(user === null || user === void 0 ? void 0 : user.id)) throw new Error(\"User not authenticated.\");\n    try {\n      const {\n        error: deleteError\n      } = await supabase.from(\"trades\").delete().eq(\"id\", tradeToRemove.id).eq(\"user_id\", user.id); // Ensure user owns the trade\n\n      if (deleteError) throw deleteError;\n\n      // Re-fetch all trades to get the accurate state after deletion\n      // and recalculate capital based on the new trade history\n      await fetchTrades(user.id);\n\n      // Re-calculate capital based on the *entire* trade history from scratch\n      // This is the safest way to ensure capital is correct after a trade is removed.\n      const {\n        data: allTradesAfterDeletion,\n        error: fetchAllTradesError\n      } = await supabase.from(\"trades\").select(\"*\").eq(\"user_id\", user.id).order(\"created_at\", {\n        ascending: true\n      }); // Need historical order for accurate capital calculation\n\n      if (fetchAllTradesError) throw fetchAllTradesError;\n      let calculatedCapital = 10000; // Start with initial capital\n      allTradesAfterDeletion.forEach(trade => {\n        if (trade.type === 'buy') {\n          calculatedCapital -= trade.quantity * trade.price;\n        } else {\n          // sell\n          calculatedCapital += trade.quantity * trade.price;\n        }\n      });\n      await handleSetCapital(calculatedCapital); // Update capital in DB and local state\n\n      // Since trades are re-fetched, the calculatePnL in consuming components will also update.\n    } catch (error) {\n      console.error(\"Error removing trade:\", error.message);\n      throw error;\n    }\n  }, [user, fetchTrades, handleSetCapital]);\n\n  // --- Initial Data Load on Mount or User Change ---\n  useEffect(() => {\n    const {\n      data: authListener\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      setSession(session);\n      const currentUser = (session === null || session === void 0 ? void 0 : session.user) || null;\n      setUser(currentUser);\n      if (currentUser) {\n        setLoadingData(true);\n        await fetchCapital(currentUser.id);\n        await fetchTrades(currentUser.id);\n        await fetchWatchlist(currentUser.id); // NEW: Fetch watchlist <-- ADD THIS\n        setLoadingData(false);\n      } else {\n        // Clear states if user logs out\n        setCapital(10000);\n        setTrades([]);\n        setWatchListSymbols([]); // NEW: Clear watchlist <-- ADD THIS\n        setLivePrices({});\n        setUser(null);\n        setLoadingData(false);\n      }\n    });\n\n    // Initial check for session\n    const checkSession = async () => {\n      setLoadingData(true);\n      const {\n        data: {\n          session\n        }\n      } = await supabase.auth.getSession();\n      setSession(session);\n      const currentUser = (session === null || session === void 0 ? void 0 : session.user) || null;\n      setUser(currentUser);\n      if (currentUser) {\n        await fetchCapital(currentUser.id);\n        await fetchTrades(currentUser.id);\n        await fetchWatchlist(currentUser.id); // NEW: Fetch watchlist <-- ADD THIS\n      }\n      setLoadingData(false);\n    };\n    checkSession();\n    fetchAvailableSymbols(); // Fetch symbols once on load\n\n    return () => {\n      authListener.subscription.unsubscribe();\n    };\n  }, [fetchCapital, fetchTrades, fetchAvailableSymbols, fetchWatchlist]); // Add fetchWatchlist to dependencies\n\n  // --- Effect to fetch live prices for all relevant symbols ---\n  useEffect(() => {\n    // Collect all unique symbols from trades and watchlist\n    const allSymbols = [...new Set([...trades.map(t => t.symbol), ...watchListSymbols,\n    // NEW: Include watchlist symbols <-- ADD THIS\n    ...Object.keys(livePrices) // Keep previously fetched symbols\n    ])].filter(Boolean); // Filter out any null/undefined symbols\n\n    if (allSymbols.length > 0) {\n      fetchLivePrices(allSymbols);\n\n      // Set up an interval for live price updates (e.g., every 15-30 seconds)\n      const interval = setInterval(() => {\n        fetchLivePrices(allSymbols);\n      }, 20000); // Update every 20 seconds\n\n      return () => clearInterval(interval); // Cleanup interval\n    }\n  }, [trades, watchListSymbols, fetchLivePrices]); // Add watchlistSymbols to dependencies <-- ADD THIS\n\n  // Memoize the context value to prevent unnecessary re-renders\n  const contextValue = useMemo(() => ({\n    user,\n    trades,\n    capital,\n    setCapital: handleSetCapital,\n    // Use the wrapped setter\n    livePrices,\n    availableSymbols,\n    symbolError,\n    setSymbolError,\n    fetchTrades,\n    fetchLivePrices,\n    calculatePnL,\n    calculateTotalPortfolioValue,\n    isInvalidApiKey,\n    FINNHUB_API_KEY,\n    CURRENCY_SYMBOL,\n    loadingData,\n    removeTrade,\n    watchListSymbols,\n    // NEW: Add to context value <-- ADD THIS\n    addToWatchlist,\n    // NEW: Add to context value <-- ADD THIS\n    removeFromWatchlist // NEW: Add to context value <-- ADD THIS\n  }), [user, trades, capital, handleSetCapital, livePrices, availableSymbols, symbolError, setSymbolError, fetchTrades, fetchLivePrices, calculatePnL, calculateTotalPortfolioValue, isInvalidApiKey, FINNHUB_API_KEY, CURRENCY_SYMBOL, loadingData, removeTrade, watchListSymbols,\n  // <-- ADD THIS\n  addToWatchlist,\n  // <-- ADD THIS\n  removeFromWatchlist // <-- ADD THIS\n  ]);\n  return /*#__PURE__*/React.createElement(TradingDataContext.Provider, {\n    value: contextValue,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 533,\n      columnNumber: 5\n    }\n  }, children);\n};\nexport const useTradingData = () => useContext(TradingDataContext);","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useCallback","useMemo","supabase","axios","TradingDataContext","FINNHUB_API_KEY","process","env","REACT_APP_FINNHUB_API_KEY","CURRENCY_SYMBOL","REACT_APP_CURRENCY_SYMBOL","isInvalidApiKey","key","length","TradingDataProvider","children","user","setUser","trades","setTrades","capital","setCapital","livePrices","setLivePrices","availableSymbols","setAvailableSymbols","symbolError","setSymbolError","loadingData","setLoadingData","session","setSession","watchListSymbols","setWatchListSymbols","fetchCapital","userId","data","error","from","select","eq","single","code","newProfile","insertError","insert","user_id","console","message","updateCapitalInDb","newCapital","warn","update","handleSetCapital","id","fetchTrades","order","ascending","fetchWatchlist","map","item","symbol","addToWatchlist","Error","normalizedSymbol","toUpperCase","includes","prev","fetchLivePrices","removeFromWatchlist","delete","filter","s","newPrices","symbolsToFetch","uniqueSymbols","Set","forEach","sym","responses","Promise","all","get","res","index","c","errorPrices","fetchAvailableSymbols","filteredSymbols","type","sort","calculatePnL","holdings","totalRealizedPnl","trade","netQty","totalCost","avgBuyPrice","quantity","price","currentNetQty","sellProfit","totalUnrealizedPnl","Object","values","holding","livePrice","unrealized","unrealizedPnl","toFixed","calculateTotalPortfolioValue","holdingsValue","removeTrade","tradeToRemove","deleteError","allTradesAfterDeletion","fetchAllTradesError","calculatedCapital","authListener","auth","onAuthStateChange","event","currentUser","checkSession","getSession","subscription","unsubscribe","allSymbols","t","keys","Boolean","interval","setInterval","clearInterval","contextValue","createElement","Provider","value","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","useTradingData"],"sources":["/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js"],"sourcesContent":["// src/TradingDataContext.js\nimport React, { createContext, useContext, useState, useEffect, useCallback, useMemo } from \"react\";\nimport { supabase } from \"./supabaseClient\";\nimport axios from \"axios\";\n\nconst TradingDataContext = createContext();\n\n// Constants for API Key and Currency Symbol - Replace with your actual values\nconst FINNHUB_API_KEY = process.env.REACT_APP_FINNHUB_API_KEY || \"YOUR_FINNHUB_API_KEY\"; // Get from .env or replace\nconst CURRENCY_SYMBOL = process.env.REACT_APP_CURRENCY_SYMBOL || \"$\"; // Get from .env or replace\n\n// Helper to check if API key is valid (simple check)\nconst isInvalidApiKey = (key) => {\n  return !key || key === \"YOUR_FINNHUB_API_KEY\" || key.length < 10; // Basic check\n};\n\nexport const TradingDataProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [trades, setTrades] = useState([]);\n  const [capital, setCapital] = useState(10000); // Initial capital\n  const [livePrices, setLivePrices] = useState({});\n  const [availableSymbols, setAvailableSymbols] = useState([]);\n  const [symbolError, setSymbolError] = useState(\"\");\n  const [loadingData, setLoadingData] = useState(true);\n  const [session, setSession] = useState(null); // Supabase session\n  const [watchListSymbols, setWatchListSymbols] = useState([]); // NEW STATE for watchlist symbols <-- ADD THIS\n\n  // --- Helper to fetch user's capital from Supabase ---\n  const fetchCapital = useCallback(async (userId) => {\n    if (!userId) {\n      // console.warn(\"fetchCapital: No user ID provided. Setting default capital.\");\n      setCapital(10000); // Reset to default if no user\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { data, error } = await supabase\n        .from(\"user_profiles\")\n        .select(\"capital\")\n        .eq(\"user_id\", userId)\n        .single();\n\n      if (error && error.code !== 'PGRST116') { // PGRST116 means no rows found (new user)\n        throw error;\n      }\n\n      if (data) {\n        setCapital(data.capital);\n      } else {\n        // If no profile exists, create one with default capital\n        const { data: newProfile, error: insertError } = await supabase\n          .from(\"user_profiles\")\n          .insert([{ user_id: userId, capital: 10000 }])\n          .select(\"capital\")\n          .single();\n\n        if (insertError) throw insertError;\n        setCapital(newProfile.capital);\n      }\n    } catch (error) {\n      console.error(\"Error fetching or setting capital:\", error.message);\n      // Fallback to default capital if DB operation fails\n      setCapital(10000);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Function to update capital in Supabase ---\n  const updateCapitalInDb = useCallback(async (newCapital, userId) => {\n    if (!userId) {\n      console.warn(\"updateCapitalInDb: No user ID, not updating DB.\");\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { error } = await supabase\n        .from(\"user_profiles\")\n        .update({ capital: newCapital })\n        .eq(\"user_id\", userId);\n\n      if (error) throw error;\n      setCapital(newCapital); // Update local state only after successful DB update\n    } catch (error) {\n      console.error(\"Error updating capital in DB:\", error.message);\n      // You might want to revert the local state or show an error to the user\n      // if the DB update fails, or trigger a re-fetch.\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Wrapped setCapital to update DB as well ---\n  const handleSetCapital = useCallback(async (newCapital) => {\n    // Optimistic update\n    setCapital(newCapital);\n    // Then attempt to update DB\n    if (user?.id) {\n      await updateCapitalInDb(newCapital, user.id);\n    } else {\n      console.warn(\"No user ID available for DB capital update.\");\n    }\n  }, [user, updateCapitalInDb]);\n\n  // --- Fetch trades for the current user ---\n  const fetchTrades = useCallback(async (userId) => {\n    if (!userId) {\n      setTrades([]); // Clear trades if no user\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { data, error } = await supabase\n        .from(\"trades\")\n        .select(\"*\")\n        .eq(\"user_id\", userId)\n        .order(\"created_at\", { ascending: false });\n\n      if (error) throw error;\n      setTrades(data);\n    } catch (error) {\n      console.error(\"Error fetching trades:\", error.message);\n      setTrades([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- NEW: Fetch watchlist symbols for the current user ---\n  const fetchWatchlist = useCallback(async (userId) => {\n    if (!userId) {\n      setWatchListSymbols([]);\n      return;\n    }\n    try {\n      const { data, error } = await supabase\n        .from(\"watchlists\")\n        .select(\"symbol\")\n        .eq(\"user_id\", userId)\n        .order(\"created_at\", { ascending: true }); // Order by creation for consistent display\n\n      if (error) throw error;\n      setWatchListSymbols(data.map(item => item.symbol));\n    } catch (error) {\n      console.error(\"Error fetching watchlist:\", error.message);\n      setWatchListSymbols([]);\n    }\n  }, []); // <-- ADD THIS FUNCTION\n\n  // --- NEW: Add symbol to watchlist ---\n  const addToWatchlist = useCallback(async (symbol) => {\n    if (!user?.id) {\n      throw new Error(\"User not authenticated.\");\n    }\n    const normalizedSymbol = symbol.toUpperCase();\n    if (watchListSymbols.includes(normalizedSymbol)) {\n      throw new Error(`'${normalizedSymbol}' is already in your watchlist.`);\n    }\n\n    try {\n      const { data, error } = await supabase\n        .from(\"watchlists\")\n        .insert([{ user_id: user.id, symbol: normalizedSymbol }])\n        .select(\"symbol\")\n        .single();\n\n      if (error) throw error;\n      setWatchListSymbols((prev) => [...prev, data.symbol]);\n      // Also fetch live price for this new symbol\n      fetchLivePrices([normalizedSymbol]);\n    } catch (error) {\n      console.error(\"Error adding to watchlist:\", error.message);\n      throw error; // Re-throw to be handled by UI\n    }\n  }, [user, watchListSymbols, fetchLivePrices]); // <-- ADD THIS FUNCTION\n\n  // --- NEW: Remove symbol from watchlist ---\n  const removeFromWatchlist = useCallback(async (symbol) => {\n    if (!user?.id) {\n      throw new Error(\"User not authenticated.\");\n    }\n    try {\n      const { error } = await supabase\n        .from(\"watchlists\")\n        .delete()\n        .eq(\"user_id\", user.id)\n        .eq(\"symbol\", symbol.toUpperCase());\n\n      if (error) throw error;\n      setWatchListSymbols((prev) => prev.filter((s) => s !== symbol.toUpperCase()));\n      // Optionally remove price from livePrices if it's no longer needed anywhere else\n      setLivePrices((prev) => {\n        const newPrices = { ...prev };\n        delete newPrices[symbol.toUpperCase()];\n        return newPrices;\n      });\n    } catch (error) {\n      console.error(\"Error removing from watchlist:\", error.message);\n      throw error; // Re-throw to be handled by UI\n    }\n  }, [user]); // <-- ADD THIS FUNCTION\n\n  // --- Fetch live prices for a given list of symbols ---\n  const fetchLivePrices = useCallback(async (symbolsToFetch) => {\n    // Filter out invalid symbols or duplicates\n    const uniqueSymbols = [...new Set(symbolsToFetch)].filter(s => s && typeof s === 'string');\n\n    if (uniqueSymbols.length === 0 || isInvalidApiKey(FINNHUB_API_KEY)) {\n      setLivePrices((prev) => { // Clear prices for symbols not being fetched\n        const newPrices = {};\n        // Keep existing prices if they're for symbols currently being watched/held\n        // This logic needs to be careful not to remove valid prices if the input is empty\n        // For simplicity, if symbolsToFetch is empty, we don't update prices here.\n        if (uniqueSymbols.length === 0) return prev;\n\n        // If specific symbols are requested, only keep those\n        uniqueSymbols.forEach(sym => {\n            if (prev[sym]) newPrices[sym] = prev[sym];\n        });\n        return newPrices;\n      });\n      return;\n    }\n\n    try {\n      const responses = await Promise.all(\n        uniqueSymbols.map((symbol) =>\n          axios.get(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`)\n        )\n      );\n\n      const newPrices = {};\n      responses.forEach((res, index) => {\n        const symbol = uniqueSymbols[index];\n        if (res.data && res.data.c !== 0) { // 'c' is current price, 0 often means no data\n          newPrices[symbol] = res.data.c;\n        } else {\n          newPrices[symbol] = null; // Mark as unavailable\n        }\n      });\n\n      setLivePrices((prev) => ({ ...prev, ...newPrices }));\n    } catch (error) {\n      console.error(\"Error fetching live prices:\", error);\n      // Mark all requested symbols as unavailable on error\n      const errorPrices = {};\n      uniqueSymbols.forEach(symbol => { errorPrices[symbol] = null; });\n      setLivePrices((prev) => ({ ...prev, ...errorPrices }));\n    }\n  }, [FINNHUB_API_KEY]);\n\n\n  // --- Fetch available US stock symbols from Finnhub ---\n  const fetchAvailableSymbols = useCallback(async () => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      setSymbolError(\"Invalid Finnhub API Key. Cannot fetch US stock symbols.\");\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { data } = await axios.get(\n        `https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`\n      );\n      // Filter for common stock types (e.g., 'Common Stock', 'ADR', 'REIT', 'ETP')\n      const filteredSymbols = data\n        .filter(\n          (s) =>\n            s.type === \"Common Stock\" ||\n            s.type === \"ADR\" ||\n            s.type === \"REIT\" ||\n            s.type === \"ETP\" ||\n            s.type === \"ETF\"\n        )\n        .map((s) => s.symbol)\n        .sort(); // Sort alphabetically\n\n      setAvailableSymbols(filteredSymbols);\n      setSymbolError(\"\"); // Clear any previous errors\n    } catch (error) {\n      console.error(\"Error fetching available symbols:\", error);\n      setSymbolError(\n        \"Failed to fetch US stock symbols. This might be due to API rate limits or an invalid Finnhub API key (free tier keys have limited symbol access).\"\n      );\n      setAvailableSymbols([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, [FINNHUB_API_KEY]);\n\n\n  // --- Calculate PnL and Holdings ---\n  const calculatePnL = useCallback(() => {\n    let holdings = {};\n    let totalRealizedPnl = 0;\n\n    trades.forEach((trade) => {\n      if (!holdings[trade.symbol]) {\n        holdings[trade.symbol] = {\n          symbol: trade.symbol,\n          netQty: 0,\n          totalCost: 0,\n          avgBuyPrice: 0,\n        };\n      }\n\n      if (trade.type === \"buy\") {\n        holdings[trade.symbol].totalCost += trade.quantity * trade.price;\n        holdings[trade.symbol].netQty += trade.quantity;\n        holdings[trade.symbol].avgBuyPrice =\n          holdings[trade.symbol].totalCost / holdings[trade.symbol].netQty;\n      } else {\n        // Sell logic: Calculate realized P&L based on average buy price\n        const { netQty: currentNetQty, avgBuyPrice } = holdings[trade.symbol];\n        if (currentNetQty > 0) {\n          const sellProfit = (trade.price - avgBuyPrice) * trade.quantity;\n          totalRealizedPnl += sellProfit;\n        }\n        holdings[trade.symbol].netQty -= trade.quantity;\n        // If netQty becomes 0 or negative, reset cost/avg price\n        if (holdings[trade.symbol].netQty <= 0) {\n          holdings[trade.symbol].totalCost = 0;\n          holdings[trade.symbol].avgBuyPrice = 0;\n        } else {\n          // If selling partial, totalCost needs to be adjusted proportionally\n          holdings[trade.symbol].totalCost = holdings[trade.symbol].netQty * holdings[trade.symbol].avgBuyPrice;\n        }\n      }\n    });\n\n    let totalUnrealizedPnl = 0;\n    // Calculate unrealized P&L for current holdings\n    Object.values(holdings).forEach((holding) => {\n      if (holding.netQty > 0 && livePrices[holding.symbol]) {\n        const livePrice = livePrices[holding.symbol];\n        const unrealized = (livePrice - holding.avgBuyPrice) * holding.netQty;\n        holding.unrealizedPnl = unrealized.toFixed(2);\n        totalUnrealizedPnl += unrealized;\n      } else {\n        holding.unrealizedPnl = \"0.00\";\n      }\n    });\n\n    return {\n      holdings: Object.values(holdings),\n      totalRealizedPnl: totalRealizedPnl.toFixed(2),\n      totalUnrealizedPnl: totalUnrealizedPnl.toFixed(2),\n    };\n  }, [trades, livePrices]);\n\n  // --- Calculate total portfolio value ---\n  const calculateTotalPortfolioValue = useCallback(() => {\n    const { holdings } = calculatePnL();\n    let holdingsValue = 0;\n    holdings.forEach(holding => {\n      if (holding.netQty > 0 && livePrices[holding.symbol]) {\n        holdingsValue += holding.netQty * livePrices[holding.symbol];\n      }\n    });\n    return (capital + holdingsValue).toFixed(2);\n  }, [capital, calculatePnL, livePrices]);\n\n\n  // --- NEW: Remove trade logic ---\n  const removeTrade = useCallback(async (tradeToRemove) => {\n    if (!user?.id) throw new Error(\"User not authenticated.\");\n\n    try {\n      const { error: deleteError } = await supabase\n        .from(\"trades\")\n        .delete()\n        .eq(\"id\", tradeToRemove.id)\n        .eq(\"user_id\", user.id); // Ensure user owns the trade\n\n      if (deleteError) throw deleteError;\n\n      // Re-fetch all trades to get the accurate state after deletion\n      // and recalculate capital based on the new trade history\n      await fetchTrades(user.id);\n\n      // Re-calculate capital based on the *entire* trade history from scratch\n      // This is the safest way to ensure capital is correct after a trade is removed.\n      const { data: allTradesAfterDeletion, error: fetchAllTradesError } = await supabase\n          .from(\"trades\")\n          .select(\"*\")\n          .eq(\"user_id\", user.id)\n          .order(\"created_at\", { ascending: true }); // Need historical order for accurate capital calculation\n\n      if (fetchAllTradesError) throw fetchAllTradesError;\n\n      let calculatedCapital = 10000; // Start with initial capital\n      allTradesAfterDeletion.forEach(trade => {\n          if (trade.type === 'buy') {\n              calculatedCapital -= (trade.quantity * trade.price);\n          } else { // sell\n              calculatedCapital += (trade.quantity * trade.price);\n          }\n      });\n\n      await handleSetCapital(calculatedCapital); // Update capital in DB and local state\n      \n      // Since trades are re-fetched, the calculatePnL in consuming components will also update.\n\n    } catch (error) {\n      console.error(\"Error removing trade:\", error.message);\n      throw error;\n    }\n  }, [user, fetchTrades, handleSetCapital]);\n\n\n  // --- Initial Data Load on Mount or User Change ---\n  useEffect(() => {\n    const { data: authListener } = supabase.auth.onAuthStateChange(\n      async (event, session) => {\n        setSession(session);\n        const currentUser = session?.user || null;\n        setUser(currentUser);\n\n        if (currentUser) {\n          setLoadingData(true);\n          await fetchCapital(currentUser.id);\n          await fetchTrades(currentUser.id);\n          await fetchWatchlist(currentUser.id); // NEW: Fetch watchlist <-- ADD THIS\n          setLoadingData(false);\n        } else {\n          // Clear states if user logs out\n          setCapital(10000);\n          setTrades([]);\n          setWatchListSymbols([]); // NEW: Clear watchlist <-- ADD THIS\n          setLivePrices({});\n          setUser(null);\n          setLoadingData(false);\n        }\n      }\n    );\n\n    // Initial check for session\n    const checkSession = async () => {\n      setLoadingData(true);\n      const { data: { session } } = await supabase.auth.getSession();\n      setSession(session);\n      const currentUser = session?.user || null;\n      setUser(currentUser);\n\n      if (currentUser) {\n        await fetchCapital(currentUser.id);\n        await fetchTrades(currentUser.id);\n        await fetchWatchlist(currentUser.id); // NEW: Fetch watchlist <-- ADD THIS\n      }\n      setLoadingData(false);\n    };\n\n    checkSession();\n    fetchAvailableSymbols(); // Fetch symbols once on load\n\n    return () => {\n      authListener.subscription.unsubscribe();\n    };\n  }, [fetchCapital, fetchTrades, fetchAvailableSymbols, fetchWatchlist]); // Add fetchWatchlist to dependencies\n\n  // --- Effect to fetch live prices for all relevant symbols ---\n  useEffect(() => {\n    // Collect all unique symbols from trades and watchlist\n    const allSymbols = [\n      ...new Set([\n        ...trades.map((t) => t.symbol),\n        ...watchListSymbols, // NEW: Include watchlist symbols <-- ADD THIS\n        ...Object.keys(livePrices) // Keep previously fetched symbols\n      ])\n    ].filter(Boolean); // Filter out any null/undefined symbols\n\n    if (allSymbols.length > 0) {\n      fetchLivePrices(allSymbols);\n\n      // Set up an interval for live price updates (e.g., every 15-30 seconds)\n      const interval = setInterval(() => {\n        fetchLivePrices(allSymbols);\n      }, 20000); // Update every 20 seconds\n\n      return () => clearInterval(interval); // Cleanup interval\n    }\n  }, [trades, watchListSymbols, fetchLivePrices]); // Add watchlistSymbols to dependencies <-- ADD THIS\n\n\n  // Memoize the context value to prevent unnecessary re-renders\n  const contextValue = useMemo(\n    () => ({\n      user,\n      trades,\n      capital,\n      setCapital: handleSetCapital, // Use the wrapped setter\n      livePrices,\n      availableSymbols,\n      symbolError,\n      setSymbolError,\n      fetchTrades,\n      fetchLivePrices,\n      calculatePnL,\n      calculateTotalPortfolioValue,\n      isInvalidApiKey,\n      FINNHUB_API_KEY,\n      CURRENCY_SYMBOL,\n      loadingData,\n      removeTrade,\n      watchListSymbols, // NEW: Add to context value <-- ADD THIS\n      addToWatchlist,   // NEW: Add to context value <-- ADD THIS\n      removeFromWatchlist, // NEW: Add to context value <-- ADD THIS\n    }),\n    [\n      user,\n      trades,\n      capital,\n      handleSetCapital,\n      livePrices,\n      availableSymbols,\n      symbolError,\n      setSymbolError,\n      fetchTrades,\n      fetchLivePrices,\n      calculatePnL,\n      calculateTotalPortfolioValue,\n      isInvalidApiKey,\n      FINNHUB_API_KEY,\n      CURRENCY_SYMBOL,\n      loadingData,\n      removeTrade,\n      watchListSymbols, // <-- ADD THIS\n      addToWatchlist,   // <-- ADD THIS\n      removeFromWatchlist, // <-- ADD THIS\n    ]\n  );\n\n  return (\n    <TradingDataContext.Provider value={contextValue}>\n      {children}\n    </TradingDataContext.Provider>\n  );\n};\n\nexport const useTradingData = () => useContext(TradingDataContext);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}