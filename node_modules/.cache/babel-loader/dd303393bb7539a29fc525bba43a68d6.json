{"ast":null,"code":"var _jsxFileName = \"/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js\";\nimport React, { createContext, useState, useEffect, useCallback } from 'react';\nimport { supabase } from './supabaseClient'; // Make sure supabase is imported here if used\n\n// --- IMPORTANT: Ensure TradingContext is EXPORTED here ---\nexport const TradingContext = createContext();\nexport const TradingDataProvider = ({\n  children,\n  user\n}) => {\n  // --- Your existing states and functions for the context ---\n  const [userCapital, setUserCapital] = useState(0);\n  const [trades, setTrades] = useState([]);\n  const [availableSymbols, setAvailableSymbols] = useState([]);\n  const [livePrices, setLivePrices] = useState({});\n  const [symbolError, setSymbolError] = useState(null);\n  const [isApiLimitExceeded, setIsApiLimitExceeded] = useState(false); // Make sure this is present\n\n  // Memoized function to fetch user capital from Supabase\n  const fetchUserCapital = useCallback(async () => {\n    if (!user || !user.id) {\n      // console.log(\"fetchUserCapital: No user or user ID available, skipping.\"); // Removed unnecessary console.log\n      return;\n    }\n    try {\n      // console.log(\"fetchUserCapital: Fetching capital for user ID:\", user.id); // Removed unnecessary console.log\n      const {\n        data: profile,\n        error\n      } = await supabase.from('profiles').select('paper_trading_capital').eq('id', user.id).single();\n      if (error && error.message !== 'No rows found') {\n        // Handle specific error for no rows\n        console.error(\"Error fetching user profile:\", error);\n        // If no rows found, create a new profile for the user with default capital\n        if (error.code === 'PGRST116' || error.message.includes('No rows found')) {\n          // PGRST116 is common for single() with no rows\n          console.log(\"No profile found, creating new one for user:\", user.id);\n          const initialCapital = 100000.00; // Default starting capital\n          const {\n            error: insertError\n          } = await supabase.from('profiles').insert([{\n            id: user.id,\n            paper_trading_capital: initialCapital\n          }]);\n          if (insertError) {\n            console.error(\"Error inserting new profile:\", insertError);\n          } else {\n            setUserCapital(initialCapital);\n            // console.log(\"New profile created with capital:\", initialCapital); // Removed unnecessary console.log\n          }\n        } else {\n          // General error\n          console.error(\"Error fetching user profile:\", error);\n        }\n      } else if (profile) {\n        setUserCapital(profile.paper_trading_capital || 0);\n        // console.log(\"User capital fetched:\", profile.paper_trading_capital); // Removed unnecessary console.log\n      }\n    } catch (error) {\n      console.error(\"Unexpected error in fetchUserCapital:\", error);\n    }\n  }, [user]);\n\n  // Memoized function to fetch trades\n  const fetchTrades = useCallback(async () => {\n    if (!user || !user.id) return;\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('trades').select('*').eq('user_id', user.id).order('created_at', {\n        ascending: false\n      });\n      if (error) throw error;\n      setTrades(data || []);\n      // console.log(\"Trades fetched:\", data); // Removed unnecessary console.log\n    } catch (error) {\n      console.error(\"Error fetching trades:\", error);\n    }\n  }, [user]);\n\n  // Memoized function to fetch available symbols (usually only once or rarely)\n  const fetchAvailableSymbols = useCallback(async () => {\n    try {\n      // Check if symbols are already loaded or if there's a cached version in local storage\n      const cachedSymbols = localStorage.getItem('finnhub_symbols');\n      const lastFetchTime = localStorage.getItem('finnhub_symbols_last_fetch');\n      const oneDay = 24 * 60 * 60 * 1000; // 1 day in milliseconds\n\n      if (cachedSymbols && lastFetchTime && Date.now() - parseInt(lastFetchTime) < oneDay) {\n        setAvailableSymbols(JSON.parse(cachedSymbols));\n        return; // Use cached data\n      }\n\n      // If not cached or stale, fetch from Finnhub\n      const FINNHUB_API_KEY = process.env.REACT_APP_FINNHUB_API_KEY; // Ensure this is set in .env\n      if (!FINNHUB_API_KEY) {\n        setSymbolError(\"Finnhub API Key is not configured. Please set REACT_APP_FINNHUB_API_KEY in your .env file.\");\n        setIsApiLimitExceeded(true); // Treat as a blocking error\n        return;\n      }\n      const response = await fetch(`https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`);\n      if (!response.ok) {\n        // Handle API rate limit (429) specifically\n        if (response.status === 429) {\n          setSymbolError(`Finnhub API Error: Too Many Requests (429). Please wait for your quota to reset.`);\n          setIsApiLimitExceeded(true);\n        } else {\n          setSymbolError(`Failed to fetch symbols: ${response.statusText || 'Network error'}`);\n        }\n        throw new Error(`Finnhub API request failed with status ${response.status}`);\n      }\n      const data = await response.json();\n      const usSymbols = data.map(item => item.symbol);\n      setAvailableSymbols(usSymbols);\n      localStorage.setItem('finnhub_symbols', JSON.stringify(usSymbols));\n      localStorage.setItem('finnhub_symbols_last_fetch', Date.now().toString());\n      // console.log(\"Available symbols fetched and cached.\"); // Removed unnecessary console.log\n    } catch (error) {\n      console.error(\"Error fetching available symbols:\", error);\n      // setSymbolError(error.message); // Already handled by more specific messages above\n      // If it's a general network error, ensure API limit flag is reset if it wasn't a 429\n      if (error.message && !error.message.includes(\"429\")) {\n        setIsApiLimitExceeded(false); // Not an API limit issue\n      }\n    }\n  }, []);\n\n  // Memoized function to fetch live prices\n  const fetchLivePrices = useCallback(async symbolsToFetch => {\n    if (!symbolsToFetch || symbolsToFetch.length === 0) {\n      setLivePrices({});\n      return;\n    }\n    try {\n      setIsApiLimitExceeded(false); // Reset this state before fetching\n      setSymbolError(null); // Clear previous errors\n\n      const FINNHUB_API_KEY = process.env.REACT_APP_FINNHUB_API_KEY;\n      if (!FINNHUB_API_KEY) {\n        setSymbolError(\"Finnhub API Key is not configured.\");\n        setIsApiLimitExceeded(true);\n        return;\n      }\n\n      // Finnhub's quote endpoint is for individual symbols\n      // We need to loop or use their WebSocket for multiple symbols (more complex)\n      // For now, let's make individual calls or handle batches if Finnhub supports it in one go.\n      // Assuming 'quote' endpoint\n      const newPrices = {};\n      for (const symbol of symbolsToFetch) {\n        const response = await fetch(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`);\n        if (!response.ok) {\n          if (response.status === 429) {\n            setSymbolError(`Finnhub API Error: Too Many Requests (429). Live prices might be delayed.`);\n            setIsApiLimitExceeded(true);\n            console.error(`Finnhub 429 for ${symbol}`);\n            // Break or return if 429 to avoid further blocked requests\n            return;\n          }\n          console.warn(`Failed to fetch quote for ${symbol}: ${response.statusText}`);\n          continue; // Skip to next symbol if error\n        }\n        const data = await response.json();\n        if (data && data.c) {\n          // 'c' is the current price\n          newPrices[symbol] = data.c;\n        }\n      }\n      setLivePrices(prevPrices => ({\n        ...prevPrices,\n        ...newPrices\n      }));\n      // console.log(\"Live prices fetched:\", newPrices); // Removed unnecessary console.log\n    } catch (error) {\n      console.error(\"Error fetching live prices:\", error);\n      setSymbolError(`Failed to fetch live prices: ${error.message || 'Network error'}`);\n    }\n  }, []);\n\n  // Unified data refresh function\n  const refreshData = useCallback(async () => {\n    await fetchUserCapital();\n    await fetchTrades();\n    await fetchAvailableSymbols();\n    // Live prices will be fetched based on current holdings after trades are loaded\n  }, [fetchUserCapital, fetchTrades, fetchAvailableSymbols]);\n\n  // Effect to fetch live prices based on current holdings\n  useEffect(() => {\n    if (trades.length > 0) {\n      const uniqueSymbolsInTrades = [...new Set(trades.map(trade => trade.symbol))];\n      // console.log(\"Attempting to fetch live prices for symbols:\", uniqueSymbolsInTrades); // Removed unnecessary console.log\n      fetchLivePrices(uniqueSymbolsInTrades);\n\n      // Set up an interval to refresh live prices every 10-15 seconds (adjust as needed)\n      // Be mindful of Finnhub API limits with this interval\n      const intervalId = setInterval(() => {\n        fetchLivePrices(uniqueSymbolsInTrades);\n      }, 15000); // Fetch every 15 seconds\n\n      return () => clearInterval(intervalId); // Clear interval on unmount or dependency change\n    } else {\n      setLivePrices({}); // Clear live prices if no trades\n    }\n  }, [trades, fetchLivePrices]); // Re-run when trades change or fetchLivePrices changes\n\n  // --- Context Provider value ---\n  const contextValue = {\n    userCapital,\n    setUserCapital,\n    // Provide setter if needed directly by components\n    fetchUserCapital,\n    trades,\n    setTrades,\n    // Provide setter if needed directly by components\n    fetchTrades,\n    availableSymbols,\n    setAvailableSymbols,\n    // Provide setter if needed directly by components\n    fetchAvailableSymbols,\n    livePrices,\n    setLivePrices,\n    // Provide setter if needed directly by components\n    fetchLivePrices,\n    symbolError,\n    setSymbolError,\n    isApiLimitExceeded,\n    setIsApiLimitExceeded,\n    refreshData // Expose the unified refresh function\n  };\n  return /*#__PURE__*/React.createElement(TradingContext.Provider, {\n    value: contextValue,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 231,\n      columnNumber: 5\n    }\n  }, children);\n};","map":{"version":3,"names":["React","createContext","useState","useEffect","useCallback","supabase","TradingContext","TradingDataProvider","children","user","userCapital","setUserCapital","trades","setTrades","availableSymbols","setAvailableSymbols","livePrices","setLivePrices","symbolError","setSymbolError","isApiLimitExceeded","setIsApiLimitExceeded","fetchUserCapital","id","data","profile","error","from","select","eq","single","message","console","code","includes","log","initialCapital","insertError","insert","paper_trading_capital","fetchTrades","order","ascending","fetchAvailableSymbols","cachedSymbols","localStorage","getItem","lastFetchTime","oneDay","Date","now","parseInt","JSON","parse","FINNHUB_API_KEY","process","env","REACT_APP_FINNHUB_API_KEY","response","fetch","ok","status","statusText","Error","json","usSymbols","map","item","symbol","setItem","stringify","toString","fetchLivePrices","symbolsToFetch","length","newPrices","warn","c","prevPrices","refreshData","uniqueSymbolsInTrades","Set","trade","intervalId","setInterval","clearInterval","contextValue","createElement","Provider","value","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js"],"sourcesContent":["import React, { createContext, useState, useEffect, useCallback } from 'react';\nimport { supabase } from './supabaseClient'; // Make sure supabase is imported here if used\n\n// --- IMPORTANT: Ensure TradingContext is EXPORTED here ---\nexport const TradingContext = createContext();\n\nexport const TradingDataProvider = ({ children, user }) => {\n  // --- Your existing states and functions for the context ---\n  const [userCapital, setUserCapital] = useState(0);\n  const [trades, setTrades] = useState([]);\n  const [availableSymbols, setAvailableSymbols] = useState([]);\n  const [livePrices, setLivePrices] = useState({});\n  const [symbolError, setSymbolError] = useState(null);\n  const [isApiLimitExceeded, setIsApiLimitExceeded] = useState(false); // Make sure this is present\n\n  // Memoized function to fetch user capital from Supabase\n  const fetchUserCapital = useCallback(async () => {\n    if (!user || !user.id) {\n      // console.log(\"fetchUserCapital: No user or user ID available, skipping.\"); // Removed unnecessary console.log\n      return;\n    }\n    try {\n      // console.log(\"fetchUserCapital: Fetching capital for user ID:\", user.id); // Removed unnecessary console.log\n      const { data: profile, error } = await supabase\n        .from('profiles')\n        .select('paper_trading_capital')\n        .eq('id', user.id)\n        .single();\n\n      if (error && error.message !== 'No rows found') { // Handle specific error for no rows\n        console.error(\"Error fetching user profile:\", error);\n        // If no rows found, create a new profile for the user with default capital\n        if (error.code === 'PGRST116' || error.message.includes('No rows found')) { // PGRST116 is common for single() with no rows\n            console.log(\"No profile found, creating new one for user:\", user.id);\n            const initialCapital = 100000.00; // Default starting capital\n            const { error: insertError } = await supabase\n                .from('profiles')\n                .insert([{ id: user.id, paper_trading_capital: initialCapital }]);\n\n            if (insertError) {\n                console.error(\"Error inserting new profile:\", insertError);\n            } else {\n                setUserCapital(initialCapital);\n                // console.log(\"New profile created with capital:\", initialCapital); // Removed unnecessary console.log\n            }\n        } else {\n            // General error\n            console.error(\"Error fetching user profile:\", error);\n        }\n      } else if (profile) {\n        setUserCapital(profile.paper_trading_capital || 0);\n        // console.log(\"User capital fetched:\", profile.paper_trading_capital); // Removed unnecessary console.log\n      }\n    } catch (error) {\n      console.error(\"Unexpected error in fetchUserCapital:\", error);\n    }\n  }, [user]);\n\n  // Memoized function to fetch trades\n  const fetchTrades = useCallback(async () => {\n    if (!user || !user.id) return;\n    try {\n      const { data, error } = await supabase\n        .from('trades')\n        .select('*')\n        .eq('user_id', user.id)\n        .order('created_at', { ascending: false });\n\n      if (error) throw error;\n      setTrades(data || []);\n      // console.log(\"Trades fetched:\", data); // Removed unnecessary console.log\n    } catch (error) {\n      console.error(\"Error fetching trades:\", error);\n    }\n  }, [user]);\n\n  // Memoized function to fetch available symbols (usually only once or rarely)\n  const fetchAvailableSymbols = useCallback(async () => {\n    try {\n      // Check if symbols are already loaded or if there's a cached version in local storage\n      const cachedSymbols = localStorage.getItem('finnhub_symbols');\n      const lastFetchTime = localStorage.getItem('finnhub_symbols_last_fetch');\n      const oneDay = 24 * 60 * 60 * 1000; // 1 day in milliseconds\n\n      if (cachedSymbols && lastFetchTime && (Date.now() - parseInt(lastFetchTime) < oneDay)) {\n        setAvailableSymbols(JSON.parse(cachedSymbols));\n        return; // Use cached data\n      }\n\n      // If not cached or stale, fetch from Finnhub\n      const FINNHUB_API_KEY = process.env.REACT_APP_FINNHUB_API_KEY; // Ensure this is set in .env\n      if (!FINNHUB_API_KEY) {\n        setSymbolError(\"Finnhub API Key is not configured. Please set REACT_APP_FINNHUB_API_KEY in your .env file.\");\n        setIsApiLimitExceeded(true); // Treat as a blocking error\n        return;\n      }\n\n      const response = await fetch(\n        `https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`\n      );\n\n      if (!response.ok) {\n        // Handle API rate limit (429) specifically\n        if (response.status === 429) {\n          setSymbolError(`Finnhub API Error: Too Many Requests (429). Please wait for your quota to reset.`);\n          setIsApiLimitExceeded(true);\n        } else {\n          setSymbolError(`Failed to fetch symbols: ${response.statusText || 'Network error'}`);\n        }\n        throw new Error(`Finnhub API request failed with status ${response.status}`);\n      }\n\n      const data = await response.json();\n      const usSymbols = data.map(item => item.symbol);\n      setAvailableSymbols(usSymbols);\n      localStorage.setItem('finnhub_symbols', JSON.stringify(usSymbols));\n      localStorage.setItem('finnhub_symbols_last_fetch', Date.now().toString());\n      // console.log(\"Available symbols fetched and cached.\"); // Removed unnecessary console.log\n    } catch (error) {\n      console.error(\"Error fetching available symbols:\", error);\n      // setSymbolError(error.message); // Already handled by more specific messages above\n      // If it's a general network error, ensure API limit flag is reset if it wasn't a 429\n      if (error.message && !error.message.includes(\"429\")) {\n         setIsApiLimitExceeded(false); // Not an API limit issue\n      }\n    }\n  }, []);\n\n  // Memoized function to fetch live prices\n  const fetchLivePrices = useCallback(async (symbolsToFetch) => {\n    if (!symbolsToFetch || symbolsToFetch.length === 0) {\n      setLivePrices({});\n      return;\n    }\n    try {\n      setIsApiLimitExceeded(false); // Reset this state before fetching\n      setSymbolError(null); // Clear previous errors\n\n      const FINNHUB_API_KEY = process.env.REACT_APP_FINNHUB_API_KEY;\n      if (!FINNHUB_API_KEY) {\n        setSymbolError(\"Finnhub API Key is not configured.\");\n        setIsApiLimitExceeded(true);\n        return;\n      }\n\n      // Finnhub's quote endpoint is for individual symbols\n      // We need to loop or use their WebSocket for multiple symbols (more complex)\n      // For now, let's make individual calls or handle batches if Finnhub supports it in one go.\n      // Assuming 'quote' endpoint\n      const newPrices = {};\n      for (const symbol of symbolsToFetch) {\n        const response = await fetch(\n          `https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`\n        );\n\n        if (!response.ok) {\n          if (response.status === 429) {\n            setSymbolError(`Finnhub API Error: Too Many Requests (429). Live prices might be delayed.`);\n            setIsApiLimitExceeded(true);\n            console.error(`Finnhub 429 for ${symbol}`);\n            // Break or return if 429 to avoid further blocked requests\n            return;\n          }\n          console.warn(`Failed to fetch quote for ${symbol}: ${response.statusText}`);\n          continue; // Skip to next symbol if error\n        }\n        const data = await response.json();\n        if (data && data.c) { // 'c' is the current price\n          newPrices[symbol] = data.c;\n        }\n      }\n      setLivePrices(prevPrices => ({ ...prevPrices, ...newPrices }));\n      // console.log(\"Live prices fetched:\", newPrices); // Removed unnecessary console.log\n\n    } catch (error) {\n      console.error(\"Error fetching live prices:\", error);\n      setSymbolError(`Failed to fetch live prices: ${error.message || 'Network error'}`);\n    }\n  }, []);\n\n  // Unified data refresh function\n  const refreshData = useCallback(async () => {\n    await fetchUserCapital();\n    await fetchTrades();\n    await fetchAvailableSymbols();\n    // Live prices will be fetched based on current holdings after trades are loaded\n  }, [fetchUserCapital, fetchTrades, fetchAvailableSymbols]);\n\n  // Effect to fetch live prices based on current holdings\n  useEffect(() => {\n    if (trades.length > 0) {\n      const uniqueSymbolsInTrades = [...new Set(trades.map(trade => trade.symbol))];\n      // console.log(\"Attempting to fetch live prices for symbols:\", uniqueSymbolsInTrades); // Removed unnecessary console.log\n      fetchLivePrices(uniqueSymbolsInTrades);\n\n      // Set up an interval to refresh live prices every 10-15 seconds (adjust as needed)\n      // Be mindful of Finnhub API limits with this interval\n      const intervalId = setInterval(() => {\n        fetchLivePrices(uniqueSymbolsInTrades);\n      }, 15000); // Fetch every 15 seconds\n\n      return () => clearInterval(intervalId); // Clear interval on unmount or dependency change\n    } else {\n        setLivePrices({}); // Clear live prices if no trades\n    }\n  }, [trades, fetchLivePrices]); // Re-run when trades change or fetchLivePrices changes\n\n\n  // --- Context Provider value ---\n  const contextValue = {\n    userCapital,\n    setUserCapital, // Provide setter if needed directly by components\n    fetchUserCapital,\n    trades,\n    setTrades, // Provide setter if needed directly by components\n    fetchTrades,\n    availableSymbols,\n    setAvailableSymbols, // Provide setter if needed directly by components\n    fetchAvailableSymbols,\n    livePrices,\n    setLivePrices, // Provide setter if needed directly by components\n    fetchLivePrices,\n    symbolError,\n    setSymbolError,\n    isApiLimitExceeded,\n    setIsApiLimitExceeded,\n    refreshData, // Expose the unified refresh function\n  };\n\n  return (\n    <TradingContext.Provider value={contextValue}>\n      {children}\n    </TradingContext.Provider>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}