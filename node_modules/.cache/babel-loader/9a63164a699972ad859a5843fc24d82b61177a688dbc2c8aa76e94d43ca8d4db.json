{"ast":null,"code":"var _jsxFileName = \"/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// src/TradingDataContext.js\nimport React, { createContext, useContext, useState, useEffect, useCallback, useMemo } from \"react\";\nimport { supabase } from \"./supabaseClient\";\nimport axios from \"axios\";\n\n// Constants for API Key and Currency Symbol\n// WARNING: Hardcoding API keys directly in source code is not recommended for security.\n// Consider using environment variables (.env file) for production deployment.\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const FINNHUB_API_KEY = \"d108911r01qhkqr8ggb0d108911r01qhkqr8ggbg\"; // YOUR FINNHUB API KEY\nexport const ALPHA_VANTAGE_API_KEY = \"DR0O9MY1P0QU6ZEL\"; // YOUR ALPHA VANTAGE API KEY HERE\nexport const CURRENCY_SYMBOL = process.env.REACT_APP_CURRENCY_SYMBOL || \"$\";\n\n// Helper to check if API key is valid (simple check)\nexport const isInvalidApiKey = key => {\n  const trimmedKey = key ? key.trim() : '';\n  // Check for empty string, Finnhub placeholder, or Alpha Vantage placeholder\n  return !trimmedKey || trimmedKey === \"YOUR_FINNHUB_API_KEY_HERE\" || trimmedKey === \"YOUR_ALPHA_VANTAGE_API_KEY\" || trimmedKey.length < 10;\n};\nconst TradingDataContext = /*#__PURE__*/createContext();\nexport const TradingDataProvider = ({\n  children\n}) => {\n  _s();\n  const [user, setUser] = useState(null);\n  const [trades, setTrades] = useState([]);\n  const [capital, setCapital] = useState(10000); // Initial capital\n  const [livePrices, setLivePrices] = useState({});\n  const [availableSymbols, setAvailableSymbols] = useState([]);\n  const [symbolError, setSymbolError] = useState(\"\");\n  const [loadingData, setLoadingData] = useState(true);\n  const [session, setSession] = useState(null); // Supabase session\n  const [watchListSymbols, setWatchListSymbols] = useState([]);\n\n  // --- Fetch live prices for a given list of symbols (uses Finnhub) ---\n  const fetchLivePrices = useCallback(async symbolsToFetch => {\n    const uniqueSymbols = [...new Set(symbolsToFetch)].filter(s => s && typeof s === 'string');\n    if (uniqueSymbols.length === 0 || isInvalidApiKey(FINNHUB_API_KEY)) {\n      setLivePrices(prev => {\n        const newPrices = {};\n        if (uniqueSymbols.length === 0) return prev;\n        uniqueSymbols.forEach(sym => {\n          if (prev[sym]) newPrices[sym] = prev[sym];\n        });\n        return newPrices;\n      });\n      return;\n    }\n    try {\n      const responses = await Promise.all(uniqueSymbols.map(symbol => axios.get(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`)));\n      const newPrices = {};\n      responses.forEach((res, index) => {\n        const symbol = uniqueSymbols[index];\n        if (res.data && res.data.c !== 0) {\n          newPrices[symbol] = res.data.c;\n        } else {\n          newPrices[symbol] = null; // Mark as unavailable\n        }\n      });\n      setLivePrices(prev => ({\n        ...prev,\n        ...newPrices\n      }));\n    } catch (error) {\n      console.error(\"Error fetching live prices:\", error);\n      const errorPrices = {};\n      uniqueSymbols.forEach(symbol => {\n        errorPrices[symbol] = null;\n      });\n      setLivePrices(prev => ({\n        ...prev,\n        ...errorPrices\n      }));\n    }\n  }, []);\n\n  // --- Helper to fetch user's capital from Supabase ---\n  const fetchCapital = useCallback(async userId => {\n    if (!userId) {\n      setCapital(10000);\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"user_profiles\").select(\"capital\").eq(\"user_id\", userId).single();\n      if (error && error.code !== 'PGRST116') {\n        // PGRST116 means \"no row found\"\n        throw error;\n      }\n      if (data) {\n        setCapital(data.capital);\n      } else {\n        // If no profile exists, create one with initial capital\n        const {\n          data: newProfile,\n          error: insertError\n        } = await supabase.from(\"user_profiles\").insert([{\n          user_id: userId,\n          capital: 10000\n        }]).select(\"capital\").single();\n        if (insertError) throw insertError;\n        setCapital(newProfile.capital);\n      }\n    } catch (error) {\n      console.error(\"Error fetching or setting capital:\", error.message);\n      setCapital(10000); // Default to initial capital on error\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Function to update capital in Supabase ---\n  const updateCapitalInDb = useCallback(async (newCapital, userId) => {\n    if (!userId) {\n      console.warn(\"updateCapitalInDb: No user ID, not updating DB.\");\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        error\n      } = await supabase.from(\"user_profiles\").update({\n        capital: newCapital\n      }).eq(\"user_id\", userId);\n      if (error) throw error;\n      setCapital(newCapital); // Update local state after successful DB update\n    } catch (error) {\n      console.error(\"Error updating capital in DB:\", error.message);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Wrapped setCapital to update DB as well ---\n  const handleSetCapital = useCallback(async newCapital => {\n    setCapital(newCapital); // Optimistically update local state\n    if (user !== null && user !== void 0 && user.id) {\n      await updateCapitalInDb(newCapital, user.id);\n    } else {\n      console.warn(\"No user ID available for DB capital update.\");\n    }\n  }, [user, updateCapitalInDb]);\n\n  // --- Fetch trades for the current user ---\n  const fetchTrades = useCallback(async userId => {\n    if (!userId) {\n      setTrades([]);\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"trades\").select(\"*\").eq(\"user_id\", userId).order(\"created_at\", {\n        ascending: false\n      });\n      if (error) throw error;\n      setTrades(data);\n    } catch (error) {\n      console.error(\"Error fetching trades:\", error.message);\n      setTrades([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Fetch watchlist symbols for the current user ---\n  const fetchWatchlist = useCallback(async userId => {\n    if (!userId) {\n      setWatchListSymbols([]);\n      return;\n    }\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"watchlists\").select(\"symbol\").eq(\"user_id\", userId).order(\"created_at\", {\n        ascending: true\n      });\n      if (error) throw error;\n      setWatchListSymbols(data.map(item => item.symbol));\n    } catch (error) {\n      console.error(\"Error fetching watchlist:\", error.message);\n      setWatchListSymbols([]);\n    }\n  }, []);\n\n  // --- Add symbol to watchlist ---\n  const addToWatchlist = useCallback(async symbol => {\n    if (!(user !== null && user !== void 0 && user.id)) {\n      throw new Error(\"User not authenticated.\");\n    }\n    const normalizedSymbol = symbol.toUpperCase();\n    if (watchListSymbols.includes(normalizedSymbol)) {\n      throw new Error(`'${normalizedSymbol}' is already in your watchlist.`);\n    }\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(\"watchlists\").insert([{\n        user_id: user.id,\n        symbol: normalizedSymbol\n      }]).select(\"symbol\").single();\n      if (error) throw error;\n      setWatchListSymbols(prev => [...prev, data.symbol]);\n      fetchLivePrices([normalizedSymbol]);\n    } catch (error) {\n      console.error(\"Error adding to watchlist:\", error.message);\n      throw error;\n    }\n  }, [user, watchListSymbols, fetchLivePrices]);\n\n  // --- Remove symbol from watchlist ---\n  const removeFromWatchlist = useCallback(async symbol => {\n    if (!(user !== null && user !== void 0 && user.id)) {\n      throw new Error(\"User not authenticated.\");\n    }\n    try {\n      const {\n        error\n      } = await supabase.from(\"watchlists\").delete().eq(\"user_id\", user.id).eq(\"symbol\", symbol.toUpperCase());\n      if (error) throw error;\n      setWatchListSymbols(prev => prev.filter(s => s !== symbol.toUpperCase()));\n      setLivePrices(prev => {\n        // Clear live price for removed symbol if not needed elsewhere\n        const newPrices = {\n          ...prev\n        };\n        delete newPrices[symbol.toUpperCase()];\n        return newPrices;\n      });\n    } catch (error) {\n      console.error(\"Error removing from watchlist:\", error.message);\n      throw error;\n    }\n  }, [user]);\n\n  // --- Fetch available US stock symbols from Finnhub (uses Finnhub) ---\n  const fetchAvailableSymbols = useCallback(async () => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      setSymbolError(\"Invalid Finnhub API Key. Cannot fetch US stock symbols.\");\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const {\n        data\n      } = await axios.get(`https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`);\n      const filteredSymbols = data.filter(s => s.type === \"Common Stock\" || s.type === \"ADR\" || s.type === \"REIT\" || s.type === \"ETP\" || s.type === \"ETF\").map(s => s.symbol).sort();\n      setAvailableSymbols(filteredSymbols);\n      setSymbolError(\"\");\n    } catch (error) {\n      console.error(\"Error fetching available symbols:\", error);\n      setSymbolError(\"Failed to fetch US stock symbols. This might be due to API rate limits or an invalid Finnhub API key (free tier keys have limited symbol access).\");\n      setAvailableSymbols([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Calculate PnL and Holdings ---\n  const calculatePnL = useCallback(() => {\n    let holdings = {};\n    let totalRealizedPnl = 0;\n    trades.forEach(trade => {\n      if (!holdings[trade.symbol]) {\n        holdings[trade.symbol] = {\n          symbol: trade.symbol,\n          netQty: 0,\n          totalCost: 0,\n          avgBuyPrice: 0\n        };\n      }\n      if (trade.type === \"buy\") {\n        holdings[trade.symbol].totalCost += trade.quantity * trade.price;\n        holdings[trade.symbol].netQty += trade.quantity;\n        holdings[trade.symbol].avgBuyPrice = holdings[trade.symbol].netQty > 0 ? holdings[trade.symbol].totalCost / holdings[trade.symbol].netQty : 0;\n      } else {\n        // sell\n        const qtySold = trade.quantity;\n        const currentNetQty = holdings[trade.symbol].netQty;\n        const currentAvgBuyPrice = holdings[trade.symbol].avgBuyPrice;\n        if (currentNetQty > 0) {\n          // Only calculate realized PnL if there were holdings to sell against\n          const sellCostBasis = currentAvgBuyPrice * Math.min(qtySold, currentNetQty);\n          const sellProceeds = trade.price * qtySold;\n          totalRealizedPnl += sellProceeds - sellCostBasis;\n        }\n        holdings[trade.symbol].netQty -= qtySold;\n\n        // Adjust totalCost and avgBuyPrice if netQty becomes zero or negative\n        if (holdings[trade.symbol].netQty <= 0) {\n          holdings[trade.symbol].totalCost = 0;\n          holdings[trade.symbol].avgBuyPrice = 0;\n          holdings[trade.symbol].netQty = 0; // Ensure netQty doesn't go negative\n        } else {\n          // If partial sell, new totalCost and avgBuyPrice for remaining shares\n          holdings[trade.symbol].totalCost = holdings[trade.symbol].netQty * holdings[trade.symbol].avgBuyPrice;\n        }\n      }\n    });\n    let totalUnrealizedPnl = 0;\n    Object.values(holdings).forEach(holding => {\n      if (holding.netQty > 0 && livePrices[holding.symbol]) {\n        const livePrice = livePrices[holding.symbol];\n        const unrealized = (livePrice - holding.avgBuyPrice) * holding.netQty;\n        holding.unrealizedPnl = unrealized.toFixed(2);\n        totalUnrealizedPnl += unrealized;\n      } else {\n        holding.unrealizedPnl = \"0.00\";\n      }\n    });\n    return {\n      holdings: Object.values(holdings),\n      totalRealizedPnl: totalRealizedPnl.toFixed(2),\n      totalUnrealizedPnl: totalUnrealizedPnl.toFixed(2)\n    };\n  }, [trades, livePrices]);\n\n  // --- Calculate total portfolio value ---\n  const calculateTotalPortfolioValue = useCallback(() => {\n    const {\n      holdings\n    } = calculatePnL();\n    let holdingsValue = 0;\n    holdings.forEach(holding => {\n      if (holding.netQty > 0 && livePrices[holding.symbol]) {\n        holdingsValue += holding.netQty * livePrices[holding.symbol];\n      }\n    });\n    return (capital + holdingsValue).toFixed(2);\n  }, [capital, calculatePnL, livePrices]);\n\n  // --- Remove trade logic ---\n  const removeTrade = useCallback(async tradeToRemove => {\n    if (!(user !== null && user !== void 0 && user.id)) throw new Error(\"User not authenticated.\");\n    try {\n      const {\n        error: deleteError\n      } = await supabase.from(\"trades\").delete().eq(\"id\", tradeToRemove.id).eq(\"user_id\", user.id);\n      if (deleteError) throw deleteError;\n\n      // Re-fetch all trades to reconstruct history\n      await fetchTrades(user.id);\n\n      // Recalculate capital from scratch based on the new trade history\n      const {\n        data: allTradesAfterDeletion,\n        error: fetchAllTradesError\n      } = await supabase.from(\"trades\").select(\"*\").eq(\"user_id\", user.id).order(\"created_at\", {\n        ascending: true\n      }); // Order by created_at to simulate transaction history\n\n      if (fetchAllTradesError) throw fetchAllTradesError;\n      let recalculatedCapital = 10000; // Start with initial capital\n      allTradesAfterDeletion.forEach(trade => {\n        if (trade.type === 'buy') {\n          recalculatedCapital -= trade.quantity * trade.price;\n        } else {\n          // sell\n          recalculatedCapital += trade.quantity * trade.price;\n        }\n      });\n      await handleSetCapital(recalculatedCapital); // Update capital in DB and state\n    } catch (error) {\n      console.error(\"Error removing trade:\", error.message);\n      throw error;\n    }\n  }, [user, fetchTrades, handleSetCapital]);\n\n  // --- Initial Data Load on Mount or User Change ---\n  useEffect(() => {\n    const {\n      data: authListener\n    } = supabase.auth.onAuthStateChange(async (event, session) => {\n      setSession(session);\n      const currentUser = (session === null || session === void 0 ? void 0 : session.user) || null;\n      setUser(currentUser);\n      if (currentUser) {\n        setLoadingData(true);\n        await fetchCapital(currentUser.id);\n        await fetchTrades(currentUser.id);\n        await fetchWatchlist(currentUser.id);\n        setLoadingData(false);\n      } else {\n        setCapital(10000); // Reset to initial capital for logged-out state\n        setTrades([]);\n        setWatchListSymbols([]);\n        setLivePrices({});\n        setUser(null);\n        setLoadingData(false);\n      }\n    });\n\n    // Initial check for session on component mount\n    const checkSession = async () => {\n      setLoadingData(true);\n      const {\n        data: {\n          session\n        }\n      } = await supabase.auth.getSession();\n      setSession(session);\n      const currentUser = (session === null || session === void 0 ? void 0 : session.user) || null;\n      setUser(currentUser);\n      if (currentUser) {\n        await fetchCapital(currentUser.id);\n        await fetchTrades(currentUser.id);\n        await fetchWatchlist(currentUser.id);\n      }\n      setLoadingData(false);\n    };\n    checkSession();\n    fetchAvailableSymbols(); // Fetch symbols once on load for everyone\n\n    return () => {\n      authListener.subscription.unsubscribe();\n    };\n  }, [fetchCapital, fetchTrades, fetchAvailableSymbols, fetchWatchlist]); // Dependencies for initial data load\n\n  // --- Effect to fetch live prices for all relevant symbols ---\n  useEffect(() => {\n    // Combine symbols from trades and watchlist\n    const allSymbols = [...new Set([...trades.map(t => t.symbol), ...watchListSymbols])].filter(Boolean); // Filter out any null/undefined/empty symbols\n\n    if (allSymbols.length > 0) {\n      // Fetch immediately\n      fetchLivePrices(allSymbols);\n\n      // Set up interval for periodic refresh\n      const interval = setInterval(() => {\n        fetchLivePrices(allSymbols);\n      }, 20000); // Every 20 seconds\n\n      return () => clearInterval(interval); // Cleanup on unmount or dependency change\n    }\n  }, [trades, watchListSymbols, fetchLivePrices]); // Re-run if trades or watchlist change\n\n  // Memoize the context value to prevent unnecessary re-renders\n  const contextValue = useMemo(() => ({\n    user,\n    trades,\n    capital,\n    setCapital: handleSetCapital,\n    // Use the wrapped function\n    livePrices,\n    availableSymbols,\n    symbolError,\n    setSymbolError,\n    fetchTrades,\n    fetchLivePrices,\n    calculatePnL,\n    calculateTotalPortfolioValue,\n    loadingData,\n    removeTrade,\n    watchListSymbols,\n    addToWatchlist,\n    removeFromWatchlist\n  }), [user, trades, capital, handleSetCapital, livePrices, availableSymbols, symbolError, setSymbolError, fetchTrades, fetchLivePrices, calculatePnL, calculateTotalPortfolioValue, loadingData, removeTrade, addToWatchlist, removeFromWatchlist, watchListSymbols]);\n  return /*#__PURE__*/_jsxDEV(TradingDataContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 513,\n    columnNumber: 5\n  }, this);\n};\n_s(TradingDataProvider, \"aQU4mF18P02JepaGsj1qhJ2IqEU=\");\n_c = TradingDataProvider;\nexport const useTradingData = () => {\n  _s2();\n  const context = useContext(TradingDataContext);\n  if (context === undefined) {\n    throw new Error(\"useTradingData must be used within a TradingDataProvider\");\n  }\n  return context;\n};\n_s2(useTradingData, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"TradingDataProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useCallback","useMemo","supabase","axios","jsxDEV","_jsxDEV","FINNHUB_API_KEY","ALPHA_VANTAGE_API_KEY","CURRENCY_SYMBOL","process","env","REACT_APP_CURRENCY_SYMBOL","isInvalidApiKey","key","trimmedKey","trim","length","TradingDataContext","TradingDataProvider","children","_s","user","setUser","trades","setTrades","capital","setCapital","livePrices","setLivePrices","availableSymbols","setAvailableSymbols","symbolError","setSymbolError","loadingData","setLoadingData","session","setSession","watchListSymbols","setWatchListSymbols","fetchLivePrices","symbolsToFetch","uniqueSymbols","Set","filter","s","prev","newPrices","forEach","sym","responses","Promise","all","map","symbol","get","res","index","data","c","error","console","errorPrices","fetchCapital","userId","from","select","eq","single","code","newProfile","insertError","insert","user_id","message","updateCapitalInDb","newCapital","warn","update","handleSetCapital","id","fetchTrades","order","ascending","fetchWatchlist","item","addToWatchlist","Error","normalizedSymbol","toUpperCase","includes","removeFromWatchlist","delete","fetchAvailableSymbols","filteredSymbols","type","sort","calculatePnL","holdings","totalRealizedPnl","trade","netQty","totalCost","avgBuyPrice","quantity","price","qtySold","currentNetQty","currentAvgBuyPrice","sellCostBasis","Math","min","sellProceeds","totalUnrealizedPnl","Object","values","holding","livePrice","unrealized","unrealizedPnl","toFixed","calculateTotalPortfolioValue","holdingsValue","removeTrade","tradeToRemove","deleteError","allTradesAfterDeletion","fetchAllTradesError","recalculatedCapital","authListener","auth","onAuthStateChange","event","currentUser","checkSession","getSession","subscription","unsubscribe","allSymbols","t","Boolean","interval","setInterval","clearInterval","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useTradingData","_s2","context","undefined","$RefreshReg$"],"sources":["/Users/aryansrivastava/projects/Paper-Trading-Portal/src/TradingDataContext.js"],"sourcesContent":["// src/TradingDataContext.js\nimport React, { createContext, useContext, useState, useEffect, useCallback, useMemo } from \"react\";\nimport { supabase } from \"./supabaseClient\";\nimport axios from \"axios\";\n\n// Constants for API Key and Currency Symbol\n// WARNING: Hardcoding API keys directly in source code is not recommended for security.\n// Consider using environment variables (.env file) for production deployment.\n\nexport const FINNHUB_API_KEY = \"d108911r01qhkqr8ggb0d108911r01qhkqr8ggbg\"; // YOUR FINNHUB API KEY\nexport const ALPHA_VANTAGE_API_KEY = \"DR0O9MY1P0QU6ZEL\"; // YOUR ALPHA VANTAGE API KEY HERE\nexport const CURRENCY_SYMBOL = process.env.REACT_APP_CURRENCY_SYMBOL || \"$\";\n\n// Helper to check if API key is valid (simple check)\nexport const isInvalidApiKey = (key) => {\n  const trimmedKey = key ? key.trim() : '';\n  // Check for empty string, Finnhub placeholder, or Alpha Vantage placeholder\n  return !trimmedKey || trimmedKey === \"YOUR_FINNHUB_API_KEY_HERE\" || trimmedKey === \"YOUR_ALPHA_VANTAGE_API_KEY\" || trimmedKey.length < 10;\n};\n\nconst TradingDataContext = createContext();\n\nexport const TradingDataProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [trades, setTrades] = useState([]);\n  const [capital, setCapital] = useState(10000); // Initial capital\n  const [livePrices, setLivePrices] = useState({});\n  const [availableSymbols, setAvailableSymbols] = useState([]);\n  const [symbolError, setSymbolError] = useState(\"\");\n  const [loadingData, setLoadingData] = useState(true);\n  const [session, setSession] = useState(null); // Supabase session\n  const [watchListSymbols, setWatchListSymbols] = useState([]);\n\n  // --- Fetch live prices for a given list of symbols (uses Finnhub) ---\n  const fetchLivePrices = useCallback(async (symbolsToFetch) => {\n    const uniqueSymbols = [...new Set(symbolsToFetch)].filter(s => s && typeof s === 'string');\n\n    if (uniqueSymbols.length === 0 || isInvalidApiKey(FINNHUB_API_KEY)) {\n      setLivePrices((prev) => {\n        const newPrices = {};\n        if (uniqueSymbols.length === 0) return prev;\n\n        uniqueSymbols.forEach(sym => {\n            if (prev[sym]) newPrices[sym] = prev[sym];\n        });\n        return newPrices;\n      });\n      return;\n    }\n\n    try {\n      const responses = await Promise.all(\n        uniqueSymbols.map((symbol) =>\n          axios.get(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`)\n        )\n      );\n\n      const newPrices = {};\n      responses.forEach((res, index) => {\n        const symbol = uniqueSymbols[index];\n        if (res.data && res.data.c !== 0) {\n          newPrices[symbol] = res.data.c;\n        } else {\n          newPrices[symbol] = null; // Mark as unavailable\n        }\n      });\n\n      setLivePrices((prev) => ({ ...prev, ...newPrices }));\n    } catch (error) {\n      console.error(\"Error fetching live prices:\", error);\n      const errorPrices = {};\n      uniqueSymbols.forEach(symbol => { errorPrices[symbol] = null; });\n      setLivePrices((prev) => ({ ...prev, ...errorPrices }));\n    }\n  }, []);\n\n  // --- Helper to fetch user's capital from Supabase ---\n  const fetchCapital = useCallback(async (userId) => {\n    if (!userId) {\n      setCapital(10000);\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { data, error } = await supabase\n        .from(\"user_profiles\")\n        .select(\"capital\")\n        .eq(\"user_id\", userId)\n        .single();\n\n      if (error && error.code !== 'PGRST116') { // PGRST116 means \"no row found\"\n        throw error;\n      }\n\n      if (data) {\n        setCapital(data.capital);\n      } else {\n        // If no profile exists, create one with initial capital\n        const { data: newProfile, error: insertError } = await supabase\n          .from(\"user_profiles\")\n          .insert([{ user_id: userId, capital: 10000 }])\n          .select(\"capital\")\n          .single();\n\n        if (insertError) throw insertError;\n        setCapital(newProfile.capital);\n      }\n    } catch (error) {\n      console.error(\"Error fetching or setting capital:\", error.message);\n      setCapital(10000); // Default to initial capital on error\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Function to update capital in Supabase ---\n  const updateCapitalInDb = useCallback(async (newCapital, userId) => {\n    if (!userId) {\n      console.warn(\"updateCapitalInDb: No user ID, not updating DB.\");\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { error } = await supabase\n        .from(\"user_profiles\")\n        .update({ capital: newCapital })\n        .eq(\"user_id\", userId);\n\n      if (error) throw error;\n      setCapital(newCapital); // Update local state after successful DB update\n    } catch (error) {\n      console.error(\"Error updating capital in DB:\", error.message);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Wrapped setCapital to update DB as well ---\n  const handleSetCapital = useCallback(async (newCapital) => {\n    setCapital(newCapital); // Optimistically update local state\n    if (user?.id) {\n      await updateCapitalInDb(newCapital, user.id);\n    } else {\n      console.warn(\"No user ID available for DB capital update.\");\n    }\n  }, [user, updateCapitalInDb]);\n\n  // --- Fetch trades for the current user ---\n  const fetchTrades = useCallback(async (userId) => {\n    if (!userId) {\n      setTrades([]);\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { data, error } = await supabase\n        .from(\"trades\")\n        .select(\"*\")\n        .eq(\"user_id\", userId)\n        .order(\"created_at\", { ascending: false });\n\n      if (error) throw error;\n      setTrades(data);\n    } catch (error) {\n      console.error(\"Error fetching trades:\", error.message);\n      setTrades([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Fetch watchlist symbols for the current user ---\n  const fetchWatchlist = useCallback(async (userId) => {\n    if (!userId) {\n      setWatchListSymbols([]);\n      return;\n    }\n    try {\n      const { data, error } = await supabase\n        .from(\"watchlists\")\n        .select(\"symbol\")\n        .eq(\"user_id\", userId)\n        .order(\"created_at\", { ascending: true });\n\n      if (error) throw error;\n      setWatchListSymbols(data.map(item => item.symbol));\n    } catch (error) {\n      console.error(\"Error fetching watchlist:\", error.message);\n      setWatchListSymbols([]);\n    }\n  }, []);\n\n  // --- Add symbol to watchlist ---\n  const addToWatchlist = useCallback(async (symbol) => {\n    if (!user?.id) {\n      throw new Error(\"User not authenticated.\");\n    }\n    const normalizedSymbol = symbol.toUpperCase();\n    if (watchListSymbols.includes(normalizedSymbol)) {\n      throw new Error(`'${normalizedSymbol}' is already in your watchlist.`);\n    }\n\n    try {\n      const { data, error } = await supabase\n        .from(\"watchlists\")\n        .insert([{ user_id: user.id, symbol: normalizedSymbol }])\n        .select(\"symbol\")\n        .single();\n\n      if (error) throw error;\n      setWatchListSymbols((prev) => [...prev, data.symbol]);\n      fetchLivePrices([normalizedSymbol]);\n    } catch (error) {\n      console.error(\"Error adding to watchlist:\", error.message);\n      throw error;\n    }\n  }, [user, watchListSymbols, fetchLivePrices]);\n\n  // --- Remove symbol from watchlist ---\n  const removeFromWatchlist = useCallback(async (symbol) => {\n    if (!user?.id) {\n      throw new Error(\"User not authenticated.\");\n    }\n    try {\n      const { error } = await supabase\n        .from(\"watchlists\")\n        .delete()\n        .eq(\"user_id\", user.id)\n        .eq(\"symbol\", symbol.toUpperCase());\n\n      if (error) throw error;\n      setWatchListSymbols((prev) => prev.filter((s) => s !== symbol.toUpperCase()));\n      setLivePrices((prev) => { // Clear live price for removed symbol if not needed elsewhere\n        const newPrices = { ...prev };\n        delete newPrices[symbol.toUpperCase()];\n        return newPrices;\n      });\n    } catch (error) {\n      console.error(\"Error removing from watchlist:\", error.message);\n      throw error;\n    }\n  }, [user]);\n\n  // --- Fetch available US stock symbols from Finnhub (uses Finnhub) ---\n  const fetchAvailableSymbols = useCallback(async () => {\n    if (isInvalidApiKey(FINNHUB_API_KEY)) {\n      setSymbolError(\"Invalid Finnhub API Key. Cannot fetch US stock symbols.\");\n      return;\n    }\n    setLoadingData(true);\n    try {\n      const { data } = await axios.get(\n        `https://finnhub.io/api/v1/stock/symbol?exchange=US&token=${FINNHUB_API_KEY}`\n      );\n      const filteredSymbols = data\n        .filter(\n          (s) =>\n            s.type === \"Common Stock\" ||\n            s.type === \"ADR\" ||\n            s.type === \"REIT\" ||\n            s.type === \"ETP\" ||\n            s.type === \"ETF\"\n        )\n        .map((s) => s.symbol)\n        .sort();\n\n      setAvailableSymbols(filteredSymbols);\n      setSymbolError(\"\");\n    } catch (error) {\n      console.error(\"Error fetching available symbols:\", error);\n      setSymbolError(\n        \"Failed to fetch US stock symbols. This might be due to API rate limits or an invalid Finnhub API key (free tier keys have limited symbol access).\"\n      );\n      setAvailableSymbols([]);\n    } finally {\n      setLoadingData(false);\n    }\n  }, []);\n\n  // --- Calculate PnL and Holdings ---\n  const calculatePnL = useCallback(() => {\n    let holdings = {};\n    let totalRealizedPnl = 0;\n\n    trades.forEach((trade) => {\n      if (!holdings[trade.symbol]) {\n        holdings[trade.symbol] = {\n          symbol: trade.symbol,\n          netQty: 0,\n          totalCost: 0,\n          avgBuyPrice: 0,\n        };\n      }\n\n      if (trade.type === \"buy\") {\n        holdings[trade.symbol].totalCost += trade.quantity * trade.price;\n        holdings[trade.symbol].netQty += trade.quantity;\n        holdings[trade.symbol].avgBuyPrice =\n          holdings[trade.symbol].netQty > 0 ? holdings[trade.symbol].totalCost / holdings[trade.symbol].netQty : 0;\n      } else { // sell\n        const qtySold = trade.quantity;\n        const currentNetQty = holdings[trade.symbol].netQty;\n        const currentAvgBuyPrice = holdings[trade.symbol].avgBuyPrice;\n\n        if (currentNetQty > 0) { // Only calculate realized PnL if there were holdings to sell against\n            const sellCostBasis = (currentAvgBuyPrice * Math.min(qtySold, currentNetQty));\n            const sellProceeds = trade.price * qtySold;\n            totalRealizedPnl += (sellProceeds - sellCostBasis);\n        }\n\n        holdings[trade.symbol].netQty -= qtySold;\n        \n        // Adjust totalCost and avgBuyPrice if netQty becomes zero or negative\n        if (holdings[trade.symbol].netQty <= 0) {\n          holdings[trade.symbol].totalCost = 0;\n          holdings[trade.symbol].avgBuyPrice = 0;\n          holdings[trade.symbol].netQty = 0; // Ensure netQty doesn't go negative\n        } else {\n             // If partial sell, new totalCost and avgBuyPrice for remaining shares\n             holdings[trade.symbol].totalCost = holdings[trade.symbol].netQty * holdings[trade.symbol].avgBuyPrice;\n        }\n      }\n    });\n\n    let totalUnrealizedPnl = 0;\n    Object.values(holdings).forEach((holding) => {\n      if (holding.netQty > 0 && livePrices[holding.symbol]) {\n        const livePrice = livePrices[holding.symbol];\n        const unrealized = (livePrice - holding.avgBuyPrice) * holding.netQty;\n        holding.unrealizedPnl = unrealized.toFixed(2);\n        totalUnrealizedPnl += unrealized;\n      } else {\n        holding.unrealizedPnl = \"0.00\";\n      }\n    });\n\n    return {\n      holdings: Object.values(holdings),\n      totalRealizedPnl: totalRealizedPnl.toFixed(2),\n      totalUnrealizedPnl: totalUnrealizedPnl.toFixed(2),\n    };\n  }, [trades, livePrices]);\n\n  // --- Calculate total portfolio value ---\n  const calculateTotalPortfolioValue = useCallback(() => {\n    const { holdings } = calculatePnL();\n    let holdingsValue = 0;\n    holdings.forEach(holding => {\n      if (holding.netQty > 0 && livePrices[holding.symbol]) {\n        holdingsValue += holding.netQty * livePrices[holding.symbol];\n      }\n    });\n    return (capital + holdingsValue).toFixed(2);\n  }, [capital, calculatePnL, livePrices]);\n\n  // --- Remove trade logic ---\n  const removeTrade = useCallback(async (tradeToRemove) => {\n    if (!user?.id) throw new Error(\"User not authenticated.\");\n\n    try {\n      const { error: deleteError } = await supabase\n        .from(\"trades\")\n        .delete()\n        .eq(\"id\", tradeToRemove.id)\n        .eq(\"user_id\", user.id);\n\n      if (deleteError) throw deleteError;\n\n      // Re-fetch all trades to reconstruct history\n      await fetchTrades(user.id);\n\n      // Recalculate capital from scratch based on the new trade history\n      const { data: allTradesAfterDeletion, error: fetchAllTradesError } = await supabase\n          .from(\"trades\")\n          .select(\"*\")\n          .eq(\"user_id\", user.id)\n          .order(\"created_at\", { ascending: true }); // Order by created_at to simulate transaction history\n\n      if (fetchAllTradesError) throw fetchAllTradesError;\n\n      let recalculatedCapital = 10000; // Start with initial capital\n      allTradesAfterDeletion.forEach(trade => {\n          if (trade.type === 'buy') {\n              recalculatedCapital -= (trade.quantity * trade.price);\n          } else { // sell\n              recalculatedCapital += (trade.quantity * trade.price);\n          }\n      });\n\n      await handleSetCapital(recalculatedCapital); // Update capital in DB and state\n      \n    } catch (error) {\n      console.error(\"Error removing trade:\", error.message);\n      throw error;\n    }\n  }, [user, fetchTrades, handleSetCapital]);\n\n  // --- Initial Data Load on Mount or User Change ---\n  useEffect(() => {\n    const { data: authListener } = supabase.auth.onAuthStateChange(\n      async (event, session) => {\n        setSession(session);\n        const currentUser = session?.user || null;\n        setUser(currentUser);\n\n        if (currentUser) {\n          setLoadingData(true);\n          await fetchCapital(currentUser.id);\n          await fetchTrades(currentUser.id);\n          await fetchWatchlist(currentUser.id);\n          setLoadingData(false);\n        } else {\n          setCapital(10000); // Reset to initial capital for logged-out state\n          setTrades([]);\n          setWatchListSymbols([]);\n          setLivePrices({});\n          setUser(null);\n          setLoadingData(false);\n        }\n      }\n    );\n\n    // Initial check for session on component mount\n    const checkSession = async () => {\n      setLoadingData(true);\n      const { data: { session } } = await supabase.auth.getSession();\n      setSession(session);\n      const currentUser = session?.user || null;\n      setUser(currentUser);\n\n      if (currentUser) {\n        await fetchCapital(currentUser.id);\n        await fetchTrades(currentUser.id);\n        await fetchWatchlist(currentUser.id);\n      }\n      setLoadingData(false);\n    };\n\n    checkSession();\n    fetchAvailableSymbols(); // Fetch symbols once on load for everyone\n\n    return () => {\n      authListener.subscription.unsubscribe();\n    };\n  }, [fetchCapital, fetchTrades, fetchAvailableSymbols, fetchWatchlist]); // Dependencies for initial data load\n\n  // --- Effect to fetch live prices for all relevant symbols ---\n  useEffect(() => {\n    // Combine symbols from trades and watchlist\n    const allSymbols = [\n      ...new Set([\n        ...trades.map((t) => t.symbol),\n        ...watchListSymbols,\n      ])\n    ].filter(Boolean); // Filter out any null/undefined/empty symbols\n\n    if (allSymbols.length > 0) {\n      // Fetch immediately\n      fetchLivePrices(allSymbols);\n\n      // Set up interval for periodic refresh\n      const interval = setInterval(() => {\n        fetchLivePrices(allSymbols);\n      }, 20000); // Every 20 seconds\n\n      return () => clearInterval(interval); // Cleanup on unmount or dependency change\n    }\n  }, [trades, watchListSymbols, fetchLivePrices]); // Re-run if trades or watchlist change\n\n  // Memoize the context value to prevent unnecessary re-renders\n  const contextValue = useMemo(\n    () => ({\n      user,\n      trades,\n      capital,\n      setCapital: handleSetCapital, // Use the wrapped function\n      livePrices,\n      availableSymbols,\n      symbolError,\n      setSymbolError,\n      fetchTrades,\n      fetchLivePrices,\n      calculatePnL,\n      calculateTotalPortfolioValue,\n      loadingData,\n      removeTrade,\n      watchListSymbols,\n      addToWatchlist,\n      removeFromWatchlist,\n    }),\n    [\n      user,\n      trades,\n      capital,\n      handleSetCapital,\n      livePrices,\n      availableSymbols,\n      symbolError,\n      setSymbolError,\n      fetchTrades,\n      fetchLivePrices,\n      calculatePnL,\n      calculateTotalPortfolioValue,\n      loadingData,\n      removeTrade,\n      addToWatchlist,\n      removeFromWatchlist,\n      watchListSymbols,\n    ]\n  );\n\n  return (\n    <TradingDataContext.Provider value={contextValue}>\n      {children}\n    </TradingDataContext.Provider>\n  );\n};\n\nexport const useTradingData = () => {\n  const context = useContext(TradingDataContext);\n  if (context === undefined) {\n    throw new Error(\"useTradingData must be used within a TradingDataProvider\");\n  }\n  return context;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}